<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mufool</title>
  
  <subtitle>my blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mufool.com/"/>
  <updated>2017-11-20T10:53:30.604Z</updated>
  <id>http://mufool.com/</id>
  
  <author>
    <name>Mufool</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FM原理和使用</title>
    <link href="http://mufool.com/2017/11/20/fm/"/>
    <id>http://mufool.com/2017/11/20/fm/</id>
    <published>2017-11-20T10:49:12.000Z</published>
    <updated>2017-11-20T10:53:30.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FM算法，全称Factorization Machines,一般翻译为“因子分解机”。2010年，它由当时还在日本大阪大学的Steffen Rendle提出。此算法的主要作用是可以把所有特征进行高阶组合，减少人工参与特征组合的工作，工程师可以将精力集中在模型参数调优。FM只需要线性时间复杂度，可以应用于大规模机器学习。经过部分数据集试验，此算法在稀疏数据集合上的效果要明显好于SVM。</p><a id="more"></a><h2 id="模型形式"><a href="#模型形式" class="headerlink" title="模型形式"></a>模型形式</h2><p>在线性回归模型中，每个feature具有一个权重，参数求解过程相当于构造一个超平面将空间分为两部分。线性回归最大的优点是简单高效，只需要计算好每个feature的权重。但是缺点也是模型比较简单，只能建模线性关系（不过大部分时候也够用了，不够用时可以用特征工程）。</p><p>传统线性回归基于以下模型，从模型方程易见，各特征分量xi和xj是相互独立。</p><p><img src="http://mufool.qiniudn.com/fm/fm1.jpg" alt="image"><br>但是，一般线性模型无法学习到高阶组合特征，所以会将特征进行高阶组合，这里以二阶为例(理论上，FM可以组合任意高阶，但是由于计算复杂度，实际中常用二阶，后面也主要介绍二阶组合的内容)。模型形式为，</p><p><img src="http://mufool.qiniudn.com/fm/fm2.jpg" alt="image"></p><p>相比于线性模型而言，二阶模型多了n(n−1)2参数。比如有(n=)1000个特征（连续变量离散化，并one-hot编码，特征很容易到达此量级），增加近50万个参数。</p><p>FM使用近似矩阵分解。将参数量级减少成线性量级。可以将所有参数Wij组合成一个矩阵。</p><p><img src="http://mufool.qiniudn.com/fm/fm3.jpg" alt="image"></p><p><img src="http://mufool.qiniudn.com/fm/fm4.jpg" alt="image"><br>很明显，实数矩阵W是对称的。所以，实对称矩阵W正定（至少半正定，这里假设正定）。根据矩阵的性质，正定矩阵可以分解。</p><p>定理：当k足够大时，对于任意对称正定矩阵<br><img src="http://mufool.qiniudn.com/fm/fm5.jpg" alt="image"><br>存在矩阵</p><p><img src="http://mufool.qiniudn.com/fm/fm6.jpg" alt="image"></p><p>使得<br><img src="http://mufool.qiniudn.com/fm/fm7.jpg" alt="image"></p><p>带入后，模型如下<br><img src="http://mufool.qiniudn.com/fm/fm8.jpg" alt="image"></p><p>问题从求解矩阵W变成了求解矩阵V</p><p>这样做的有点：</p><ul><li>W需要求解的参数个数为n<em>n，V需要求解的个数为n</em>k，k是一个可调整的参数，通常远远小于n</li><li>上面说过为求解wij，需要大量同时不为0的xi，xj，这个几乎是不可解的，没有那么多的样本。参数因子化使得 xhxi的参数和 xixj 的参数不再是相互独立的，因此我们可以在样本稀疏的情况下相对合理地估计FM的二次项参数。具体来说，xhxi 和 xixj 的系数分别为 <vh,vi> 和 <vi,vj>，它们之间有共同项 vi。也就是说，所有包含“xi的非零组合特征”（存在某个 j≠i，使得 xixj≠0）的样本都可以用来学习隐向量 vi，这很大程度上避免了数据稀疏性造成的影响。而在多项式模型中，whi 和 wij 是相互独立的。</vi,vj></vh,vi></li></ul><p>总的来说，计算效率得到质提升是因为使用近似计算，将参数复杂度从O(n2)降到O(n)。之前工作中遇到的介数估算，也使用类似套路，减少计算时间复杂度。</p><h2 id="FM实践"><a href="#FM实践" class="headerlink" title="FM实践"></a>FM实践</h2><p>使用真实环境中用户的数据测试一下几个FM库，测试样本共800万条，正负样本各一半，特征为325个。因为本例是点击率预测的，所以属于二分类问题。</p><h3 id="libfm使用示例"><a href="#libfm使用示例" class="headerlink" title="libfm使用示例"></a>libfm使用示例</h3><p>训练<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./libFM -task c -train /opt/hadoop/hadoop-2.6.5/train1.txt -test /opt/hadoop/hadoop-2.6.5/test1.txt -rlog ./log.txt -dim &apos;1,1,16&apos; -iter 10 -init_stdev 0.001 -method sgd -learn_rate 0.001  -regular &apos;0,0,0.001&apos; -save_model mode.fm -out model.txt</div></pre></td></tr></table></figure></p><p>预测，<code>-iter</code>设置为0即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./libFM -task c -train /opt/hadoop/hadoop-2.6.5/train1.txt -test /opt/hadoop/hadoop-2.6.5/test1.txt -rlog ./log.txt -dim &apos;1,1,16&apos; -iter 0 -init_stdev 0.001 -method sgd -learn_rate 0.001  -regular &apos;0,0,0.001&apos; -load_model mode.fm -out model.txt</div></pre></td></tr></table></figure></p><p>rlog.txt为输出的log文件，对于回归输出的是均方差；对于分类输出为准确率。</p><h3 id="fastFM使用"><a href="#fastFM使用" class="headerlink" title="fastFM使用"></a>fastFM使用</h3><p>支持tests目录下的例子即可，对于als的使用，可能会报错，需要修改源码中报错部分再安装。</p><h3 id="alphaFM使用"><a href="#alphaFM使用" class="headerlink" title="alphaFM使用"></a>alphaFM使用</h3><p>训练<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat train1.txt | /opt/hadoop/alphaFM-master/bin/fm_train -dim 1,1,16 -m /opt/hadoop/hadoop-2.6.5/model_file.txt -w_l1 0.05 -v_l1 0.05 -init_stdev 0.001 -w_alpha 0.01 -v_alpha 0.01 -core 10</div></pre></td></tr></table></figure></p><p>预测<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/hdfs dfs -cat /fmdata/20171107/part-*| /opt/hadoop/alphaFM-master/bin/fm_predict -dim 8 -m /opt/hadoop/hadoop-2.6.5/model_file.txt -out fm_pre.txt -core 10</div></pre></td></tr></table></figure></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th>FM库</th><th>语言</th><th>训练时间</th><th>准确性</th><th>接口</th><th>其他</th></tr></thead><tbody><tr><td><a href="https://github.com/srendle/libfm" target="_blank" rel="external">libfm</a></td><td>C++11</td><td>5min</td><td>73%</td><td>命令行，支持模型保存和载入</td><td>基于paper的实现，支持SGD, SGDA, ALS和MCMC</td></tr><tr><td><a href="https://github.com/jfloff/pywFM" target="_blank" rel="external">pywFM</a></td><td>python</td><td>5min</td><td>同上</td><td>类sklearn接口，支持模型保存和载入</td><td>python封装的libfm</td></tr><tr><td><a href="http://geek.csdn.net/news/detail/112231" target="_blank" rel="external">alphaFM</a></td><td>C++11</td><td>2min</td><td>71%</td><td>命令行，支持模型保存和载入</td><td>支持多线程，基于FTRL算法实现</td></tr><tr><td><a href="https://github.com/ibayer/fastFM" target="_blank" rel="external">fastFM</a></td><td>python，c</td><td>8min</td><td>sgd:61% als:73% mcmc:76%</td><td>类sklearn接口，mcmc不支持模型保存载入</td><td>SGD, ALS和MCMC</td></tr><tr><td><a href="https://github.com/coreylynch/pyFM" target="_blank" rel="external">pyFM</a></td><td>python，c</td><td>大数据量无法计算</td><td>无</td><td>类sklearn接口，支持模型保存和载入</td><td>基于SGDA算法实现</td></tr><tr><td><a href="https://github.com/geffy/tffm/tree/master/tffm" target="_blank" rel="external">Factorization Machines with libFM (Python/TensorFlow)</a></td><td>python</td><td>未测试</td><td></td><td></td></tr><tr><td><a href="https://github.com/zhengruifeng/spark-libFM" target="_blank" rel="external">spark-libFM</a></td><td>scala</td><td>未测试</td><td></td><td></td></tr><tr><td><a href="https://github.com/dmlc/difacto" target="_blank" rel="external">DiFacto</a></td><td>c++</td><td>未测试</td><td></td></tr></tbody></table><h2 id="FFM"><a href="#FFM" class="headerlink" title="FFM"></a>FFM</h2><p>FM有一个衍生算法FFM（Field-aware FM），大概思路是将特征进行分组，学习出更多的隐式向量V，FM可以看做FFM只有一个分组的特例。FFM复杂度比较高，比较适合高度稀疏数据；而FM可以应用于非稀疏数据，更加通用。</p><p>参考：<br><a href="http://www.libfm.org/libfm-1.42.manual.pdf" target="_blank" rel="external">libfm使用文档</a><br><a href="http://d0evi1.com/libfm/" target="_blank" rel="external">libfm中文翻译</a><br><a href="http://ibayer.github.io/fastFM/guide.html" target="_blank" rel="external">fastFM文档</a><br><a href="http://www.tk4479.net/jiangda_0_0/article/details/77510029" target="_blank" rel="external">FM算法和fastFM包的使用介绍</a><br><a href="http://castellanzhang.github.io/2016/10/16/fm_ftrl_softmax/" target="_blank" rel="external">FM, FTRL, Softmax</a><br><a href="https://github.com/arogozhnikov/arogozhnikov.github.io/blob/master/notebooks/2016-02-15-TestingLibFM.ipynb" target="_blank" rel="external">老外的测试结果</a><br><a href="https://tech.meituan.com/deep-understanding-of-ffm-principles-and-practices.html" target="_blank" rel="external">美团fm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;FM算法，全称Factorization Machines,一般翻译为“因子分解机”。2010年，它由当时还在日本大阪大学的Steffen Rendle提出。此算法的主要作用是可以把所有特征进行高阶组合，减少人工参与特征组合的工作，工程师可以将精力集中在模型参数调优。FM只需要线性时间复杂度，可以应用于大规模机器学习。经过部分数据集试验，此算法在稀疏数据集合上的效果要明显好于SVM。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://mufool.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python使用国内源下载</title>
    <link href="http://mufool.com/2017/11/16/python-mirrors/"/>
    <id>http://mufool.com/2017/11/16/python-mirrors/</id>
    <published>2017-11-16T08:54:00.000Z</published>
    <updated>2017-11-16T08:55:12.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>通过pip安装scipy、scikit-learn等库的时候，可能会报上面的错误</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ReadTimeoutError: HTTPSConnectionPool(host=&apos;pypi.python.org&apos;, port=443): Read timed out.</div></pre></td></tr></table></figure><h2 id="原因及解决方法"><a href="#原因及解决方法" class="headerlink" title="原因及解决方法"></a>原因及解决方法</h2><p>以上原因是因为默认使用国外源进行下载，下载速度慢导致超时。解决方法更换成国内园即可。</p><p>国内源：</p><ul><li><a href="http://pypi.douban.com/" target="_blank" rel="external">http://pypi.douban.com/</a>  豆瓣</li><li><a href="http://pypi.hustunique.com/" target="_blank" rel="external">http://pypi.hustunique.com/</a>  华中理工大学</li><li><a href="http://pypi.sdutlinux.org/" target="_blank" rel="external">http://pypi.sdutlinux.org/</a>  山东理工大学</li><li><a href="http://pypi.mirrors.ustc.edu.cn/" target="_blank" rel="external">http://pypi.mirrors.ustc.edu.cn/</a>  中国科学技术大学</li></ul><p>下载时指定源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip  install --index https://pypi.mirrors.ustc.edu.cn/simple/  scikit-learn</div></pre></td></tr></table></figure><p>或者，更改默认的配置，创建~/.pip/pip.conf，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[global]</div><div class="line">index-url = https://pypi.mirrors.ustc.edu.cn/simple/</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;通过pip安装scipy、scikit-learn等库的时候，可能会报上面的错误&lt;/p&gt;
    
    </summary>
    
    
      <category term="PYTHON" scheme="http://mufool.com/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>Zeppelin中文文档</title>
    <link href="http://mufool.com/2017/11/16/zeppelin/"/>
    <id>http://mufool.com/2017/11/16/zeppelin/</id>
    <published>2017-11-16T08:52:46.000Z</published>
    <updated>2017-11-16T08:55:48.116Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://cwiki.apachecn.org/display/Zeppelin/Index" target="_blank" rel="external">Apache Zeppelin 0.7.2 中文文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://cwiki.apachecn.org/display/Zeppelin/Index&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Zeppelin 0.7.2 中文文档&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="SPARK" scheme="http://mufool.com/tags/SPARK/"/>
    
  </entry>
  
  <entry>
    <title>Centos升级gcc版本</title>
    <link href="http://mufool.com/2017/11/16/gcc-update/"/>
    <id>http://mufool.com/2017/11/16/gcc-update/</id>
    <published>2017-11-16T08:46:15.000Z</published>
    <updated>2017-11-16T08:58:04.677Z</updated>
    
    <content type="html"><![CDATA[<ol><li>下载源码包</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://ftp.gnu.org/gnu/gcc/gcc-4.8.0/gcc-4.8.0.tar.bz2</div></pre></td></tr></table></figure><p>　　<br>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -jxvf  gcc-4.8.0.tar.bz2</div></pre></td></tr></table></figure><ol><li>下载编译所需依赖库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd gcc-4.8.0　</div><div class="line">./contrib/download_prerequisites　</div><div class="line">cd ..</div></pre></td></tr></table></figure><ol><li>建立编译输出目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir gcc-build-4.8.0</div></pre></td></tr></table></figure><ol><li>进入此目录，执行以下命令，生成makefile文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd  gcc-build-4.8.0</div><div class="line">../gcc-4.8.0/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</div></pre></td></tr></table></figure><ol><li>编译</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make -j4</div></pre></td></tr></table></figure><p>如果编译成功，则时间是比较长的，半个小时左右，所以如果你看它一直在输出没有立刻停下来，应该很开心！</p><ol><li>安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo make install</div></pre></td></tr></table></figure><ol><li>切换GCC到新版</li></ol><p>确定新安装的GCC的路径,一般默认在/usr/local/bin下。可以先<code>updatedb</code>,然后<code>locate gcc-4.8|tail</code>找一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls /usr/local/bin | grep gcc</div></pre></td></tr></table></figure><p>添加新GCC到可选项，倒数第三个是名字，倒数第二个参数为新GCC路径，最后一个参数40为优先级，设大一些之后就自动使用新版了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update-alternatives --install /usr/bin/gcc gcc /usr/local/bin/i686-pc-linux-gnu-gcc 40</div></pre></td></tr></table></figure><ol><li>确认当前版本已经切换为新版</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -v</div></pre></td></tr></table></figure><p>我这里用ssh远程的，发现版本没变，断开重练下，重新生成会话后发现变成了4.8了！</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;下载源码包&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="GCC" scheme="http://mufool.com/tags/GCC/"/>
    
  </entry>
  
  <entry>
    <title>Centos升级python2.7</title>
    <link href="http://mufool.com/2017/11/16/python-update-2-7/"/>
    <id>http://mufool.com/2017/11/16/python-update-2-7/</id>
    <published>2017-11-16T08:43:26.000Z</published>
    <updated>2017-11-16T08:44:41.871Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS 6.X 自带的Python版本是 2.6 , 目前python主流的编译环境是2.7，故整理一下python2.6到2.7的升级过程。</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>依赖工具包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel</div></pre></td></tr></table></figure><p>源码安装2.7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget http://www.python.org/ftp/python/2.7.8/Python-2.7.8.tar.xz</div><div class="line">xz -d Python-2.7.8.tar.xz</div><div class="line">tar -xvf Python-2.7.8.tar</div></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd Python-2.7.8</div><div class="line">./configure --prefix=/usr/local</div><div class="line">make</div><div class="line">make altinstall</div><div class="line">[root@VM_centos ~]# python2.7 -V</div><div class="line">Python 2.7.8</div></pre></td></tr></table></figure><h2 id="更新python"><a href="#更新python" class="headerlink" title="更新python"></a>更新python</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mv /usr/bin/python /usr/bin/python.bak</div><div class="line">ln -s /usr/local/bin/python2.7  /usr/bin/python</div></pre></td></tr></table></figure><p>此时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[clouddev@TY-0064 ~]$ python -V</div><div class="line">Python 2.7.8</div><div class="line">[clouddev@TY-0064 ~]$ which python</div><div class="line">/usr/bin/python</div><div class="line">[clouddev@TY-0064 ~]$</div></pre></td></tr></table></figure><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl  https://bootstrap.pypa.io/get-pip.py | python2.7 -</div></pre></td></tr></table></figure><p>启动pip报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pkg_resources.DistributionNotFound: The &apos;pip==7.1.0&apos; distribution was not found and is required by the application</div></pre></td></tr></table></figure></p><p>修改pip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mv /usr/bin/pip /usr/bin/pip0</div><div class="line">cp /usr/local/bin/pip2.7 /usr/bin/pip</div></pre></td></tr></table></figure></p><h2 id="修复yum"><a href="#修复yum" class="headerlink" title="修复yum"></a>修复yum</h2><p>yum依赖的python2.6，此时yum无法使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[clouddev@TY-0064 ~]$ which yum</div><div class="line">/usr/bin/yum</div></pre></td></tr></table></figure></p><p>将第一行<code>#!/usr/bin/python</code>改为<code>#!/usr/bin/python2.6</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS 6.X 自带的Python版本是 2.6 , 目前python主流的编译环境是2.7，故整理一下python2.6到2.7的升级过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PYTHON" scheme="http://mufool.com/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>Centos安装redis集群</title>
    <link href="http://mufool.com/2017/10/17/redis-cluster/"/>
    <id>http://mufool.com/2017/10/17/redis-cluster/</id>
    <published>2017-10-17T12:02:47.000Z</published>
    <updated>2017-10-17T12:05:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>Redis Cluster是3.0版本之后提供的新功能，采用了P2P的去中心化架构，而没有采用像Codis之类的Proxy解决方案中的中心协调节点设计。</p><a id="more"></a><h2 id="Redis集群原理"><a href="#Redis集群原理" class="headerlink" title="Redis集群原理"></a>Redis集群原理</h2><p>Redis集群使用数据分片而非一致性哈希来实现，一个Redis集群包含16384个哈希槽（slot），数据库中的每个键都属于这16384个哈希槽中的其中一个，集群中的每个节点可以处理0个或最多16384个槽，当数据库中的16384个槽都有节点在处理时，集群处于上线状态；而如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态。<br>集群中的每个节点负责处理一部分哈希槽，比如，现在有三个独立的节点127.0.0.1:7000,127.0.0.1:7001,127.0.0.1:7002，其中各节点处理的哈希槽关系：节点7000负责处理0到5000号哈希槽，节点7001负责处理5001到10000号哈希槽，节点7002负责处理10001到16384号哈希槽。<br>从而，当向集群中添加或删除节点时，集群只需在对应节点的哈希槽做移动即可。不会造成节点阻塞、集群下线。<br>当然，为了使得集群在一部分节点下线的情况下仍然可以正常运作，Redis集群对节点提供了主从复制功能，集群中的每个节点都有1到N个复制节点，形成主-从模型。</p><h2 id="Redis集群架构"><a href="#Redis集群架构" class="headerlink" title="Redis集群架构"></a>Redis集群架构</h2><p>(图片来自网络)<br><img src="http://i.imgur.com/O4QfdDF.jpg" alt="image"></p><p>Redis集群架构的主要特点有:</p><ul><li>所有节点批次互联（PING-PONG机制），没有中心控制协调节点，内部使用二进制协议优化传输速度和带宽；</li><li>节点的失效通过集群中超过半数的节点“投票”监测；</li><li>客户端与Redis节点直连，不需要中间proxy层，客户端连接集群中任何一个可用节点即可；</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>依赖库安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install gcc openssl-devel libyaml-devel libffi-devel readline-devel zlib-devel gdbm-devel ncurses-devel gcc-c++ automake autoconf</div></pre></td></tr></table></figure></p><p>redis编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget http://download.redis.io/releases/redis-3.0.6.tar.gz</div><div class="line">tar xvf redis-3.0.6.tar.gz</div><div class="line">cd redis-3.0.6/</div><div class="line">make MALLOC=libc</div></pre></td></tr></table></figure></p><p>编译之后再src目录下会生成需要的可执行文件，用到的文件有：</p><ul><li>redis-trib.rb，集群创建脚本</li><li>redis-server，redis服务</li><li>redis-cli，redis客户端</li></ul><h2 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h2><p>这里部署在同一台上测试，同时配置主从，共6个节点7000-7005。</p><p>1、创建目录</p><p>在redis-cluster目录下，创建目录7000-7005<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir redis-cluster</div><div class="line">mkdir 7000 7001 7002 7003 7004 7005</div></pre></td></tr></table></figure></p><p>2、修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">daemonize yes</div><div class="line">pidfile /var/run/redis0.pid</div><div class="line">port 7000</div><div class="line">#bind 127.0.0.1 192.168.193.229 119.18.193.229</div><div class="line">loglevel notice</div><div class="line">logfile &quot;./log.txt&quot;</div><div class="line"></div><div class="line">cluster-enabled yes</div><div class="line">cluster-config-file nodes-7000.conf</div><div class="line">cluster-node-timeout 5000</div><div class="line"></div><div class="line">appendonly yes</div><div class="line">appendfsync everysec</div><div class="line"></div><div class="line">rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c28</div><div class="line">rename-command FLUSHALL &quot;&quot; </div><div class="line">rename-command FLUSHDB &quot;&quot;</div></pre></td></tr></table></figure><p>分别拷贝到其他目录，并修改对应的配置项。</p><p>3、分别启动6个redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd redis-cluster/7000</div><div class="line">./redis-server redis.conf</div><div class="line">...</div><div class="line">cd redis-cluster/7005</div><div class="line">./redis-server redis.conf</div></pre></td></tr></table></figure><p>4、查看进程</p><p><img src="http://mufool.qiniudn.com/redis/redis-cluster0.jpg" alt="image"></p><h2 id="建立redis集群"><a href="#建立redis集群" class="headerlink" title="建立redis集群"></a>建立redis集群</h2><p>以上步骤分别创建了6个节点，并已经启动，这里要把这6个节点加入到一个集群里面。redis 已经为我们提供了集群操作的脚本 redis-trib.rb。</p><h3 id="安装ruby"><a href="#安装ruby" class="headerlink" title="安装ruby"></a>安装ruby</h3><p>由于集群操作需要用到 ruby 脚本 redis-trib.rb , 所以要安装 ruby 和 rubygems<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum -y install ruby rubygems</div><div class="line">gem install redis --version 3.0.6</div></pre></td></tr></table></figure></p><p><img src="http://mufool.qiniudn.com/redis/redis-cluster1.jpg" alt="image"></p><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div></pre></td></tr></table></figure><p>其中，命令create表示创建一个新的集群，选项–replicas 1表示未集群中的每个主节点创建一个从节点。即，上述命令运行后，redis-trib将创建一个包含三个主节点和三个从节点的集群。<br><img src="http://mufool.qiniudn.com/redis/redis-cluster2.jpg" alt="image"><br>上面信息中 M 表示 Master 节点， S 表示 Slave 节点，同时可以看到主备关系。随后输入yes即可创建完成。</p><h2 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./src/redis-trib.rb check 127.0.0.1:7000</div></pre></td></tr></table></figure><p><img src="http://mufool.qiniudn.com/redis/redis-cluster3.jpg" alt="image"><br> 其中可以看到每台master上的slot的分配个数，所有16384个slot都被covered，集群处于上线状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src/redis-cli -p 7000 cluster nodes</div></pre></td></tr></table></figure><p><img src="http://mufool.qiniudn.com/redis/redis-cluster4.jpg" alt="image"> </p><p>查看集群中各节点的信息。包括唯一的节点ID，主从关系，每个主节点分配的slots范围。</p><p><img src="http://mufool.qiniudn.com/redis/redis-cluster5.jpg" alt="image"> </p><p>在任意节点上增删数据都可以在集群的其他节点看到。若节点上没有查询的数据，-c参数指定查询时接收到MOVED指令自动跳转。</p><p>参考：<br><a href="http://blog.dujiong.net/2017/01/15/Redis-Cluster/" target="_blank" rel="external">搭建Redis集群</a><br><a href="http://weizijun.cn/2016/01/08/redis%20cluster%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7redis-trib-rb%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">redis cluster管理工具redis-trib.rb详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis Cluster是3.0版本之后提供的新功能，采用了P2P的去中心化架构，而没有采用像Codis之类的Proxy解决方案中的中心协调节点设计。&lt;/p&gt;
    
    </summary>
    
    
      <category term="REDIS" scheme="http://mufool.com/tags/REDIS/"/>
    
  </entry>
  
  <entry>
    <title>Centos安装配置powerline</title>
    <link href="http://mufool.com/2017/09/29/powerline/"/>
    <id>http://mufool.com/2017/09/29/powerline/</id>
    <published>2017-09-29T08:23:47.000Z</published>
    <updated>2017-10-12T08:10:30.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Powerline是vim编辑器的插件，它是Python开发的，为多个应用（bash，zsh，tmux等）提供statusline。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装pip：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install python-pip -y</div></pre></td></tr></table></figure></p><p>安装powerline</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install git+git://github.com/powerline/powerline</div></pre></td></tr></table></figure><p>安装Powerline字体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/powerline/powerline/raw/develop/font/PowerlineSymbols.otf</div><div class="line">wget https://github.com/powerline/powerline/raw/develop/font/10-powerline-symbols.conf</div><div class="line">mv PowerlineSymbols.otf /usr/share/fonts/</div><div class="line">fc-cache -vf /usr/share/fonts/            //更新系统的字体缓存</div><div class="line">mv 10-powerline-symbols.conf /etc/fonts/conf.d/</div></pre></td></tr></table></figure><h2 id="在Bash中启用Powerline"><a href="#在Bash中启用Powerline" class="headerlink" title="在Bash中启用Powerline"></a>在Bash中启用Powerline</h2><p>查看powerline安装位置<br><img src="http://mufool.qiniudn.com/powerline/powerline1.jpg" alt="image"></p><p>可以看到安装位置在<code>/usr/lib/python2.6/site-packages</code>下</p><p>在~/.bashrc中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">powerline-daemon -q</div><div class="line">POWERLINE_BASH_CONTINUATION=1</div><div class="line">POWERLINE_BASH_SELECT=1</div><div class="line">. /usr/lib/python2.6/site-packages/powerline/bindings/bash/powerline.sh</div></pre></td></tr></table></figure><p><code>source ~/.bashrc</code>生效</p><p>重启终端即可看到效果。</p><p><img src="http://mufool.qiniudn.com/powerline/powerlinel4.jpg" alt="image"></p><h2 id="在vim中启用powerline"><a href="#在vim中启用powerline" class="headerlink" title="在vim中启用powerline"></a>在vim中启用powerline</h2><p>在.vimrc文件中添加即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">set rtp+=/usr/lib/python2.6/dist-packages/powerline/bindings/vim/</div><div class="line">set laststatus=2</div><div class="line">set t_Co=256</div></pre></td></tr></table></figure><p><img src="http://mufool.qiniudn.com/powerline/powerline2.jpg" alt="image"></p><h2 id="在zsh中启用powerline"><a href="#在zsh中启用powerline" class="headerlink" title="在zsh中启用powerline"></a>在zsh中启用powerline</h2><p>与bash中类似，在.zshrc中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export TERM=xterm-256color</div><div class="line">source /usr/lib/python2.6/site-packages/powerline/bindings/zsh/powerline.zsh</div></pre></td></tr></table></figure><p><code>source ~/.zshrc</code>生效。</p><p>参考：<br><a href="http://blog.topspeedsnail.com/archives/2652" target="_blank" rel="external">安装使用Powerline：Vim和Bash终端的状态栏</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Powerline是vim编辑器的插件，它是Python开发的，为多个应用（bash，zsh，tmux等）提供statusline。&lt;/p&gt;
    
    </summary>
    
    
      <category term="POWERLINE" scheme="http://mufool.com/tags/POWERLINE/"/>
    
  </entry>
  
  <entry>
    <title>Tmux安装使用</title>
    <link href="http://mufool.com/2017/09/29/tmux/"/>
    <id>http://mufool.com/2017/09/29/tmux/</id>
    <published>2017-09-29T07:24:41.000Z</published>
    <updated>2017-10-11T04:31:37.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Tmux是一个优秀的终端复用软件，支持多标签，也支持窗口内部面板的分割，更重要的是，Tmux提供了窗体随时保存和恢复的功能。想象一下假如你在公司的服务器上开了许多窗口调试程序，回到家时通过SSH连接公司电脑又要打开一堆繁琐的窗口，而且还忘记了当时调试到哪一步了，那Tmux可以帮你解决这个难题，当SSH连接断开重新连接后能够恢复到原来的工作环境。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">yum -y install ncurses-devel #依赖包</div><div class="line"></div><div class="line"># 版本需大于2.0.10-stable</div><div class="line">wget --no-check-certificate https://github.com/downloads/libevent/libevent/libevent-2.0.21-stable.tar.gz</div><div class="line">tar xzf libevent-2.0.21-stable.tar.gz</div><div class="line">cd libevent-2.0.21-stable</div><div class="line">./configure</div><div class="line">make &amp;&amp; make install</div><div class="line">cd ../</div></pre></td></tr></table></figure><h3 id="安装tmux"><a href="#安装tmux" class="headerlink" title="安装tmux"></a>安装tmux</h3><p>从git上下载最新代码编译安装，参见<a href="https://github.com/tmux/tmux" target="_blank" rel="external">github</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/tmux/tmux.git</div><div class="line">$ cd tmux</div><div class="line">$ sh autogen.sh</div><div class="line">$ CFLAGS=&quot;-I/usr/local/include&quot; LDFLAGS=&quot;-L//usr/local/lib&quot; ./configure #直接./configure会报错</div><div class="line"># make &amp;&amp; make install</div></pre></td></tr></table></figure></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>运行可能出现如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux: error while loading shared libraries: libevent-2.0.so.5: cannot open shared object file: No such file or directory</div></pre></td></tr></table></figure></p><p>建立一下符号链接即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if [ `getconf WORD_BIT` = '32' ] &amp;&amp; [ `getconf LONG_BIT` = '64' ] ; then</div><div class="line">    ln -s /usr/local/lib/libevent-2.0.so.5 /usr/lib64/libevent-2.0.so.5</div><div class="line">else</div><div class="line">    ln -s /usr/local/lib/libevent-2.0.so.5 /usr/lib/libevent-2.0.so.5</div><div class="line">fi</div></pre></td></tr></table></figure><p>启动如出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lost server</div></pre></td></tr></table></figure></p><p>重新安装解决</p><p>完成进入tmux进入软件，界面类似一个下方带有状态栏的终端。<br><img src="http://mufool.qiniudn.com/tmux/tmux1.jpg" alt="image"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Tmux基于典型的c/s模型，主要分为会话、窗口和面板三个元素：</p><ul><li>服务器：输入tmux命令时就开启了一个服务器。</li><li>Session：输入tmux后就创建了一个会话，一个会话是一组窗体的集合。</li><li>Window：会话中一个可见的窗口。</li><li>Pane:一个窗口可以分成多个面板。</li></ul><p><img src="http://mufool.qiniudn.com/tmux/tmux2.jpg" alt="image"><br>注：图片来自网络<br>图中左下角的3显示为当前会话，随后1 vim,2 bash,3 ssh 分别是3个窗口，蓝色bash表示当前窗口，图中用蓝色数字标记的1,2,3分别是bash窗口的三个面板。你还可以在tmux配置文件中给状态栏添加时间、天气等信息。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>第一次会产生一个新的 session 和 window ，在下方会显示其状态，如果意外断开 (detach) 连接，session 仍会在后台运行，每个窗口可以分为多个 pane 。</p><p>启动时的参数选项有：</p><ul><li>-2: 强制 tmux 假设终端支持 256 色。</li><li>-8: 类似于 -2 ，不过是强制 tmux 假设终端支持 88 色。</li><li>-c shell-command: 使用默认的 shell 执行命令，主要用于当 tmux 作为 login shell 时使用。</li><li>-f file: 指定配置文件，默认检查 /etc/tmux.conf、~/.tmux.conf，如果有命令错误，则会直接退出。</li><li>-V: 查看版本号。<br>默认 tmux 会创建的匿名的 session ，可以通过如下命令创建一个命名的 session ， Ctrl-b 是命令前缀(Command prefix)，通过前缀告知 tmux 下面的命令是发给 tmux 的，而非终端。常见的操作如下。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ tmux new-session -s basic    # 创建一个名为 basic 的 session</div><div class="line">$ tmux new -s basic -d        # 同上，但是不会连接到终端，在后台运行</div><div class="line">$ tmux new -s basic -n win    # 同上，并将第一个窗口命令为 win</div><div class="line"></div><div class="line">$ tmux ls                      # 列出现在的 sessions ，等同 tmux list-sessioin</div><div class="line">$ tmux attach                  # 如果只有一个 session</div><div class="line">$ tmux attach -t basic        # 指定名称，-t 表示 target</div><div class="line"></div><div class="line">$ tmux kill-session -t basic  # 关闭一个 session</div></pre></td></tr></table></figure></li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>基本操作</p><table><thead><tr><th>命令</th><th>操作</th></tr></thead><tbody><tr><td>?</td><td>列出所有快捷键；按q返回</td></tr><tr><td>d</td><td>脱离当前会话,可暂时返回Shell界面，输入tmux attach能够重新进入之前会话</td></tr><tr><td>s</td><td>选择并切换会话；在同时开启了多个会话时使用</td></tr><tr><td>D</td><td>选择要脱离的会话；在同时开启了多个会话时使用</td></tr><tr><td>:</td><td>进入命令行模式；此时可输入支持的命令，例如kill-server所有tmux会话</td></tr><tr><td>[</td><td>复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc退出</td></tr><tr><td>]</td><td>进入粘贴模式，粘贴之前复制的内容，按q/Esc退出</td></tr><tr><td>~</td><td>列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</td></tr><tr><td>t</td><td>显示当前的时间</td></tr><tr><td>Ctrl+z</td><td>挂起当前会话</td></tr></tbody></table><p>窗口操作</p><table><thead><tr><th>命令</th><th>操作</th></tr></thead><tbody><tr><td>c</td><td>创建新窗口</td></tr><tr><td>&amp;</td><td>关闭当前窗口</td></tr><tr><td>数字键</td><td>切换到指定窗口</td></tr><tr><td>p</td><td>切换至上一窗口</td></tr><tr><td>n</td><td>切换至下一窗口</td></tr><tr><td>l</td><td>前后窗口间互相切换</td></tr><tr><td>w</td><td>通过窗口列表切换窗口</td></tr><tr><td>,</td><td>重命名当前窗口，便于识别</td></tr><tr><td>.</td><td>修改当前窗口编号，相当于重新排序</td></tr><tr><td>f</td><td>在所有窗口中查找关键词，便于窗口多了切换</td></tr></tbody></table><p>面板操作</p><table><thead><tr><th>命令</th><th>操作</th></tr></thead><tbody><tr><td>“</td><td>将当前面板上下分屏</td></tr><tr><td>%</td><td>将当前面板左右分屏</td></tr><tr><td>x</td><td>关闭当前分屏</td></tr><tr><td>!</td><td>将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板</td></tr><tr><td>Ctrl+方向键</td><td>以1个单元格为单位移动边缘以调整当前面板大小</td></tr><tr><td>Alt+方向键</td><td>以5个单元格为单位移动边缘以调整当前面板大小</td></tr><tr><td>空格键</td><td>可以在默认面板布局中切换，试试就知道了</td></tr><tr><td>q</td><td>显示面板编号</td></tr><tr><td>o</td><td>选择当前窗口中下一个面板</td></tr><tr><td>方向键</td><td>移动光标选择对应面板</td></tr><tr><td>{</td><td>向前置换当前面板</td></tr><tr><td>}</td><td>向后置换当前面板</td></tr><tr><td>Alt+o</td><td>逆时针旋转当前窗口的面板</td></tr><tr><td>Ctrl+o</td><td>顺时针旋转当前窗口的面板</td></tr><tr><td>z</td><td>tmux 1.8新特性，最大化当前所在面板</td></tr></tbody></table><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>用户私人配置文件在~/.tmux.conf, 全局配置文件在 /etc/tmux.conf。修改这两处均可。</p><h3 id="前缀修改"><a href="#前缀修改" class="headerlink" title="前缀修改"></a>前缀修改</h3><p>Tmux的所有操作必须使用一个前缀进入命令模式，默认前缀为ctrl+b，很多人会改为ctrl+a,你可以修改tmux.conf配置文件来修改默认前缀：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#前缀设置为&lt;Ctrl-a&gt;</div><div class="line">set -g prefix C-a</div><div class="line">#解除&lt;Ctrl-b&gt;</div><div class="line">ubind C-b</div></pre></td></tr></table></figure><h3 id="配置更新"><a href="#配置更新" class="headerlink" title="配置更新"></a>配置更新</h3><p>配置完以后，重启tmux起效，或者先按C+b，然后输入：，进入命令行模式， 在命令行模式下输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source-file ~/.tmux.conf</div></pre></td></tr></table></figure></p><p>你也可以跟我一样，在配置文件中加入下面这句话，以后改了只需要按前缀+r了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#将r 设置为加载配置文件，并显示&quot;reloaded!&quot;信息</div><div class="line">bind r source-file ~/.tmux.conf \; display &quot;Reloaded!&quot;</div></pre></td></tr></table></figure></p><h3 id="复制模式copy-mode"><a href="#复制模式copy-mode" class="headerlink" title="复制模式copy-mode"></a>复制模式copy-mode</h3><ul><li>前缀 [ 进入复制模式</li><li>按 space 开始复制，移动光标选择复制区域</li><li>按 Enter 复制并退出copy-mode。</li><li>将光标移动到指定位置，按 PREIFX ] 粘贴<br>如果把tmux比作vim的话，那么我们大部分时间都是处于编辑模式，我们复制的时候可不可以像 vim一样移动呢？只需要在配置文件(~/.tmux.conf)中加入如下行即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#copy-mode 将快捷键设置为vi 模式</div><div class="line">setw -g mode-keys vi</div></pre></td></tr></table></figure></li></ul><h3 id="开启批量执行"><a href="#开启批量执行" class="headerlink" title="开启批量执行"></a>开启批量执行</h3><p>如果已经修改prefix键位Ctrl+a，则Ctrl+a[默认Ctrl+b]后输入:set synchronize-panes ，输入:set sync [TAB]键可自动补齐</p><h3 id="脚本化启动"><a href="#脚本化启动" class="headerlink" title="脚本化启动"></a>脚本化启动</h3><p>把以下脚本内容加入到~/.bashrc，即可每次登录进入到tmux<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tmux_init()</div><div class="line">&#123;</div><div class="line">tmux new-session -s &quot;kumu&quot; -d -n &quot;local&quot; # 开启一个会话</div><div class="line">tmux new-window -n &quot;other&quot; # 开启一个窗口</div><div class="line">tmux split-window -h # 开启一个竖屏</div><div class="line">tmux split-window -v &quot;top&quot; # 开启一个横屏,并执行top命令</div><div class="line">tmux -2 attach-session -d # tmux -2强制启用256color，连接已开启的tmux</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="自动关联session"><a href="#自动关联session" class="headerlink" title="自动关联session"></a>自动关联session</h3><p>判断是否已有开启的tmux会话，没有则开启，有则关联当前一打开的会话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if which tmux 2&gt;&amp;1 &gt;/dev/null; then</div><div class="line">test -z &quot;$TMUX&quot; &amp;&amp; (tmux attach || tmux_init)</div><div class="line">fi</div></pre></td></tr></table></figure></p><h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><p>使用下列快捷键可以进入滚动模式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ctrl-b [</div></pre></td></tr></table></figure></p><p>这会使你进入滚动模式,然后你可以使用上下键或翻页键进行滚动,翻页.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ctrl-b PageUp</div></pre></td></tr></table></figure></p><p>这个快捷键会使你立即进入滚动模式,并向上翻页.</p><h3 id="自定义状态栏"><a href="#自定义状态栏" class="headerlink" title="自定义状态栏"></a>自定义状态栏</h3><p><a href="http://note4code.com/2016/07/03/tmux-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">TMUX 自定义配置</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">set-option -g status on</div><div class="line">#set -g status-bg blue # 状态栏背景颜色</div><div class="line">set -g status-bg &apos;#333333&apos;</div><div class="line">#set -g status-fg &apos;#bbbbbb&apos; # 状态栏前景颜色</div><div class="line">set -g status-fg &apos;#ffffff&apos;</div><div class="line">set-option -g status-interval 2 # 设置自动刷新的时间间隔</div><div class="line">set-option -g status-justify &quot;centre&quot; # 状态栏对齐</div><div class="line">set -g status-left-fg green</div><div class="line">set -g status-left-bg blue</div><div class="line">set -g status-right-fg green</div><div class="line">set -g status-right-bg blue</div><div class="line">set-option -g status-left-length 60 # 状态栏左侧宽度</div><div class="line">set-option -g status-right-length 90 # 状态栏右侧宽度</div><div class="line">#set-option -g status-left &quot;#(~/tmux-powerline/powerline.sh left)&quot; 通过插件管理</div><div class="line">#set-option -g status-right &quot;#(~/tmux-powerline/powerline.sh right)&quot;</div><div class="line"></div><div class="line">set -g status-left &apos;[#(whoami),#H]&apos;</div><div class="line">#set -g status-left &apos;#[bg=#00bb00] [#S] #[default] &apos; # 状态栏左侧显示 session 的名字</div><div class="line">set -g status-right &apos;[#(date +&quot;%Y-%m-%d %H:%M:%S &quot;)]&apos; # 状态栏右侧显示时间</div><div class="line">#set -g status-right &apos;#[fg=white,bg=#55bb00] [#h] #[fg=white,bg=#009c00] %Y-%m-%d #[fg=white,bg=#007700] %H:%M:%S &apos;</div><div class="line">#set -g status-right &apos;#[fg=white,bg=#444444] [#h] #[fg=white,bg=#666666] %Y-%m-%d #[fg=white,bg=#888888] %H:%M:%S &apos;</div><div class="line"></div><div class="line">#set -g window-status-format &apos;#I #W&apos; # 未激活每个窗口占位的格式</div><div class="line">setw -g window-status-format &apos;#[bg=#0000ff, fg=#ffffff] [#I] #W &apos;</div><div class="line"></div><div class="line">#set -g window-status-current-format &apos; #I #W &apos; # 当前激活窗口在状态栏的展位格式</div><div class="line">setw -g window-status-current-format &apos;#[bg=#ff0000, fg=#ffffff, bold]*[#I] #W*&apos;</div><div class="line"></div><div class="line">setw -g window-status-current-bg blue</div><div class="line">setw -g window-status-current-fg green</div><div class="line"></div><div class="line"># 自动重新编号 window</div><div class="line">set -g renumber-windows on</div><div class="line"></div><div class="line"># pane border colors</div><div class="line">set -g pane-active-border-fg &apos;#55ff55&apos;</div><div class="line">set -g pane-border-fg &apos;#555555&apos;</div></pre></td></tr></table></figure><p>256颜色表<br><img src="http://mufool.qiniudn.com/tmux/tmux3.jpg" alt="image"><br>注：图片来自网络</p><h3 id="插件配置状态栏"><a href="#插件配置状态栏" class="headerlink" title="插件配置状态栏"></a>插件配置状态栏</h3><p>使用<a href="https://github.com/erikw/tmux-powerline" target="_blank" rel="external">tmux-powerline</a>插件配置状态栏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd ~</div><div class="line">$ git clone https://github.com/erikw/tmux-powerline.git</div></pre></td></tr></table></figure><p>开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set-option -g status-left &quot;#(~/tmux-powerline/powerline.sh left)&quot;</div><div class="line">set-option -g status-right &quot;#(~/tmux-powerline/powerline.sh right)&quot;</div></pre></td></tr></table></figure><p>显示<code>No weather location specified</code>时，需要修改segments/weather.sh文件，<a href="https://github.com/erikw/tmux-powerline/issues/219" target="_blank" rel="external">参考</a></p><p>securtcrt或者putty中powerline中文显示问题，参考<a href="http://blog.csdn.net/daoshuti/article/details/69788156" target="_blank" rel="external">让putty，secureCRT等工具支持Powerline，oh-my-zsh，解决乱码问题</a></p><h2 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h2><p>安装插件管理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm</div></pre></td></tr></table></figure><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># List of plugins</div><div class="line">set -g @plugin &apos;tmux-plugins/tpm&apos;</div><div class="line">set -g @plugin &apos;tmux-plugins/tmux-sensible&apos;</div><div class="line"></div><div class="line"># Other examples:</div><div class="line"># set -g @plugin &apos;github_username/plugin_name&apos;</div><div class="line"># set -g @plugin &apos;git@github.com/user/plugin&apos;</div><div class="line"># set -g @plugin &apos;git@bitbucket.com/user/plugin&apos;</div><div class="line"></div><div class="line"># Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)</div><div class="line">run &apos;~/.tmux/plugins/tpm/tpm&apos;</div></pre></td></tr></table></figure><p>启用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux source ~/.tmux.conf</div></pre></td></tr></table></figure></p><p>安装、升级和反安装插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">prefix shift-i      # install</div><div class="line">prefix shift-u      # update</div><div class="line">prefix alt-u        # uninstall plugins not on the plugin list</div></pre></td></tr></table></figure></p><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h3 id="tmux-resurrect"><a href="#tmux-resurrect" class="headerlink" title="tmux-resurrect"></a><a href="https://github.com/tmux-plugins/tmux-resurrect" target="_blank" rel="external">tmux-resurrect</a></h3><p>保存和恢复 Tmux 会话，面板布局，甚至支持恢复vim会话，重启机器仍可恢复。参考<a href="https://liam0205.me/2016/09/10/tmux-plugin-resurrect/" target="_blank" rel="external">保存和恢复 Tmux 会话</a>。</p><p>在tmux.conf中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set -g @plugin &apos;tmux-plugins/tmux-resurrect&apos;</div></pre></td></tr></table></figure></p><p>添加插件后<code>prefix + I</code>即下载并开启</p><p>参考：<br><a href="http://blog.csdn.net/u012335044/article/details/61923402" target="_blank" rel="external">tmux – Linux终端管理软件</a><br><a href="https://wiki.archlinux.org/index.php/Tmux_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">Tmux (简体中文)</a>)<br><a href="https://www.zybuluo.com/mwumli/note/149542" target="_blank" rel="external">CentOS 下安装 tmux</a><br><a href="https://qiaoanran.com/article/0d268826+Tmux_%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7" target="_blank" rel="external">Tmux 插件管理工具</a><br><a href="https://github.com/jimeh/tmux-themepack" target="_blank" rel="external">tmux-themepack</a><br><a href="https://my.oschina.net/am313/blog/865915" target="_blank" rel="external">在 Linux/Mac 安装 Tmux 及其配置</a><br><a href="https://jin-yang.github.io/post/tmux-introduce.html" target="_blank" rel="external">TMUX 简介</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Tmux是一个优秀的终端复用软件，支持多标签，也支持窗口内部面板的分割，更重要的是，Tmux提供了窗体随时保存和恢复的功能。想象一下假如你在公司的服务器上开了许多窗口调试程序，回到家时通过SSH连接公司电脑又要打开一堆繁琐的窗口，而且还忘记了当时调试到哪一步了，那Tmux可以帮你解决这个难题，当SSH连接断开重新连接后能够恢复到原来的工作环境。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TMUX" scheme="http://mufool.com/tags/TMUX/"/>
    
  </entry>
  
  <entry>
    <title>Putty免密登陆</title>
    <link href="http://mufool.com/2017/09/29/putty/"/>
    <id>http://mufool.com/2017/09/29/putty/</id>
    <published>2017-09-29T07:15:48.000Z</published>
    <updated>2017-11-16T09:06:28.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件，其主要优点有： 完全免费 、全面支持SSH1和SSH2 、绿色软件，无需安装，下载后在桌面建个快捷方式即可使用、体积很小、操作简单。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="external">下载地址</a></p><p>下载msi包安装，或者直接下载exe文件即可。</p><h2 id="免密登陆配置"><a href="#免密登陆配置" class="headerlink" title="免密登陆配置"></a>免密登陆配置</h2><p>PuTTY不提供“记住密码”一类的选项，PuTTY自动登录Linux系统，需要使用公钥/私钥方式。 这种方式需要生成一组对应的公钥（简短的字符串）和密钥（一个文件），然后把公钥放到服务器上，私钥提供给PuTTY。PuTTY仍然不知道你的密码，而是通过与服务器核对密钥而核实身份。</p><h3 id="生成公私钥"><a href="#生成公私钥" class="headerlink" title="生成公私钥"></a>生成公私钥</h3><p>使用PuTTY安装目录里的puttygen.exe工具。先点“生成(Generate)”，然后随意移动鼠标直到进度条填满，即可生成密钥。</p><p><img src="http://mufool.qiniudn.com/putty/putty1.jpg" alt="image"></p><p>点击<code>Save private key</code>保存私钥到文件。</p><h3 id="Putty关联私钥"><a href="#Putty关联私钥" class="headerlink" title="Putty关联私钥"></a>Putty关联私钥</h3><p>在Connection -&gt; SSH -&gt; Auth, Private keyfile for authentication中添加上一步生成的私钥文件，同时保存会话。<br><img src="http://mufool.qiniudn.com/putty/putty2.jpg" alt="image"></p><h3 id="服务器添加公钥"><a href="#服务器添加公钥" class="headerlink" title="服务器添加公钥"></a>服务器添加公钥</h3><p>在服务器对应的用户文件<code>~/.ssh/authorized_keys</code>，中添加生成第一步生成的公钥即可。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>退出重新登陆putty即可，如配置后仍然报错<code>server refused our key</code>，修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod 700 .ssh #目录权限700</div><div class="line">chmod 600 authorized_keys #文件权限600</div></pre></td></tr></table></figure></p><p>参考：<br><a href="http://blog.csdn.net/xocoder/article/details/45821967" target="_blank" rel="external">linux ssh私钥登陆失败:server refused our key原因</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件，其主要优点有： 完全免费 、全面支持SSH1和SSH2 、绿色软件，无需安装，下载后在桌面建个快捷方式即可使用、体积很小、操作简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PUTTY" scheme="http://mufool.com/tags/PUTTY/"/>
    
  </entry>
  
  <entry>
    <title>Linux inode节点满的解决方法</title>
    <link href="http://mufool.com/2017/09/22/linux-inode/"/>
    <id>http://mufool.com/2017/09/22/linux-inode/</id>
    <published>2017-09-22T09:25:53.000Z</published>
    <updated>2017-09-22T09:26:38.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是inode"><a href="#什么是inode" class="headerlink" title="什么是inode"></a>什么是inode</h2><a id="more"></a><p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。<br>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。<br>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。<br>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df -ih</div></pre></td></tr></table></figure><h2 id="查找满的目录"><a href="#查找满的目录" class="headerlink" title="查找满的目录"></a>查找满的目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for i in /*; do echo $i; find $i | wc -l; done</div></pre></td></tr></table></figure><p>依次对所查找的目录执行以上目录，即可找到哪个目录文件最多，一般情况下是频繁的写小文件或者linux邮件服务导致。</p><h2 id="删除占用文件多的目录"><a href="#删除占用文件多的目录" class="headerlink" title="删除占用文件多的目录"></a>删除占用文件多的目录</h2><p>直接删除目录很慢，进入目录查看文件可能会卡死<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find dir -type f -name &apos;*&apos;  | xargs rm</div></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd dir</div><div class="line">ls | xargs rm -f</div></pre></td></tr></table></figure></p><p>参考：<br><a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="external">理解inode</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是inode&quot;&gt;&lt;a href=&quot;#什么是inode&quot; class=&quot;headerlink&quot; title=&quot;什么是inode&quot;&gt;&lt;/a&gt;什么是inode&lt;/h2&gt;
    
    </summary>
    
    
      <category term="LINUX" scheme="http://mufool.com/tags/LINUX/"/>
    
  </entry>
  
  <entry>
    <title>Grunt打包前端代码</title>
    <link href="http://mufool.com/2017/09/22/grunt-package/"/>
    <id>http://mufool.com/2017/09/22/grunt-package/</id>
    <published>2017-09-22T08:19:23.000Z</published>
    <updated>2017-09-22T08:23:30.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Grunt介绍"><a href="#Grunt介绍" class="headerlink" title="Grunt介绍"></a>Grunt介绍</h2><p>grunt是一套前端自动化构建工具，一个基于nodeJs的命令行工具，一般用于压缩文件，合并文件等，与java世界的Maven工具类似。</p><a id="more"></a><h2 id="Grunt安装"><a href="#Grunt安装" class="headerlink" title="Grunt安装"></a>Grunt安装</h2><p><a href="http://mufool.com/2017/08/21/centos-grunt/">Centos下安装Grunt</a></p><h2 id="Grunt使用"><a href="#Grunt使用" class="headerlink" title="Grunt使用"></a>Grunt使用</h2><p>每一个gurnt都会需要这两个文件package.json和Gruntfile.js，package.json这个文件用来存储npm模块的依赖项，比如我们的打包若是依赖requireJS的插件；Gruntfile.js读取package信息，插件加载、注册任务，运行任务。</p><h3 id="package-json示例"><a href="#package-json示例" class="headerlink" title="package.json示例"></a>package.json示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"clouds"</span>,</div><div class="line">    <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">    <span class="string">"author"</span>: <span class="string">"xx@xx.com"</span>,</div><div class="line">    <span class="string">"description"</span>: <span class="string">"clouds-app"</span>,</div><div class="line">    <span class="string">"dependencies"</span>: &#123;</div><div class="line">        <span class="string">"ejs"</span>: <span class="string">"*"</span>,  </div><div class="line">        <span class="string">"grunt"</span>: <span class="string">"~0.4.1"</span>,</div><div class="line">        <span class="string">"grunt-contrib-less"</span>: <span class="string">"*"</span>,</div><div class="line">        <span class="string">"grunt-contrib-uglify"</span>: <span class="string">"~0.2.2"</span>,</div><div class="line">        <span class="string">"grunt-contrib-cssmin"</span>: <span class="string">"~0.9.0"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>devDependencies中添加所需要的插件，以及对应的版本信息。以及一些会显示在文件中的版本，作者信息等。<br>在已有package.json的情况下，执行<code>npm install</code>会自动将所需要的插件下载到node_modules目录下，</p><h3 id="Gruntfile-js示例"><a href="#Gruntfile-js示例" class="headerlink" title="Gruntfile.js示例"></a>Gruntfile.js示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> zipjs,compileJsConfig,config;</div><div class="line">    config = &#123;</div><div class="line">        pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),</div><div class="line">        ismap: <span class="literal">false</span>,<span class="comment">//是否生成调试代码</span></div><div class="line">        path: &#123;<span class="attr">less</span>: <span class="string">'less/'</span>,<span class="attr">style</span>: <span class="string">'style/'</span>,<span class="attr">script</span>:<span class="string">"script/"</span>,<span class="attr">src</span>:<span class="string">"src/"</span>&#125;,</div><div class="line">        less: &#123; <span class="comment">// 编译 LESS 文件</span></div><div class="line">            compile: &#123;</div><div class="line">                files: &#123;</div><div class="line">                    <span class="string">'&lt;%= path.style %&gt;index.css'</span>:[<span class="string">'&lt;%= path.less %&gt;index.less'</span>],</div><div class="line">                     ......</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        cssmin: &#123; <span class="comment">// 压缩 CSS 文件</span></div><div class="line">            options: &#123;</div><div class="line">                report : <span class="string">"min"</span></div><div class="line">            &#125;,</div><div class="line">            combine: &#123;</div><div class="line">                files: &#123;</div><div class="line">                  <span class="string">'&lt;%= path.style %&gt;index.min.css'</span>: <span class="string">'&lt;%= path.style %&gt;index.css'</span>,</div><div class="line">                ......</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        uglify: &#123;<span class="comment">// 压缩合并 JS 文件</span></div><div class="line">            options: &#123;</div><div class="line">                report:<span class="string">'min'</span>,</div><div class="line">                expand: <span class="literal">true</span>,</div><div class="line">                mangle: <span class="literal">true</span>,</div><div class="line">                sourceMapRoot: <span class="string">'../../'</span>,</div><div class="line">                preserveComments: <span class="string">'false'</span>,</div><div class="line">                beautify: &#123;</div><div class="line">                    ascii_only: <span class="literal">true</span><span class="comment">//中文ascii化,防止中文乱码</span></div><div class="line">                &#125;,</div><div class="line">                banner: <span class="string">'/** \n'</span> +<span class="comment">//生成注释</span></div><div class="line">                        <span class="string">' * -------------------------------------------------------------\n'</span> +</div><div class="line">                        <span class="string">' * Copyright (c) 2014 xx, All rights reserved. \n'</span> +</div><div class="line">                        <span class="string">' * @version: &lt;%= pkg.version%&gt; \n'</span> +</div><div class="line">                        <span class="string">' * @author: &lt;%= pkg.author%&gt; \n'</span> +</div><div class="line">                        <span class="string">' * @description: &lt;%= pkg.description%&gt; \n'</span> +</div><div class="line">                        <span class="string">' * @date: &lt;%=grunt.template.today("yyyy-mm-dd  HH:MM:ss")%&gt;\n'</span> +</div><div class="line">                        <span class="string">' * ------------------------------------------------------------- \n'</span> +</div><div class="line">                        <span class="string">' */ \n\n'</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    zipjs = &#123;<span class="comment">//压缩配置</span></div><div class="line">        swfupload : &#123;</div><div class="line">            namespace : config.path.script+<span class="string">'swfUpload.min.js'</span>,</div><div class="line">            dstname : [config.path.ui+<span class="string">'SwfLoaderBar.js'</span>,config.path.view+<span class="string">'swfUpload.js'</span>]</div><div class="line">        &#125;,</div><div class="line">                ......</div><div class="line">    &#125;;</div><div class="line">    compileJsConfig = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> json;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> zipjs) &#123;<span class="comment">//需要压缩的代码</span></div><div class="line">            json = &#123;&#125;</div><div class="line">            json[zipjs[key].namespace] = zipjs[key].dstname;</div><div class="line">            config.uglify[key] = &#123;<span class="attr">files</span>:json&#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(config.ismap)&#123;</div><div class="line">            config.uglify.options.sourceMap = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;<span class="comment">// 生成 map文件的地址</span></div><div class="line">                <span class="keyword">var</span> file = path.split(<span class="string">"/"</span>),filename = file.pop(),route = file.join(<span class="string">"/"</span>) + <span class="string">"/"</span>;</div><div class="line">                <span class="keyword">return</span> route + <span class="string">"map/"</span> +  filename.replace(<span class="string">'.js'</span>,<span class="string">'.map'</span>);</div><div class="line">            &#125;;</div><div class="line">            config.uglify.options.sourceMappingURL = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;<span class="comment">// 用于定义 map文件地址 并放在压缩文件底部， url相对于 压缩文件</span></div><div class="line">                <span class="keyword">var</span> file = path.split(<span class="string">"/"</span>),filename = file.pop();</div><div class="line">                <span class="keyword">return</span> <span class="string">"map/"</span> +  filename.replace(<span class="string">'.js'</span>,<span class="string">'.map'</span>);</div><div class="line">            &#125;;  </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> config;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//读取配置文件</span></div><div class="line">    grunt.initConfig(compileJsConfig(config));</div><div class="line"></div><div class="line">    <span class="comment">//加载任务的插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-contrib-less'</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-contrib-cssmin'</span>); </div><div class="line"></div><div class="line">    <span class="comment">//注册任务</span></div><div class="line">    grunt.registerTask(<span class="string">'build'</span>, [<span class="string">'less'</span>,<span class="string">'cssmin'</span>,<span class="string">'uglify'</span>]);</div><div class="line">    grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'uglify'</span>]);<span class="comment">//不带参数，及执行uglify</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>参考：<br><a href="http://javascript.ruanyifeng.com/tool/grunt.html" target="_blank" rel="external">Grunt：任务自动管理工具</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Grunt介绍&quot;&gt;&lt;a href=&quot;#Grunt介绍&quot; class=&quot;headerlink&quot; title=&quot;Grunt介绍&quot;&gt;&lt;/a&gt;Grunt介绍&lt;/h2&gt;&lt;p&gt;grunt是一套前端自动化构建工具，一个基于nodeJs的命令行工具，一般用于压缩文件，合并文件等，与java世界的Maven工具类似。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JS" scheme="http://mufool.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Linux压缩命令对比</title>
    <link href="http://mufool.com/2017/09/22/linux-zip/"/>
    <id>http://mufool.com/2017/09/22/linux-zip/</id>
    <published>2017-09-22T08:18:43.000Z</published>
    <updated>2017-09-22T09:03:39.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zip格式的压缩和解压缩"><a href="#zip格式的压缩和解压缩" class="headerlink" title=".zip格式的压缩和解压缩"></a>.zip格式的压缩和解压缩</h2><a id="more"></a><ul><li><p>zip 压缩文件名源文件<br>含义：这条命令压缩的是文件。</p></li><li><p>zip -r 压缩文件名源目录<br>含义：这条命令压缩的是目录，包括目录下的文件一并压缩进去。</p></li><li><p>unzip 压缩文件名<br>含义：解压缩，不管是压缩的文件还是压缩的目录都用此来解压缩</p></li></ul><p>注意：Linux下的.zip和windows下的.zip格式是一样的，也就是说windows下的.zip压缩包可以直接拿到</p><h2 id="gz格式的压缩和解压缩"><a href="#gz格式的压缩和解压缩" class="headerlink" title=".gz格式的压缩和解压缩"></a>.gz格式的压缩和解压缩</h2><ul><li><p>gzip 源文件<br>含义：将源文件压缩为.gz格式，但是源文件会消失。</p></li><li><p>gzip -c 源文件 &gt; 压缩文件<br>含义：将源文件压缩为.gz格式，但是源文件会保留。其实原理是将压缩的.gz输入到“压缩文件”而已。</p></li><li><p>gzip -r 目录<br>含义：压缩目录下的所有子文件，但是注意不能压缩目录。</p></li><li><p>gunzip 压缩文件<br>含义：解压缩。原有的.ga压缩文件会消失的。</p></li><li><p>gzip -d 压缩文件<br>含义：解压缩。同上。</p></li><li><p>gunzip -r 目录<br>含义：将目录下所有的.gz格式的文件解压缩。</p></li></ul><p>注意：windows下的.rar格式压缩文件不能在Linux下使用。.gz格式是Linux下独有的压缩格式，但是也可以在windows下被解压缩。</p><h2 id="bz2格式的压缩与解压缩"><a href="#bz2格式的压缩与解压缩" class="headerlink" title=".bz2格式的压缩与解压缩"></a>.bz2格式的压缩与解压缩</h2><ul><li><p>bzip2 源文件<br>含义：压缩源文件为.bz2格式，不保留源文件。</p></li><li><p>bzip2 -k 源文件<br>含义：压缩源文件，但是保留源文件。</p></li></ul><p>注意：.bz2不支持压缩目录。</p><ul><li><p>bzip2 -d 压缩文件<br>含义：解压缩。如果加选项“-k”，则保留压缩文件</p></li><li><p>bunzip2 压缩文件<br>含义：解压缩。如果加选项“-k”，则保留压缩文件</p></li></ul><h2 id="tar-gz和tar-bz2格式的压缩和解压缩"><a href="#tar-gz和tar-bz2格式的压缩和解压缩" class="headerlink" title=".tar.gz和tar.bz2格式的压缩和解压缩"></a>.tar.gz和tar.bz2格式的压缩和解压缩</h2><p>为了解决.gz格式不能压缩目录，所以Linux给出了.tar.gz的压缩格式。它的原理其实就是先将目录（也可以将文件）打包成一个.tar格式的单一文件包，然后再使用.gz的压缩方式对其压缩。那么我们就按照它的实现原理来讲几个命令：</p><h3 id="打包成-tar-gz格式。"><a href="#打包成-tar-gz格式。" class="headerlink" title="打包成.tar.gz格式。"></a>打包成.tar.gz格式。</h3><p>先将文件或者目录打包成.tart格式，使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -cvf 打包文件名源文件</div></pre></td></tr></table></figure></p><p>选项：</p><ul><li>-c 打包的意思</li><li>-v 显示过程</li><li>-f 指定打包后的文件名</li></ul><p>比如我们打包出了文件”cangls.tar”，然后再将其打包成.tar.gz。直接使用.gz格式的命令即可。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip cangls.tar</div></pre></td></tr></table></figure></p><p>这样子最终就打包成了cangls.tar.ga格式的压缩包了。</p><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><p>下面我们可以一步步的将.tar.gz解压缩。首先使用.gz的命令解压成.tar格式，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gunzip cangls.tar.gz</div></pre></td></tr></table></figure></p><p>这样子就会被解压成cangls.tar。然后再使用.tar的解压方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -xvf cangls.tar</div></pre></td></tr></table></figure></p><p>这样子就最终解压成了cangls。</p><p>上面说的是其实现原理，你可以这样子一步步来压缩。也可以一步将文件或者目录打包成.tar.gz格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zcvf 压缩包名源文件</div></pre></td></tr></table></figure></p><p>选项：</p><ul><li>-z 就是直接打包成.tar.gz格式的意思</li></ul><p>一句话将.tar.gz格式解压缩：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf 压缩包名</div></pre></td></tr></table></figure></p><p>而关于.tar.bz2的实现原理跟上面是一样的，这里就不再多说。</p><p>下面做一下总结，其实.tar.gz和.tar.bz2是linux下最常用的命令。对于初学者，只需要记住一下几个命令即可：</p><p>一般记住下面的命令即可：</p><ul><li><p>tar -zcvf 压缩包名源文件或者目录<br>含义：将源文件或者目录打包成.tar.gz格式。</p></li><li><p>tar -zxvf 压缩包名<br>含义：将.tar.gz格式的包解压。</p></li><li><p>tar -jcvf 压缩包名源文件或者目录名<br>含义：将源文件或者目录压缩成.tar.bz2格式的包。</p></li><li><p>tar -jxvf 压缩包名<br>含义：将.tar.bz2格式解压缩</p></li></ul><p>上面的命令都是压缩到或者解压到当前目录下，如果想压缩到或者解压到其他目录下呢？</p><p>用下面的两个示例来说明一下方法吧：</p><ul><li><p>tar -zxvf cangls.tar.gz -c /tmp/<br>含义：将cangls.tar.gz解压到tmp目录下。也就是说，后面跟上“-c 目录名”，就是要解压到的地方。</p></li><li><p>tar -zcvf /tmp/cangls.tar.gz cangls<br>含义：将cangls压缩到/tmp目录下，并且命名为cangls.tar.gz。也就是压缩到哪里，在前面直接加上目录即可。</p></li></ul><h2 id="各个压缩命令比较"><a href="#各个压缩命令比较" class="headerlink" title="各个压缩命令比较"></a>各个压缩命令比较</h2><p>已一个163M的node目录为例进行压缩比较</p><ul><li>tar -cvf node.tar node<br>压缩完后148M</li><li>zip -r node.zip node<br>压缩完后44M</li><li>tar -zcvf node.tgz node<br>压缩完后34M</li><li>tar -jcvf node.tar.bz node<br>压缩完后28M</li><li>tar -jcvf node.tar.bz2 node<br>压缩完后28M，只是bz2的压缩速度更快</li></ul><p>综合起来，在压缩比率上： tar.bz=tar.bz2&gt;tgz&gt;zip&gt;tar<br>耗费时间（打包，解压）<br>打包：tar.bz&gt;tar.bz2&gt;tgz&gt;zip&gt;tar<br>解压： tar.bz&gt;tar.bz2&gt;zip&gt;tar&gt;tgz<br>从效率角度来说，当然是耗费时间越短越好，可以根据需要选择不同的压缩工具，物理空间和时间上不能两全。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;zip格式的压缩和解压缩&quot;&gt;&lt;a href=&quot;#zip格式的压缩和解压缩&quot; class=&quot;headerlink&quot; title=&quot;.zip格式的压缩和解压缩&quot;&gt;&lt;/a&gt;.zip格式的压缩和解压缩&lt;/h2&gt;
    
    </summary>
    
    
      <category term="ZIP" scheme="http://mufool.com/tags/ZIP/"/>
    
  </entry>
  
  <entry>
    <title>zsh安装使用</title>
    <link href="http://mufool.com/2017/09/22/zsh/"/>
    <id>http://mufool.com/2017/09/22/zsh/</id>
    <published>2017-09-22T08:12:55.000Z</published>
    <updated>2017-09-22T08:23:44.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zsh介绍"><a href="#zsh介绍" class="headerlink" title="zsh介绍"></a>zsh介绍</h2><p>Zsh 也许是目前最好用的 shell，是 bash 替代品中较为优秀的一个，号称终极shell。</p><a id="more"></a><h2 id="zsh安装"><a href="#zsh安装" class="headerlink" title="zsh安装"></a>zsh安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install zsh -y</div></pre></td></tr></table></figure><h2 id="zsh配置"><a href="#zsh配置" class="headerlink" title="zsh配置"></a>zsh配置</h2><h3 id="oh-my-zsh配置"><a href="#oh-my-zsh配置" class="headerlink" title="oh-my-zsh配置"></a>oh-my-zsh配置</h3><p>oh-my-zsh是为了简化zsh的配置而提供的一个配置模板，可以更好的管理zsh的各项配置</p><p>通过curl安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</div></pre></td></tr></table></figure></p><p>通过wget安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh</div></pre></td></tr></table></figure></p><p>手动安装</p><p>克隆仓库里面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</div></pre></td></tr></table></figure></p><p>创建一个新的zsh配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</div></pre></td></tr></table></figure></p><p>改变默认的shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chsh -s /bin/zsh</div></pre></td></tr></table></figure></p><p>如不生效，则在~/.bashrc最后添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bash -c zsh</div></pre></td></tr></table></figure></p><h3 id="主题配色"><a href="#主题配色" class="headerlink" title="主题配色"></a>主题配色</h3><p>～/.oh-my-zsh/themes目录下面的任意文件都可以作为主题，如果都不喜欢可以选择自己定义，参照<a href="http://blog.csdn.net/lushujun2011/article/details/7351926" target="_blank" rel="external">linux环境变量设置 (PS1，PS2)</a>。</p><h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p>安装好 zsh 和 oh-my-zsh 后，打开文件~/.zshrc，其中有如下行<code>plugins=(git)</code>，需要添加插件，直接空格分割当道后面即可。</p><h3 id="extract"><a href="#extract" class="headerlink" title="extract"></a>extract</h3><p>功能强大的解压插件，所有类型的文件解压一个命令x全搞定。</p><h3 id="z"><a href="#z" class="headerlink" title="z"></a>z</h3><p>强大的目录自动跳转命令，会记忆你曾经进入过的目录，用模糊匹配快速进入你想要的目录。类似的有autojump，fasd等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bogon :: ~ » cd /opt/video1 </div><div class="line">bogon :: /opt/video1 » cd ~</div><div class="line">bogon :: ~ » z video1</div><div class="line">bogon :: /opt/video1 »</div></pre></td></tr></table></figure></p><p>大量的插件会拖慢打开的速度，开启需谨慎。</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>zsh完全兼容bash</li><li>连按两次Tab会列出所有的补全列表并直接开始选择，补全项可以使用 ctrl+n/p/f/b上下左右切换</li><li>命令选项补全。在zsh中只需要键入 tar -<tab> 就会列出所有的选项和帮助说明</tab></li><li>命令参数补全。键入 kill <tab> 就会列出所有的进程名和对应的进程号</tab></li><li>命令历史记录，可以用 !!来执行上一条命令，使用 ctrl-r 来搜索命令历史记录</li><li>命令不全，命令和文件补全(按tab键)</li><li>命令别名，在 .zshrc 中添加 alias shortcut=’command’ 一行就相当于添加了别名</li><li>更智能的历史命令。在用或者方向上键查找历史命令时，zsh支持限制查找。比如，输入ls,然后再按方向上键，则只会查找用过的ls命令。而此时使用则会仍然按之前的方式查找，忽略 ls</li><li>多个终端会话共享历史记录</li><li>智能跳转，安装了 autojump 之后，zsh 会自动记录你访问过的目录，通过 j 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过 hadoop-1.0.0 目录，输入j hado 即可正确跳转。j –stat 可以看你的历史路径库。</li><li>目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</li><li>在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。在你知道路径的情况下，比如 /usr/local/bin 你可以输入 cd /u/l/b 然后按进行补全快速输入</li><li>通配符搜索：ls -l <strong>/*.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find。使用 </strong>/ 来递归搜索<br>扩展环境变量，输入环境变量然后按 就可以转换成表达的值</li><li>在 .zshrc 中添加 setopt HIST_IGNORE_DUPS 可以消除重复记录，也可以利用 sort -t “;” -k 2 -u ~/.zsh_history | sort -o ~/.zsh_history 手动清除</li></ul><p>参考：<br><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="external">zsh主题</a><br><a href="http://wdxtub.com/2016/02/18/oh-my-zsh/" target="_blank" rel="external">zsh 全程指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;zsh介绍&quot;&gt;&lt;a href=&quot;#zsh介绍&quot; class=&quot;headerlink&quot; title=&quot;zsh介绍&quot;&gt;&lt;/a&gt;zsh介绍&lt;/h2&gt;&lt;p&gt;Zsh 也许是目前最好用的 shell，是 bash 替代品中较为优秀的一个，号称终极shell。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LINUX" scheme="http://mufool.com/tags/LINUX/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客环境搭建</title>
    <link href="http://mufool.com/2017/09/13/hexo-blog/"/>
    <id>http://mufool.com/2017/09/13/hexo-blog/</id>
    <published>2017-09-13T09:20:19.000Z</published>
    <updated>2017-09-13T09:21:46.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install git -y</div></pre></td></tr></table></figure><h2 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h2><p>到 Node.js 官网下载相应平台的 最新版本 ，一路安装即可。<a href="https://www.ibm.com/developerworks/cn/opensource/os-nodejs/index.html" target="_blank" rel="external">Node.js 究竟是什么？</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wget https:<span class="comment">//nodejs.org/dist/v6.11.3/node-v6.11.3.tar.gz  --no-check-certificate</span></div><div class="line">tar -xzvf node-v6.11.3.tar.gz</div><div class="line">cd node-v6.11.3</div><div class="line">./configure</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo</div></pre></td></tr></table></figure><p>在blog所在目录下安装插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install hexo --save</div><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure><p>同时，执行以下命令查看缺少的插件逐个安装，否则无法生成所需要的index.html等文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm ls --depth 0</div></pre></td></tr></table></figure><h2 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h2><h3 id="生产key并添加"><a href="#生产key并添加" class="headerlink" title="生产key并添加"></a>生产key并添加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;邮件地址@gmail.com&quot;</div></pre></td></tr></table></figure><p>一路回车，将生产的id_rsa.pub文件内容添加到github的SSH keys的配置项中。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure><p>提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi cnfeat! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure><h3 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h3><p>现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。<br>Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;mufool&quot;//用户名</div><div class="line">$ git config --global user.email  &quot;email@gmail.com&quot;//填写自己的邮箱</div></pre></td></tr></table></figure><h2 id="生产部署"><a href="#生产部署" class="headerlink" title="生产部署"></a>生产部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">hexo d</div></pre></td></tr></table></figure><p>提交成功</p><p>注：其他问题，自行google</p><p>参考：<br><a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="external">如何搭建一个独立博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;git安装&quot;&gt;&lt;a href=&quot;#git安装&quot; class=&quot;headerlink&quot; title=&quot;git安装&quot;&gt;&lt;/a&gt;git安装&lt;/h2&gt;
    
    </summary>
    
    
      <category term="HEXO" scheme="http://mufool.com/tags/HEXO/"/>
    
  </entry>
  
  <entry>
    <title>Java操作redis</title>
    <link href="http://mufool.com/2017/08/25/java-redis/"/>
    <id>http://mufool.com/2017/08/25/java-redis/</id>
    <published>2017-08-25T02:15:10.000Z</published>
    <updated>2017-09-08T03:45:38.064Z</updated>
    
    <content type="html"><![CDATA[<p>连接操作命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">quit：关闭连接（connection）</div><div class="line">auth：简单密码认证</div><div class="line">help cmd： 查看cmd帮助，例如：help quit</div></pre></td></tr></table></figure><a id="more"></a><p>持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">save：将数据同步保存到磁盘</div><div class="line">bgsave：将数据异步保存到磁盘</div><div class="line">lastsave：返回上次成功将数据保存到磁盘的Unix时戳</div><div class="line">shundown：将数据同步保存到磁盘，然后关闭服务</div></pre></td></tr></table></figure><p>远程服务控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">info：提供服务器的信息和统计</div><div class="line">monitor：实时转储收到的请求</div><div class="line">slaveof：改变复制策略设置</div><div class="line">config：在运行时配置Redis服务器</div></pre></td></tr></table></figure><p>对value操作的命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">exists(key)：确认一个key是否存在</div><div class="line">del(key)：删除一个key</div><div class="line">type(key)：返回值的类型</div><div class="line">keys(pattern)：返回满足给定pattern的所有key</div><div class="line">randomkey：随机返回key空间的一个</div><div class="line">keyrename(oldname, newname)：重命名key</div><div class="line">dbsize：返回当前数据库中key的数目</div><div class="line">expire：设定一个key的活动时间（s）</div><div class="line">ttl：获得一个key的活动时间</div><div class="line">select(index)：按索引查询</div><div class="line">move(key, dbindex)：移动当前数据库中的key到dbindex数据库</div><div class="line">flushdb：删除当前选择数据库中的所有key</div><div class="line">flushall：删除所有数据库中的所有key</div></pre></td></tr></table></figure><p>String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">set(key, value)：给数据库中名称为key的string赋予值value</div><div class="line">get(key)：返回数据库中名称为key的string的value</div><div class="line">getset(key, value)：给名称为key的string赋予上一次的value</div><div class="line">mget(key1, key2,…, key N)：返回库中多个string的value</div><div class="line">setnx(key, value)：添加string，名称为key，值为value</div><div class="line">setex(key, time, value)：向库中添加string，设定过期时间time</div><div class="line">mset(key N, value N)：批量设置多个string的值</div><div class="line">msetnx(key N, value N)：如果所有名称为key i的string都不存在</div><div class="line">incr(key)：名称为key的string增<span class="number">1</span>操作</div><div class="line">incrby(key, integer)：名称为key的string增加integer</div><div class="line">decr(key)：名称为key的string减<span class="number">1</span>操作</div><div class="line">decrby(key, integer)：名称为key的string减少integer</div><div class="line">append(key, value)：名称为key的string的值附加value</div><div class="line">substr(key, start, end)：返回名称为key的string的value的子串</div></pre></td></tr></table></figure><p>List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">rpush(key, value)：在名称为key的list尾添加一个值为value的元素</div><div class="line">lpush(key, value)：在名称为key的list头添加一个值为value的 元素</div><div class="line">llen(key)：返回名称为key的list的长度</div><div class="line">lrange(key, start, end)：返回名称为key的list中start至end之间的元素</div><div class="line">ltrim(key, start, end)：截取名称为key的list</div><div class="line">lindex(key, index)：返回名称为key的list中index位置的元素</div><div class="line">lset(key, index, value)：给名称为key的list中index位置的元素赋值</div><div class="line">lrem(key, count, value)：删除count个key的list中值为value的元素</div><div class="line">lpop(key)：返回并删除名称为key的list中的首元素</div><div class="line">rpop(key)：返回并删除名称为key的list中的尾元素</div><div class="line">blpop(key1, key2,… key N, timeout)：lpop命令的block版本。</div><div class="line">brpop(key1, key2,… key N, timeout)：rpop的block版本。</div><div class="line">rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部</div></pre></td></tr></table></figure><p>Set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">sadd(key, member)：向名称为key的set中添加元素member</div><div class="line">srem(key, member) ：删除名称为key的set中的元素member</div><div class="line">spop(key) ：随机返回并删除名称为key的set中一个元素</div><div class="line">smove(srckey, dstkey, member) ：移到集合元素</div><div class="line">scard(key) ：返回名称为key的set的基数</div><div class="line">sismember(key, member) ：member是否是名称为key的set的元素</div><div class="line">sinter(key1, key2,…key N) ：求交集</div><div class="line">sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合</div><div class="line">sunion(key1, (keys)) ：求并集</div><div class="line">sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合</div><div class="line">sdiff(key1, (keys)) ：求差集</div><div class="line">sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合</div><div class="line">smembers(key) ：返回名称为key的set的所有元素</div><div class="line">srandmember(key) ：随机返回名称为key的set的一个元素</div></pre></td></tr></table></figure><p>Hash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">hset(key, field, value)：向名称为key的hash中添加元素field</div><div class="line">hget(key, field)：返回名称为key的hash中field对应的value</div><div class="line">hmget(key, (fields))：返回名称为key的hash中field i对应的value</div><div class="line">hmset(key, (fields))：向名称为key的hash中添加元素field</div><div class="line">hincrby(key, field, integer)：将名称为key的hash中field的value增加integer</div><div class="line">hexists(key, field)：名称为key的hash中是否存在键为field的域</div><div class="line">hdel(key, field)：删除名称为key的hash中键为field的域</div><div class="line">hlen(key)：返回名称为key的hash中元素个数</div><div class="line">hkeys(key)：返回名称为key的hash中所有键</div><div class="line">hvals(key)：返回名称为key的hash中所有键对应的value</div><div class="line">hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;连接操作命令&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;quit：关闭连接（connection）&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;auth：简单密码认证&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;help cmd： 查看cmd帮助，例如：help quit&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://mufool.com/tags/JAVA/"/>
    
      <category term="REDIS" scheme="http://mufool.com/tags/REDIS/"/>
    
  </entry>
  
  <entry>
    <title>几种基本排序算法</title>
    <link href="http://mufool.com/2017/08/25/sort/"/>
    <id>http://mufool.com/2017/08/25/sort/</id>
    <published>2017-08-25T01:59:34.000Z</published>
    <updated>2017-09-08T03:45:38.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>每一轮从头开始两两比较，将较大的项放在较小项的右边，这样每轮下来保证该轮最大的数在最右边。</p><a id="more"></a><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = source.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</div><div class="line">                <span class="keyword">if</span>(source[j] &gt; source[j+<span class="number">1</span>]) &#123;</div><div class="line">                    swap(source, j, j + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h3><p>待排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">13 6 29 3</div></pre></td></tr></table></figure></p><p>排序过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1:6 13 3 29 //13和6，交换；13和29，不交换；29和3，交换</div><div class="line">2:6 3 13 29 //6和13，不交换；13和3，交换</div><div class="line">3:3 6 13 29 //6和3，交换</div></pre></td></tr></table></figure></p><p>冒泡排序算法还有个可以改进的地方，就是在算法中加入一个布尔变量标识该轮有没有进行数据的交换，若在某一次排序中未发现气泡位置的交换，则说明待排序的无序区中所有的项均已满足排序后的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = source.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">boolean</span> exchange = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</div><div class="line">                <span class="keyword">if</span>(source[j] &gt; source[j+<span class="number">1</span>]) &#123;</div><div class="line">                    swap(source, j, j + <span class="number">1</span>);</div><div class="line">                    exchange = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!exchange) <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>时间复杂度：冒泡排序最好的情况是初始状态是正序的，一次扫描即可完成排序，所以最好的时间复杂度为O(N)；最坏的情况是反序的，此时最坏的时间复杂度为O(N2)。平均情况，每轮N/2次循环，N轮时间复杂度为O(N2)。</li><li>稳定性：算法是稳定的，因为当a=b时，由于只有大于才做交换，故a和b的位置没有机会交换，所以算法稳定。</li><li>空间复杂度：空间复杂度为O(1)，不需要额外空间。</li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h3><p>选择排序改进了冒泡排序，将必要的交换次数从O(n2)减少到O(n)，但是比较次数仍保持为O(n2)。冒泡排序每比较一次就可能交换一次，但是选择排序是将一轮比较完后，把最小的放到最前的位置（或者把最大的放到最后）。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> min;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.length - <span class="number">1</span>; i++) &#123;</div><div class="line">            min = i;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; source.length; j++) &#123;</div><div class="line">                <span class="keyword">if</span>(source[j] &lt;source[min])</div><div class="line">                    min = j;</div><div class="line">            &#125;</div><div class="line">            swap(source, i, min);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="算法示例-1"><a href="#算法示例-1" class="headerlink" title="算法示例"></a>算法示例</h3><p>待排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">13 6 29 3</div></pre></td></tr></table></figure></p><p>排序过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1:3 6 29 13 //第一遍，3最小，13和3交换</div><div class="line">2:3 6 29 13 //第二遍，6最小，不需要交换</div><div class="line">3:3 6 13 29 //第三遍，13最小，交换</div></pre></td></tr></table></figure></p><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>时间复杂度：选择排序最好和最坏的情况一样运行了O(N2)时间，但是选择排序无疑更快，因为它进行的交换少得多，当N值较小时，特别是如果交换时间比比较时间大得多时，选择排序实际上是相当快的。平均复杂度也是O(N2)。</li><li>稳定性：算法是不稳定的，假设a=b，且a在b前面，而某轮循环中最小值在b后面，而次最小值需要跟a交换，这时候b就在a前面了，所以选择排序是不稳定的。</li><li>空间复杂度：空间复杂度为O(1)，不需要额外的空间。</li></ul><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h3><p>插入排序的实现步骤为：从第一个元素开始，该元素可以认为已经被排序 -&gt; 取出下一个元素，在已经排序的元素序列中从后向前扫描 -&gt; 如果该元素小于前一个元素，则将两者调换，再与前一个元素比较–&gt; 重复第三步，直到找到已排序的元素小于或者等于新元素的位置 -&gt; 将新元素插入到该位置中 -&gt; 重复第二步</p><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; source.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; (j &gt; <span class="number">0</span>) &amp;&amp; (source[j] &lt; source[j-<span class="number">1</span>]); j--) &#123;</div><div class="line">                swap(source, j, j-<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            sortNum ++;</div><div class="line">            print(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="算法示例-2"><a href="#算法示例-2" class="headerlink" title="算法示例"></a>算法示例</h3><p>待排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">13 6 29 3</div></pre></td></tr></table></figure></p><p>排序过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1:6 13 29 3 //第一遍，位置2开始，13比6大，不需要交换</div><div class="line">2:6 13 29 3 //第二遍，29分别比13和6大，不需要交换</div><div class="line">3:3 6 13 29 //第三遍，3比29小，交换；3比13小，交换；3比6小，交换</div></pre></td></tr></table></figure></p><h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>时间复杂度：插入排序最好的情况是序列已经是升序排列了，在这种情况下，需要进行N-1次比较即可，时间复杂度为O(N)，最坏的情况是序列降序排列，这时候时间复杂度为O(N2)。因此插入排序不适合对于数据量比较大的排序应用。但是如果需要排序的数据量很小(如小于千)，那么插入排序还是一个不错的选择。插入排序平均时间复杂度为O(N2)，但是它要比冒泡排序快一倍，比选择排序还要快一点，经常被用在较复杂的排序算法的最后阶段，例如快速排序。</li><li>稳定性：算法是稳定的，假设a=b，且a在b的前面，其排序位置必然比b先确定，而后面再插入b时，必然在a的后面，所以是稳定的。</li><li>空间复杂度：空间复杂度为O(1)，不需要额外的空间。</li></ul><p>注：冒泡最大的，选择最小的，插入到已排好序的</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="基本原理-3"><a href="#基本原理-3" class="headerlink" title="基本原理"></a>基本原理</h3><p>希尔排序是基于插入排序的，插入排序有个弊端，假设一个很小的数据项在很靠近右端的位置上，那么所有的中间数据项都必须向右移动一位，这个步骤对每一个数据项都执行了将近N次的复制，这也是插入排序效率为O(N2)的原因。</p><p>希尔排序的中心思想是将数据进行分组，然后对每一组数据进行插入排序，在每一组数据都有序后，再对所有的分组利用插入排序进行最后一次排序。这样可以显著减少数据交换的次数，以达到加快排序速度的目的。</p><h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> nElem = source.length;</div><div class="line">        <span class="keyword">while</span>(h &lt;= nElem / <span class="number">2</span>) &#123;</div><div class="line">            h = h * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(h &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt; nElem; i++) &#123;</div><div class="line">                <span class="comment">//insert sort</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nElem; j += h) &#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = j; (k - h &gt;= <span class="number">0</span>) &amp;&amp; source[k] &lt; source[k - h]; k -= h) &#123;</div><div class="line">                        swap(source, k, k - h);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            h = (h-<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这种思想需要依赖一个增量序列，我们称为n-增量，n表示进行排序时数据项之间的间隔，习惯上用h表示。增量序列在希尔排序中是很重要的。一般好的增量序列都有2个共同的特征： 最后一个增量必须为1，保证最后一趟是一次普通的插入排序；应该尽量避免序列中的值（尤其是相邻的值）互为倍数的情况</p><h3 id="算法示例-3"><a href="#算法示例-3" class="headerlink" title="算法示例"></a>算法示例</h3><p>待排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">13 6 29 3 38</div></pre></td></tr></table></figure></p><p>排序过程，这里选取的间隔为3和1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1:3 6 29 13 38 // 间隔为3，13和3，交换</div><div class="line">2:3 6 29 13 38 // 间隔为3，6和38不交换</div><div class="line">3:3 6 29 13 38 // 间隔为1，3和6不交换</div><div class="line">4:3 6 29 13 38 // 间隔为1，29用插入排序比6，3都大，不交换</div><div class="line">5:3 6 13 29 38 // 间隔为1，13通过插入排序和29交换，后面都类普通插入排序，省略</div><div class="line">...</div></pre></td></tr></table></figure></p><h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>时间复杂度：希尔排序时间复杂度平均为O(NlogN)，最好与最坏情况要根据具体的增量序列来判断，对于不同的增量序列有不同的复杂度。希尔排序的性能优于直接插入排序，因为在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来随着增量逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但是由于已经局部排过序了，所以已经接近有序状态，新的一趟排序过程也较快。因此，希尔排序在效率上较直接插入排序有较大的改进。</li><li>稳定性：希尔排序是不稳定的，因为不同的间隔对应的数据是独自比较的，如果a=b，但是不在同一个间隔上，显然会出现前后颠倒的情况，所以希尔排序是不稳定的。</li><li>空间复杂度： 空间复杂度为O(1)，不需要额外的存储空间。</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本原理-4"><a href="#基本原理-4" class="headerlink" title="基本原理"></a>基本原理</h3><p>快速排序本质上通过一个数组划分为两个子数组，然后递归地调用自身为每一个子数组进行快速排序来实现的，即算法分为三步：</p><ol><li>把数组或者子数组划分为左边（较小的关键字）的一组和右边（较大的关键字）的一组；</li><li>调用自身对左边的一组进行排序；</li><li>调用自身对右边的一组进行排序。</li></ol><p>快速排序需要划分数组，这就用到了划分算法。划分算法是由两个指针开始工作，两个指针分别指向数组的两头，左边的指针leftPtr向右移动，右边的指针rightPtr向左移动。当leftPtr遇到比枢纽（待比较的数据项，比其小的在其左边，比其大的在其右边，下面均称之为“枢纽”）小的数据项时继续右移，当遇到比枢纽大的数据项时就停下来；类似的rightPtr想反。两边都停下后，leftPtr和rightPtr都指在数组的错误一方的位置的数据项，交换这两个数据项。交换后继续移动这两个指针。</p><h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</div><div class="line">        recQuickSort(a,<span class="number">0</span>, a.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recQuickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(right-left &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> pivot = a[right]; <span class="comment">//保存最右边的值，以这个值作为划分点</span></div><div class="line">            <span class="keyword">int</span> partition = partitionIt(a,left, right, pivot);<span class="comment">//将数组划分两部分，并将划分点的值放在正确位置，并返回该位置</span></div><div class="line">            recQuickSort(a, left, partition-<span class="number">1</span>);<span class="comment">//调用自身对左边进行排序</span></div><div class="line">            recQuickSort(a, partition+<span class="number">1</span>, right);<span class="comment">//调用自身对右边进行排序</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partitionIt</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> pivot)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> leftPtr = left - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> rightPtr = right;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">while</span>(a[++leftPtr] &lt; pivot)&#123;&#125; <span class="comment">//从左到右，找比待比较大的</span></div><div class="line">            <span class="keyword">while</span>(rightPtr &gt; <span class="number">0</span> &amp;&amp; a[--rightPtr] &gt; pivot)&#123;&#125; <span class="comment">//从右到左，找比待比较的小的</span></div><div class="line">            <span class="keyword">if</span>(leftPtr &gt;= rightPtr) <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                Logs.info(a[leftPtr] + <span class="string">" "</span> + a[rightPtr]);</div><div class="line">                swap(a, leftPtr, rightPtr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Logs.info(a[leftPtr] + <span class="string">" "</span> + a[right]);</div><div class="line">        swap(a, leftPtr, right);<span class="comment">//将划分放在正确的位置</span></div><div class="line">        print(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">return</span> leftPtr;<span class="comment">//返回划分点，用于再次小范围划分</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="算法示例-4"><a href="#算法示例-4" class="headerlink" title="算法示例"></a>算法示例</h3><p>待比较<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source = &#123;13,6,29, 3, 15&#125;</div></pre></td></tr></table></figure></p><p>排序过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1:13 6 3 15 29 // 左边比15大的为29，右边比15小的为3，29和3，交换；重复，直到左右位置相同，记录位置</div><div class="line">2:3 6 13 15 29 // 上一步中位置3为中间位置，13,6,3，重复上面步骤</div><div class="line">3:3 6 13 15 29 // 右边15,19 重复第一步</div></pre></td></tr></table></figure></p><h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>时间复杂度：平均时间复杂度为O(NlogN)，最坏的情况下退化成插入排序了，为O(N2)。</li><li>稳定性：不稳定的排序方法。</li><li>空间复杂度：空间复杂度平均为O(logN)，空间复杂度主要是由于递归造成的。</li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="基本原理-5"><a href="#基本原理-5" class="headerlink" title="基本原理"></a>基本原理</h3><p> 归并排序的思想是把一个数组分成两半，排序每一半。然后用merge方法将数组的两半归并成一个有序的数组。被分的每一半使用递归，再次划分排序，直到得到的子数组只含有一个数据项为止。</p><h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] workSpace = <span class="keyword">new</span> <span class="keyword">int</span>[source.length];</div><div class="line">        recMergeSort(source,workSpace, <span class="number">0</span>, source.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recMergeSort</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] workSpace, <span class="keyword">int</span> lowerBound, <span class="keyword">int</span> upperBound)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(lowerBound == upperBound) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> mid = (lowerBound + upperBound) / <span class="number">2</span>;</div><div class="line">            recMergeSort(source, workSpace, lowerBound, mid); <span class="comment">//左边排</span></div><div class="line">            recMergeSort(source, workSpace, mid+<span class="number">1</span>, upperBound); <span class="comment">//右边排</span></div><div class="line">            merge(source, workSpace, lowerBound, mid+<span class="number">1</span>, upperBound);<span class="comment">//归并</span></div><div class="line">            print(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] workSpace, <span class="keyword">int</span> lowPtr, <span class="keyword">int</span> highPtr, <span class="keyword">int</span> upperBound)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> lowerBound = lowPtr;</div><div class="line">        <span class="keyword">int</span> mid = highPtr - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> n = upperBound - lowerBound + <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(lowPtr &lt;= mid &amp;&amp; highPtr &lt;= upperBound) &#123;</div><div class="line">            <span class="keyword">if</span>(a[lowPtr] &lt; a[highPtr]) &#123;</div><div class="line">                workSpace[j++] = a[lowPtr++];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                workSpace[j++] = a[highPtr++];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(lowPtr &lt;= mid) &#123;</div><div class="line">            workSpace[j++] = a[lowPtr++];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(highPtr &lt;= upperBound) &#123;</div><div class="line">            workSpace[j++] = a[highPtr++];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">            a[lowerBound + j] = workSpace[j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="算法示例-5"><a href="#算法示例-5" class="headerlink" title="算法示例"></a>算法示例</h3><p>待排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">13 6 29 3 15</div></pre></td></tr></table></figure></p><p>排序过程，先分为两堆，13,6,29一个数组，3,15一个数组；13,6,29再分为，13,6和29<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1:6 13 29 3 15 // 13和6排序</div><div class="line">2:6 13 29 3 15 // 6，13，29排序</div><div class="line">3:6 13 29 3 15 // 3，15排序</div><div class="line">4:3 6 13 15 29 // 两个数组合并</div></pre></td></tr></table></figure></p><h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>时间复杂度：归并排序的运行时间最差、最好和平均都是O(NlogN)</li><li>稳定性：归并排序是稳定的，由于没有发生数据交换</li><li>空间复杂度：空间复杂度为O(N)</li></ul><h2 id="二叉树排序"><a href="#二叉树排序" class="headerlink" title="二叉树排序"></a>二叉树排序</h2><h3 id="基本原理-6"><a href="#基本原理-6" class="headerlink" title="基本原理"></a>基本原理</h3><p>二叉树排序就是利用二叉搜索树的特点进行排序，二叉搜索树的特点是，左子节点比自己小，右子节点比自己大，那么二叉树排序的思想就是先将待排序序列逐个添加到二叉搜索树中去，再通过中序遍历二叉搜索树就可以将数据从小到大取出来。</p><h3 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;  </div><div class="line">    Node leftChild;  </div><div class="line">    Node rightChild;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;  </div><div class="line">        value = val;  </div><div class="line">    &#125;  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree2Sort</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Node root;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tree2Sort</span><span class="params">()</span> </span>&#123;  </div><div class="line">        root = <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> root;  </div><div class="line">    &#125; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.length; i++) &#123;  </div><div class="line">            <span class="keyword">int</span> value = source[i];  </div><div class="line">            Node node = <span class="keyword">new</span> Node(value);  </div><div class="line">            <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;  </div><div class="line">                root = node;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">else</span> &#123;  </div><div class="line">                Node current = root;  </div><div class="line">                Node parent;  </div><div class="line">                <span class="keyword">boolean</span> insertedOK = <span class="keyword">false</span>;  </div><div class="line">                <span class="keyword">while</span>(!insertedOK) &#123;  </div><div class="line">                    parent = current;  </div><div class="line">                    <span class="keyword">if</span>(value &lt; current.value) &#123;  </div><div class="line">                        current = current.leftChild;  </div><div class="line">                        <span class="keyword">if</span>(current == <span class="keyword">null</span>) &#123;  </div><div class="line">                            parent.leftChild = node;  </div><div class="line">                            insertedOK = <span class="keyword">true</span>;  </div><div class="line">                        &#125;  </div><div class="line">                    &#125;  </div><div class="line">                    <span class="keyword">else</span> &#123;  </div><div class="line">                        current = current.rightChild;  </div><div class="line">                        <span class="keyword">if</span>(current == <span class="keyword">null</span>) &#123;  </div><div class="line">                            parent.rightChild = node;  </div><div class="line">                            insertedOK = <span class="keyword">true</span>;  </div><div class="line">                        &#125;  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">                  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node current)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span>(current != <span class="keyword">null</span>) &#123;  </div><div class="line">            inOrder(current.leftChild);  </div><div class="line">            System.out.print(current.value + <span class="string">" "</span>);  </div><div class="line">            inOrder(current.rightChild);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="算法示例-6"><a href="#算法示例-6" class="headerlink" title="算法示例"></a>算法示例</h3><p>略</p><h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>时间复杂度：二叉树的插入时间复杂度为O(logN)，所以二叉树排序算法的时间复杂度为O(NlogN)，</li><li>稳定性：稳定</li><li>空间复杂度：空间复杂度为O(N)</li></ul><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="基本原理-7"><a href="#基本原理-7" class="headerlink" title="基本原理"></a>基本原理</h3><p>堆是一个完全二叉树，节点大于或等于自己的子节点。堆排序就是利用完全二叉树的结构将待排序的数据项依次添加到堆中，建立大根堆或者小根堆，从堆中取出的数据项是从大到小或从小到大排列的。因为根节点永远是最大或最小的，而堆中永远是取根节点。</p><h3 id="算法实现-7"><a href="#算法实现-7" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] array;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> currentIndex;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setHeapSort</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        maxSize = size;</div><div class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</div><div class="line">        currentIndex = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.length; i++) &#123;</div><div class="line">            array[currentIndex] = source[i]; <span class="comment">//插入到节点尾</span></div><div class="line">            tickedUp(currentIndex++); <span class="comment">//向上重新排好序，使得满足堆的条件</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tickedUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> parentIndex = (index - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//父节点的索引</span></div><div class="line">        <span class="keyword">int</span> temp = array[index]; <span class="comment">//将新加的尾节点存在temp中</span></div><div class="line">        <span class="keyword">while</span>(index &gt; <span class="number">0</span> &amp;&amp; array[parentIndex] &lt; temp) &#123;</div><div class="line">            array[index] = array[parentIndex];</div><div class="line">            index = parentIndex;</div><div class="line">            parentIndex = (index - <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        array[index] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxNum = array[<span class="number">0</span>];</div><div class="line">        array[<span class="number">0</span>] = array[--currentIndex];</div><div class="line">        trickleDown(<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> maxNum;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trickleDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> top = array[index];</div><div class="line">        <span class="keyword">int</span> largeChildIndex;</div><div class="line">        <span class="keyword">while</span>(index &lt; currentIndex/<span class="number">2</span>) &#123; <span class="comment">//while node has at least one child</span></div><div class="line">            <span class="keyword">int</span> leftChildIndex = <span class="number">2</span> * index + <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> rightChildIndex = leftChildIndex + <span class="number">1</span>;</div><div class="line">            <span class="comment">//find larger child</span></div><div class="line">            <span class="keyword">if</span>(rightChildIndex &lt; currentIndex &amp;&amp;  <span class="comment">//rightChild exists?</span></div><div class="line">                    array[leftChildIndex] &lt; array[rightChildIndex]) &#123;</div><div class="line">                largeChildIndex = rightChildIndex;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                largeChildIndex = leftChildIndex;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(top &gt;= array[largeChildIndex]) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            array[index] = array[largeChildIndex];</div><div class="line">            index = largeChildIndex;</div><div class="line">        &#125;</div><div class="line">        array[index] = top;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">int</span>[] source = &#123;<span class="number">13</span>,<span class="number">6</span>,<span class="number">29</span>, <span class="number">3</span>, <span class="number">15</span>&#125;;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        setHeapSort(<span class="number">5</span>);</div><div class="line">        insertSort(source);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxSize; i ++) &#123;</div><div class="line">            Logs.info(getMax());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="算法示例-7"><a href="#算法示例-7" class="headerlink" title="算法示例"></a>算法示例</h3><p>略</p><h3 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>时间复杂度：堆中插入和取出的时间复杂度均为O(logN)，所以堆排序算法的时间复杂度为O(NlogN)</li><li>稳定性：稳定</li><li>空间复杂度：空间复杂度为O(N)</li></ul><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="基本原理-8"><a href="#基本原理-8" class="headerlink" title="基本原理"></a>基本原理</h3><p>基于有向图的排序，见<a href="http://blog.csdn.net/eson_15/article/details/51194219" target="_blank" rel="external">拓扑排序</a></p><p><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="external">动图演示</a></p><p>参考：<br><a href="http://blog.csdn.net/eson_15/article/details/51952328" target="_blank" rel="external">常用数据结构和算法操作效率的对比总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;h3 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h3&gt;&lt;p&gt;每一轮从头开始两两比较，将较大的项放在较小项的右边，这样每轮下来保证该轮最大的数在最右边。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://mufool.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Cookie和Session原理</title>
    <link href="http://mufool.com/2017/08/25/cookie-session/"/>
    <id>http://mufool.com/2017/08/25/cookie-session/</id>
    <published>2017-08-25T01:56:26.000Z</published>
    <updated>2017-09-08T03:45:38.063Z</updated>
    
    <content type="html"><![CDATA[<p>Cookie和Session是为了在无状态的HTTP协议之上维护会话状态，使得服务器可以知道当前是和哪个客户在打交道。本文来详细讨论Cookie和Session的实现机制，以及其中涉及的安全问题。</p><a id="more"></a><p>因为HTTP协议是无状态的，即每次用户请求到达服务器时，HTTP服务器并不知道这个用户是谁、是否登录过等。现在的服务器之所以知道我们是否已经登录，是因为服务器在登录时设置了浏览器的Cookie。Session则是借由Cookie而实现的更高层的服务器与浏览器之间的会话。</p><h2 id="Cookie-的实现机制"><a href="#Cookie-的实现机制" class="headerlink" title="Cookie 的实现机制"></a>Cookie 的实现机制</h2><p>Cookie是由客户端保存的小型文本文件，其内容为一系列的键值对。 Cookie是由HTTP服务器设置的，保存在浏览器中， 在用户访问其他页面时，会在HTTP请求中附上该服务器之前设置的Cookie。 那么Cookie是怎样工作的呢？下面给出整个Cookie的传递流程：</p><ol><li>浏览器向某个URL发起HTTP请求</li><li>对应的服务器收到该HTTP请求，并计算应当返回给浏览器的HTTP响应。</li><li>在响应头加入Set-Cookie字段，它的值是要设置的Cookie。</li><li>浏览器收到来自服务器的HTTP响应。</li><li>浏览器在响应头中发现Set-Cookie字段，就会将该字段的值保存在内存或者硬盘中。Set-Cookie字段的值可以是很多项Cookie，每一项都可以指定过期时间Expires。 默认的过期时间是用户关闭浏览器时。</li><li>浏览器下次给该服务器发送HTTP请求时， 会将服务器设置的Cookie附加在HTTP请求的头字段Cookie中。浏览器可以存储多个域名下的Cookie，但只发送当前请求的域名曾经指定的Cookie， 这个域名也可以在Set-Cookie字段中指定）。</li><li>服务器收到这个HTTP请求，发现请求头中有Cookie字段， 便知道之前就和这个用户打过交道了。</li></ol><p>总之，服务器通过Set-Cookie响应头字段来指示浏览器保存Cookie， 浏览器通过Cookie请求头字段来告诉服务器之前的状态。 Cookie中包含若干个键值对，每个键值对可以设置过期时间。</p><h2 id="Cookie-的安全隐患和防篡改"><a href="#Cookie-的安全隐患和防篡改" class="headerlink" title="Cookie 的安全隐患和防篡改"></a>Cookie 的安全隐患和防篡改</h2><p>发送HTTP请求的不只是浏览器，很多HTTP客户端软件（包括curl、Node.js）都可以发送任意的HTTP请求，可以设置任何头字段。 假如我们直接设置Cookie字段并发送HTTP请求， 就可以欺骗服务器岂，这种攻击非常容易，Cookie是可以被篡改的！</p><p>为加强安全，服务器可以单独为每个Cookie项生成签名，由于用户篡改Cookie后无法生成对应的签名， 服务器便可以得知用户对Cookie进行了篡改。</p><p>例如，<code>Set-Cookie: authed=false|6hTiBl7lVpd1P</code>为authed项为false时生成一个加密的签名，客户端可以随意篡改authed字段，但是无法生成authed为false时的签名，服务端校验失败。</p><p>但是因为Cookie是明文传输的， 只要服务器设置过一次authed=true|xxxx我不就知道true的签名是xxxx了么， 以后就可以用这个签名来欺骗服务器了。因此Cookie中最好不要放敏感数据。 一般来讲Cookie中只会放一个Session Id，而Session存储在服务器端。</p><h2 id="Session-的实现机制"><a href="#Session-的实现机制" class="headerlink" title="Session 的实现机制"></a>Session 的实现机制</h2><p>Session 是存储在服务器端的，避免了在客户端Cookie中存储敏感数据。 Session 可以存储在HTTP服务器的内存中，也可以存在内存数据库（如redis）中， 对于重量级的应用甚至可以存储在数据库中。</p><ol><li>用户提交包含用户名和密码的表单，发送HTTP请求。</li><li>服务器验证用户发来的用户名密码。如果正确则把当前用户名（通常是用户对象）存储到redis中，并生成它在redis中的ID。</li><li>设置Cookie为sessionId=xxxxxx|checksum并发送HTTP响应， 仍然为每一项Cookie都设置签名。</li><li>用户收到HTTP响应后，便看不到任何敏感数据了。在此后的请求中发送该Cookie给服务器。</li><li>服务器收到此后的HTTP请求后，发现Cookie中有SessionID，进行放篡改验证。</li><li>如果通过了验证，根据该ID从Redis中取出对应的用户对象， 查看该对象的状态并继续执行业务逻辑。<br>Web应用框架都会实现上述过程，在Web应用中可以直接获得当前用户。 相当于在HTTP协议之上，通过Cookie实现了持久的会话。这个会话便称为Session。</li></ol><h2 id="flask中cookie和session的使用"><a href="#flask中cookie和session的使用" class="headerlink" title="flask中cookie和session的使用"></a>flask中cookie和session的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">main.secret_key = <span class="string">'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'</span></div><div class="line"></div><div class="line"><span class="meta">@main.route('/add')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></div><div class="line">    res = make_response(render_template(<span class="string">"index.html"</span>))</div><div class="line">    res.set_cookie(key=<span class="string">'username'</span>, value=<span class="string">'letian'</span>)</div><div class="line">    session[<span class="string">'name'</span>] = <span class="string">'tom'</span></div><div class="line">    <span class="keyword">return</span> res</div><div class="line"></div><div class="line"><span class="meta">@main.route('/show')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> request.cookies.get(<span class="string">'username'</span>)</div><div class="line">    <span class="keyword">if</span> <span class="string">'name'</span> <span class="keyword">in</span> session:</div><div class="line">        <span class="keyword">print</span> session[<span class="string">'name'</span>]</div><div class="line">    <span class="keyword">return</span> request.cookies.get(<span class="string">'username'</span>)</div></pre></td></tr></table></figure><p>客户端add的时候，分别在cookie中设置username，在session中设置name，使用session需要设置secret_key；客户端的show请求中，我们就能看到cookie中同时包含username：letian和session字段，在session中能解析到name字段。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cookie和Session是为了在无状态的HTTP协议之上维护会话状态，使得服务器可以知道当前是和哪个客户在打交道。本文来详细讨论Cookie和Session的实现机制，以及其中涉及的安全问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WEB" scheme="http://mufool.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>Centos下安装Grunt</title>
    <link href="http://mufool.com/2017/08/21/centos-grunt/"/>
    <id>http://mufool.com/2017/08/21/centos-grunt/</id>
    <published>2017-08-21T04:46:56.000Z</published>
    <updated>2017-09-08T03:45:38.063Z</updated>
    
    <content type="html"><![CDATA[<p>Grunt是一个自动化的项目构建工具. 如果你需要重复的执行像压缩, 编译, 单元测试, 代码检查以及打包发布的任务。</p><a id="more"></a><h2 id="CentOS-下安装-Node-js"><a href="#CentOS-下安装-Node-js" class="headerlink" title="CentOS 下安装 Node.js"></a>CentOS 下安装 Node.js</h2><p>1、下载源码，你需要在<code>https://nodejs.org/en/download/</code>下载最新的Nodejs版本，本文以v0.10.24为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/src/</div><div class="line">wget http://nodejs.org/dist/v0.10.24/node-v0.10.24.tar.gz</div></pre></td></tr></table></figure><p>2、解压源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar zxvf node-v0.10.24.tar.gz</div></pre></td></tr></table></figure><p>3、 编译安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd node-v0.10.24</div><div class="line">./configure --prefix=/usr/local/node/0.10.24</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure><p>4、 配置NODE_HOME，进入profile编辑环境变量<code>vim /etc/profile</code></p><p>设置nodejs环境变量，添加如下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#set for nodejs</div><div class="line">export NODE_HOME=/usr/local/node/0.10.24</div><div class="line">export PATH=$NODE_HOME/bin:$PATH</div></pre></td></tr></table></figure><p><code>:wq</code>保存并退出，编译/etc/profile 使配置生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/profile</div></pre></td></tr></table></figure><p>验证是否安装配置成功<code>node -v</code>，输出 v0.10.24 表示配置成功。</p><h2 id="安装NPM"><a href="#安装NPM" class="headerlink" title="安装NPM"></a>安装NPM</h2><p>装好NodeJS后，可以在你的终端执行下面的命令安装NPM：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl http://npmjs.org/install.sh | sh</div></pre></td></tr></table></figure><p>检查是否安装成功<code>npm -v</code></p><h2 id="Grunt安装"><a href="#Grunt安装" class="headerlink" title="Grunt安装"></a>Grunt安装</h2><p>Grunt和Grunt插件都是通过npm, Node.js包管理器安装和管理的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g grunt-cli</div></pre></td></tr></table></figure><p>这条命令将会把grunt命令植入到你的系统路径中，这样就允许你从任意目录中运行Grunt(定位到任意目录运行grunt命令)。</p><p>查看是否安装成功<code>grunt --version</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grunt-cli v1.2.0</div></pre></td></tr></table></figure><p>注意：安装grunt-cli并不等于安装了Grunt任务运行器! Grunt CLI的工作很简单：在Gruntfile所在目录调用运行已安装好的相应版本的Grunt。这就意味着可以在同一台机器上同时安装多个版本的Grunt。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Grunt是一个自动化的项目构建工具. 如果你需要重复的执行像压缩, 编译, 单元测试, 代码检查以及打包发布的任务。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JS" scheme="http://mufool.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>P2P之NAT详解</title>
    <link href="http://mufool.com/2017/08/21/p2p-nat/"/>
    <id>http://mufool.com/2017/08/21/p2p-nat/</id>
    <published>2017-08-21T03:39:53.000Z</published>
    <updated>2017-09-12T01:55:15.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NAT简介"><a href="#NAT简介" class="headerlink" title="NAT简介"></a>NAT简介</h2><p>&emsp;&emsp;NAT，网络地址转换，就是替换IP报文头部的地址信息。NAT通常部署在一个组织的网络出口位置，通过将内部网络IP地址替换为出口的IP地址提供公网可达性和上层协议的连接能力。<br>&emsp;&emsp;NAT的主要目的是解决IPV4缺少带来的问题，有了NAT技术，就可以在少量的公网IP和内网地址（10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255）之间建立映射关系。</p><a id="more"></a><h2 id="NAT分类"><a href="#NAT分类" class="headerlink" title="NAT分类"></a>NAT分类</h2><p>&emsp;&emsp;NAT共分为两大类：Cone NAT和Symmetric NAT。Cone NAT指的是只要源IP端口不变，无论发往的目的IP是否相同，在NAT上都映射为同一个端口，形象的看来就像锥子一样，而SymmetricNAT对于发往不同目的IP的会话在NAT上将映射为不同的端口，也就是不同的会话。 其中Cone NAT又可细分为3类，分别是Full Cone型（全锥形）、Restricted Cone型（受限锥形）和Restricted Port Cone（端口受限锥形）。限制的严格程度和对局域网内主机的保护由松到紧依次为：Full Cone、RestrictedCone、Restricted Port Cone、Symmetric NAT。“限制”指的是NAT对由外到内的数据包进行审查、过滤，看看数据包的源地址和他发送到的“洞”是否有关系，如果没有那么就将其丢弃。由内向外的限制有防火墙管理。</p><h3 id="全锥形NAT"><a href="#全锥形NAT" class="headerlink" title="全锥形NAT"></a>全锥形NAT</h3><p><img src="http://mufool.qiniudn.com/p2pnat/fc.jpg" alt="fc"><br>IP、端口都不受限。NAT设备会将客户端的{X, y}转换成公网地址的{A, b}并绑定对应关系，任何数据包通过地址{A,b}都将送到客户机的{X,y}上。</p><h3 id="受限锥形NAT"><a href="#受限锥形NAT" class="headerlink" title="受限锥形NAT"></a>受限锥形NAT</h3><p> <img src="http://mufool.qiniudn.com/p2pnat/rc.jpg" alt="rc"></p><p> IP受限，端口不受限。NAT设备会将客户端的{X, y}转换成公网地址的{A, b}并绑定对应关系，只有来自于{P}这个ip地址的包才能和主机{X, y}通信。</p><h3 id="端口受限锥型NAT"><a href="#端口受限锥型NAT" class="headerlink" title="端口受限锥型NAT"></a>端口受限锥型NAT</h3><p><img src="http://mufool.qiniudn.com/p2pnat/pc.jpg" alt="pc"><br>IP、端口都受限。NAT设备会将客户端的{X, y}转换成公网地址的{A, b}并绑定{X, y}，{A,b}和{P,q}的对应关系，NAT只会接受来自{P,q}的数据包，并将其转发到{X,y}。如果{X，y}改为向{M,n}发送数据，则{P,q}再向{A,b}发送的数据不会被接受。</p><h3 id="对称型NAT"><a href="#对称型NAT" class="headerlink" title="对称型NAT"></a>对称型NAT</h3><p> <img src="http://mufool.qiniudn.com/p2pnat/sn.jpg" alt="sn"><br>对称型NAT具有端口受限锥型的受限特性。但更重要的是，他对每个外部主机或端口的会话都会映射为不同的端口（洞）。NAT设备会将客户端的{X, y}转换成公网地址的{A, b}并绑定{X, y}，{A,b}和{P,q}的对应关系，NAT只会接受来自{P,q}的数据包，并将其转发到{X,y}，当请求一个新的地址{M,n}时，NAT设备会重新分配一个新的ip，端口{C,d}。</p><h2 id="NAT弊端"><a href="#NAT弊端" class="headerlink" title="NAT弊端"></a>NAT弊端</h2><p>在理论上，具有IP地址的每个站点在协议层面有相当的获取服务和提供服务的能力，不同的IP地址之间没有差异。NAT技术的出现破坏了IP端到端通信的能力。<br>首先，NAT使IP会话的保持时效变短。因为一个会话建立后会在NAT设备上建立一个关联表，在会话静默的这段时间，NAT网关会进行超时回收资源的操作。所以应用协议必须有报活的协议才能保持会话。<br>其次，NAT在实现上将多个内部主机发出的连接复用到一个IP上，这就使依赖IP进行主机跟踪的机制都失效了。如网络管理中需要的基于网络流量分析的应用无法跟踪到终端用户与流量的具体行为的关系。基于用户行为的日志分析也变得困难，因为一个IP被很多用户共享，如果存在恶意的用户行为，很难定位到发起连接的那个主机。<br>此外，NAT工作机制依赖于修改IP包头的信息，这会妨碍一些安全协议的工作。因为NAT篡改了IP地址、传输层端口号和校验和，这会导致认证协议彻底不能工作，因为认证目的就是要保证这些信息在传输过程中没有变化。<br>总之，因为NAT隐蔽了通信的一端，把简单的事情复杂化了。</p><h2 id="NAT穿透技术"><a href="#NAT穿透技术" class="headerlink" title="NAT穿透技术"></a>NAT穿透技术</h2><p>&emsp;&emsp;为了解决IP端到端应用在NAT环境下遇到的问题，网络协议的设计者们创造了很多工具来应对，其中主要有应用层网关，探针技术STUN和TURN，中间件技术，中继代理技术，特定协议的自穿越技术。这里主要介绍探针技术STUN和TURN。</p><p>&emsp;&emsp;所谓探针技术STUN，是通过在所有参与通信的实体上安装探测插件，以检测网络中是否存在NAT网关，并对不同NAT模型实施不同穿越方法的一种技术。所谓中继服务TURN，是通过转发请求实现两台具有NAT设备的内网IP建立链接。</p><h3 id="NAT类型识别"><a href="#NAT类型识别" class="headerlink" title="NAT类型识别"></a>NAT类型识别</h3><p>&emsp;&emsp;STUN服务器上两个公网IP分别A1,A2，同时绑定两个端口P1,P2。在主机上使用两个IP主要是测试客户机是否是对称型NAT和时候是IP受限制型NAT。主要测试流程如下：</p><ol><li>使用端口1发送消息给A1:P1，测试能否响应，能响应则UDP协议可以通过</li><li>使用端口1发送消息给A2:P2，比较响应中的地址和上一步返回的地址是否一致，验证NAT是否对不通的目的地址进行相同的映射</li><li>使用端口1发送消息给第一部中返回的NAT上映射的外网IP和端口，测试是否有回应，验证NAT是否回环</li><li>使用端口2发送消息给A1:P1，服务器端使用A2:P1回复，验证是否为IP受限NAT</li><li>使用端口2发送消息给A1:P1，服务器端使用A1:P2回复，验证是否为端口受限NAT</li><li>同时，通过以上服务器返回的客户端IP，可以有很多方法确定是否是公网IP，如绑定这个地址或者与本地网卡中IP地址比较</li></ol><h3 id="NAT穿透"><a href="#NAT穿透" class="headerlink" title="NAT穿透"></a>NAT穿透</h3><p>其中一个是公网（5种）<br>客户端A是公网，A通知服务器S希望与B建立通信；S将消息转给B；B主动连接A，NAT上留下与A通信用的映射关系；A就可以与B进行正常通信，打洞成功。这种情况下，无论B是什么类型，都能成功建立连接。</p><p>其中一个是FC（4种）<br>客户端A是FC类型，A通知S与B建立通信；S通知B想A已经存在的洞建立连接；A收到B的连接包，打洞成功。这种情况下，因为A主要在NAT上有对应关系，则任何其他地址都可以通着这个对应关系与A建立连接</p><p>其中一个是RC（3种）</p><ul><li>RC和RC，A连接S希望连B，NAT上映射关系Na只能与S通信；B和S也有保存会话的NAT映射关系Nb，此时B去连接A上的Na，失败，但是Nb属性更改为与A的连接，此时A连接B可以成功，同时Na的属性也更改为与B的连接，打洞成功。（注：真正使用可能不会复用与服务器的报端连接，而是A和B同时连接对方，后连接的以方可以打洞成功）</li><li>RC和PC，与RC和RC类似</li><li>RC和SN，B向A不通；然后A向B发包，不通，但A上留下一个可以给B使用的洞；B在使用新的映射连接A，A可以收到，并拿到B上留给A的洞的信息；A回复B，连接建立。</li></ul><p>其中一个是PC（2种）</p><ul><li>PC和PC，同RC和RC。B连A，丢弃； A连B，通过；B回复A，连接建立</li><li>PC和SN，与RC和SN的过程类似，但是在第三步，B使用新的映射连接A，A无法收到B的消息，因为A是端口受限，所以PC和SN无法打洞成功。</li></ul><p>其中一个是SN（1种）</p><ul><li>SN和SN，无法成功</li></ul><table><thead><tr><th>类型</th><th>公网</th><th>FC</th><th>RC</th><th>PC</th><th>SN </th></tr></thead><tbody><tr><td>公网</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>FC</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>RC</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>PC</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>SN</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr></tbody></table><p>参考：<br><a href="https://www.slideshare.net/foxhengxing/p2pnat" target="_blank" rel="external">P2P之NAT穿透</a><br><a href="http://www.52im.net/thread-50-1-1.html" target="_blank" rel="external">NAT详解——详细原理、P2P简介</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;NAT简介&quot;&gt;&lt;a href=&quot;#NAT简介&quot; class=&quot;headerlink&quot; title=&quot;NAT简介&quot;&gt;&lt;/a&gt;NAT简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;NAT，网络地址转换，就是替换IP报文头部的地址信息。NAT通常部署在一个组织的网络出口位置，通过将内部网络IP地址替换为出口的IP地址提供公网可达性和上层协议的连接能力。&lt;br&gt;&amp;emsp;&amp;emsp;NAT的主要目的是解决IPV4缺少带来的问题，有了NAT技术，就可以在少量的公网IP和内网地址（10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255）之间建立映射关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="P2P" scheme="http://mufool.com/tags/P2P/"/>
    
  </entry>
  
  <entry>
    <title>Spark或Hadoop集群无法停止</title>
    <link href="http://mufool.com/2017/07/06/spark-no-stop/"/>
    <id>http://mufool.com/2017/07/06/spark-no-stop/</id>
    <published>2017-07-06T11:06:25.000Z</published>
    <updated>2017-09-26T04:50:49.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>执行<code>sbin/stop-all.sh</code>，提示：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Stopping namenodes on [master]</div><div class="line">master: no namenode to stop</div><div class="line">slave1: no datanode to stop</div><div class="line">Stopping secondary namenodes [master]</div><div class="line">master: no secondarynamenode to stop</div></pre></td></tr></table></figure><a id="more"></a><p>jps显示进程都在：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">25280</span> Jps</div><div class="line"><span class="number">4290</span> Master</div><div class="line"><span class="number">21235</span> SecondaryNameNode</div><div class="line"><span class="number">21395</span> ResourceManager</div><div class="line"><span class="number">15687</span> Master</div><div class="line"><span class="number">21052</span> NameNode</div></pre></td></tr></table></figure><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>以Spark为例，Spark启动停止都是通过<code>hadoop-daemon.sh</code>文件，其中部分代码如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment"># some variables</span></div><div class="line">log=<span class="string">"<span class="variable">$SPARK_LOG_DIR</span>/spark-<span class="variable">$SPARK_IDENT_STRING</span>-<span class="variable">$command</span>-<span class="variable">$instance</span>-<span class="variable">$HOSTNAME</span>.out"</span></div><div class="line">pid=<span class="string">"<span class="variable">$SPARK_PID_DIR</span>/spark-<span class="variable">$SPARK_IDENT_STRING</span>-<span class="variable">$command</span>-<span class="variable">$instance</span>.pid"</span></div><div class="line"></div><div class="line"><span class="comment"># Set default scheduling priority</span></div><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$SPARK_NICENESS</span>"</span> = <span class="string">""</span> ]; then</div><div class="line">export SPARK_NICENESS=<span class="number">0</span></div><div class="line">fi</div><div class="line"></div><div class="line">execute_command() &#123;</div><div class="line"><span class="keyword">if</span> [ -z $&#123;SPARK_NO_DAEMONIZE+set&#125; ]; then</div><div class="line">nohup -- <span class="string">"$@"</span> &gt;&gt; <span class="variable">$log</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &lt; /dev/null &amp;</div><div class="line">newpid=<span class="string">"$!"</span></div><div class="line"></div><div class="line">echo <span class="string">"<span class="variable">$newpid</span>"</span> &gt; <span class="string">"<span class="variable">$pid</span>"</span></div><div class="line"></div><div class="line"><span class="comment"># Poll for up to 5 seconds for the java process to start</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1</span>..<span class="number">10</span>&#125;</div><div class="line"><span class="keyword">do</span></div><div class="line"><span class="keyword">if</span> [[ $(ps -p <span class="string">"<span class="variable">$newpid</span>"</span> -o comm=) =~ <span class="string">"java"</span> ]]; then</div><div class="line"><span class="keyword">break</span></div><div class="line">fi</div><div class="line">sleep <span class="number">0.5</span></div><div class="line">done</div><div class="line"></div><div class="line">sleep <span class="number">2</span></div><div class="line"><span class="comment"># Check if the process has died; in that case we'll tail the log so the user can see</span></div><div class="line"><span class="keyword">if</span> [[ ! $(ps -p <span class="string">"<span class="variable">$newpid</span>"</span> -o comm=) =~ <span class="string">"java"</span> ]]; then</div><div class="line">echo <span class="string">"failed to launch: $@"</span></div><div class="line">tail -<span class="number">2</span> <span class="string">"<span class="variable">$log</span>"</span> | sed <span class="string">'s/^//'</span></div><div class="line">echo <span class="string">"full log in <span class="variable">$log</span>"</span></div><div class="line">fi</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="string">"$@"</span></div><div class="line">fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">run_command() &#123;</div><div class="line">mode=<span class="string">"<span class="variable">$1</span>"</span></div><div class="line">shift</div><div class="line"></div><div class="line">mkdir -p <span class="string">"<span class="variable">$SPARK_PID_DIR</span>"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$pid</span>"</span> ]; then</div><div class="line">TARGET_ID=<span class="string">"$(cat "</span><span class="variable">$pid</span><span class="string">")"</span></div><div class="line"><span class="keyword">if</span> [[ $(ps -p <span class="string">"<span class="variable">$TARGET_ID</span>"</span> -o comm=) =~ <span class="string">"java"</span> ]]; then</div><div class="line">echo <span class="string">"<span class="variable">$command</span> running as process <span class="variable">$TARGET_ID</span>.  Stop it first."</span></div><div class="line"><span class="keyword">exit</span> <span class="number">1</span></div><div class="line">fi</div><div class="line">fi</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$SPARK_MASTER</span>"</span> != <span class="string">""</span> ]; then</div><div class="line">echo rsync from <span class="string">"<span class="variable">$SPARK_MASTER</span>"</span></div><div class="line">rsync -a -e ssh --delete --exclude=.svn --exclude=<span class="string">'logs/*'</span> --exclude=<span class="string">'contrib/hod/logs/*'</span> <span class="string">"<span class="variable">$SPARK_MASTER</span>/"</span> <span class="string">"$&#123;SPARK_HOME&#125;"</span></div><div class="line">  fi</div><div class="line"></div><div class="line">spark_rotate_log <span class="string">"<span class="variable">$log</span>"</span></div><div class="line">echo <span class="string">"starting <span class="variable">$command</span>, logging to <span class="variable">$log</span>"</span></div><div class="line"></div><div class="line">  case <span class="string">"<span class="variable">$mode</span>"</span> <span class="keyword">in</span></div><div class="line">(class)</div><div class="line">execute_command nice -n <span class="string">"<span class="variable">$SPARK_NICENESS</span>"</span> <span class="string">"$&#123;SPARK_HOME&#125;"</span>/bin/spark-class <span class="string">"<span class="variable">$command</span>"</span> <span class="string">"$@"</span></div><div class="line">;;</div><div class="line"></div><div class="line">(submit)</div><div class="line">execute_command nice -n <span class="string">"<span class="variable">$SPARK_NICENESS</span>"</span> bash <span class="string">"$&#123;SPARK_HOME&#125;"</span>/bin/spark-submit --class <span class="string">"<span class="variable">$command</span>"</span> <span class="string">"$@"</span></div><div class="line">;;</div><div class="line"></div><div class="line">(*)</div><div class="line">echo <span class="string">"unknown mode: <span class="variable">$mode</span>"</span></div><div class="line"><span class="keyword">exit</span> <span class="number">1</span></div><div class="line">;;</div><div class="line">esac</div><div class="line">&#125;</div><div class="line"></div><div class="line">case <span class="variable">$option</span> <span class="keyword">in</span></div><div class="line"></div><div class="line">(submit)</div><div class="line"></div><div class="line">run_command submit <span class="string">"$@"</span></div><div class="line">;;</div><div class="line"></div><div class="line">(start)</div><div class="line"></div><div class="line">run_command class <span class="string">"$@"</span></div><div class="line">;;</div><div class="line"></div><div class="line">(stop)</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ -f <span class="variable">$pid</span> ]; then</div><div class="line">TARGET_ID=<span class="string">"$(cat "</span><span class="variable">$pid</span><span class="string">")"</span></div><div class="line"><span class="keyword">if</span> [[ $(ps -p <span class="string">"<span class="variable">$TARGET_ID</span>"</span> -o comm=) =~ <span class="string">"java"</span> ]]; then</div><div class="line">echo <span class="string">"stopping <span class="variable">$command</span>"</span></div><div class="line">kill <span class="string">"<span class="variable">$TARGET_ID</span>"</span> &amp;&amp; rm -f <span class="string">"<span class="variable">$pid</span>"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">echo <span class="string">"no <span class="variable">$command</span> to stop"</span></div><div class="line">fi</div><div class="line"><span class="keyword">else</span></div><div class="line">echo <span class="string">"no <span class="variable">$command</span> to stop"</span></div><div class="line">fi</div><div class="line">;;</div><div class="line"></div><div class="line">(status)</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ -f <span class="variable">$pid</span> ]; then</div><div class="line">TARGET_ID=<span class="string">"$(cat "</span><span class="variable">$pid</span><span class="string">")"</span></div><div class="line"><span class="keyword">if</span> [[ $(ps -p <span class="string">"<span class="variable">$TARGET_ID</span>"</span> -o comm=) =~ <span class="string">"java"</span> ]]; then</div><div class="line">echo <span class="variable">$command</span> is running.</div><div class="line"><span class="keyword">exit</span> <span class="number">0</span></div><div class="line"><span class="keyword">else</span></div><div class="line">echo <span class="variable">$pid</span> file is present but <span class="variable">$command</span> not running</div><div class="line"><span class="keyword">exit</span> <span class="number">1</span></div><div class="line">fi</div><div class="line"><span class="keyword">else</span></div><div class="line">echo <span class="variable">$command</span> not running.</div><div class="line"><span class="keyword">exit</span> <span class="number">2</span></div><div class="line">fi</div><div class="line">;;</div><div class="line"></div><div class="line">(*)</div><div class="line">echo <span class="variable">$usage</span></div><div class="line"><span class="keyword">exit</span> <span class="number">1</span></div><div class="line">;;</div><div class="line">esac</div></pre></td></tr></table></figure><p>可以看到，启动是会生成pid文件，停止时会读取pid文件，并<code>kill &quot;$TARGET_ID&quot; &amp;&amp; rm -f &quot;$pid&quot;</code>，在pid文件在不定义是，默认存放目录值tmp，linux系统默认每30天清理一次/tmp目录下的文件。pid文件丢失将导致无法正确关闭相应进程。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>pid文件的默认文件名格式如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pid=<span class="string">"<span class="variable">$SPARK_PID_DIR</span>/spark-<span class="variable">$SPARK_IDENT_STRING</span>-<span class="variable">$command</span>-<span class="variable">$instance</span>.pid"</span></div></pre></td></tr></table></figure><p>通过代码可以知道，</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$SPARK_PID_DIR</span> = /tmp</div><div class="line"><span class="variable">$SPARK_IDENT_STRING</span> = hdfs <span class="comment">#username</span></div><div class="line"><span class="variable">$command</span> = org.apache.spark.deploy.master.Master <span class="comment"># or worker</span></div><div class="line"><span class="variable">$instance</span> = <span class="number">1</span></div></pre></td></tr></table></figure><p>所以，我们只需要找到对应进程的进程号，创建文件并添加就可以正常关闭进程</p><h2 id="根治方法"><a href="#根治方法" class="headerlink" title="根治方法"></a>根治方法</h2><p>既然tmp目录会被系统定时清理，那么我们重新设置对应服务的pid存放路径即可</p><p>修改hadoop-env.sh，增加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> HADOOP_PID_DIR=/opt/hadoop/appid/</div></pre></td></tr></table></figure><p>修改spark-env.sh，增加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> SPARK_PID_DIR=/opt/hadoop/appid/</div></pre></td></tr></table></figure><p>重启对应服务：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-rw-rw-r-- <span class="number">1</span> hdfs hdfs <span class="number">6</span> Jul  <span class="number">6</span> <span class="number">15</span>:<span class="number">54</span> hadoop-hdfs-datanode.pid</div><div class="line">-rw-rw-r-- <span class="number">1</span> hdfs hdfs <span class="number">6</span> Jul  <span class="number">6</span> <span class="number">15</span>:<span class="number">54</span> hadoop-hdfs-journalnode.pid</div><div class="line">-rw-rw-r-- <span class="number">1</span> hdfs hdfs <span class="number">6</span> Jul  <span class="number">6</span> <span class="number">15</span>:<span class="number">44</span> spark-hdfs-org.apache.spark.deploy.worker.Worker-<span class="number">1</span>.pid</div><div class="line">-rw-rw-r-- <span class="number">1</span> hdfs hdfs <span class="number">6</span> Jul  <span class="number">6</span> <span class="number">15</span>:<span class="number">54</span> yarn-hdfs-nodemanager.pid</div></pre></td></tr></table></figure><p>通过这个问题我们可以知道，很多linux下对应的服务都有类似的控制脚本，或者可以添加类似的控制脚本，在存放pid文件时我们也要注意这个问题，防止因为系统原因，导致服务无法正常重启等问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;执行&lt;code&gt;sbin/stop-all.sh&lt;/code&gt;，提示：&lt;/p&gt;
&lt;figure class=&quot;highlight powershell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Stopping namenodes on [master]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;master: no namenode to stop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;slave1: no datanode to stop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Stopping secondary namenodes [master]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;master: no secondarynamenode to stop&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="SPARK" scheme="http://mufool.com/tags/SPARK/"/>
    
  </entry>
  
</feed>
