<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mufool</title>
  
  <subtitle>my blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mufool.com/"/>
  <updated>2019-11-15T04:07:11.533Z</updated>
  <id>http://mufool.com/</id>
  
  <author>
    <name>Mufool</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大数据平台架构</title>
    <link href="http://mufool.com/2019/11/15/bigdata-arch/"/>
    <id>http://mufool.com/2019/11/15/bigdata-arch/</id>
    <published>2019-11-15T04:05:30.000Z</published>
    <updated>2019-11-15T04:07:11.533Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="大数据平台架构演进"><a href="#大数据平台架构演进" class="headerlink" title="大数据平台架构演进"></a>大数据平台架构演进</h2><h3 id="经典数仓架构"><a href="#经典数仓架构" class="headerlink" title="经典数仓架构"></a>经典数仓架构</h3><p>在类似于Hadoop系列的大数据分析系统大行其道之前，数据分析工作已经经历了长足的发展，尤其是以BI系统为主的数据分析，已经有了非常成熟和稳定的技术方案和生态系统，对于BI系统来说，大概的架构图如下：</p><p><img src="index_files/33ec90c2-5af5-4890-ba8a-3b1e6c4ef308.jpg" alt=""></p><a id="more"></a><p>可以看到在BI系统里面，核心的模块是Cube，Cube是一个更高层的业务模型抽象，在Cube之上可以进行多种操作，例如上钻、下钻、切片等操作。大部分BI系统都基于关系型数据库，关系型数据库使用SQL语句进行操作，但是SQL在多维操作和分析的表示能力上相对较弱，所以Cube有自己独有的查询语言MDX，MDX表达式具有更强的多维表现能力，所以以Cube为核心的分析系统基本占据着数据统计分析的半壁江山，大多数的数据库服务厂商直接提供了BI套装软件服务，轻易便可搭建出一套Olap分析系统。不过BI的问题也随着时间的推移逐渐显露出来：</p><ul><li><p>BI系统更多的以分析业务数据产生的密度高、价值高的结构化数据为主，对于非结构化和半结构化数据的处理非常乏力，例如图片，文本，音频的存储，分析。</p></li><li><p>由于数据仓库为结构化存储，在数据从其他系统进入数据仓库这个东西，我们通常叫做ETL过程，ETL动作和业务进行了强绑定，通常需要一个专门的ETL团队去和业务做衔接，决定如何进行数据的清洗和转换。</p></li><li><p>随着异构数据源的增加，例如如果存在视频，文本，图片等数据源，要解析数据内容进入数据仓库，则需要非常复杂等ETL程序，从而导致ETL变得过于庞大和臃肿。</p></li><li><p>当数据量过大的时候，性能会成为瓶颈，在TB/PB级别的数据量上表现出明显的吃力。</p></li><li><p>数据库的范式等约束规则，着力于解决数据冗余的问题，是为了保障数据的一致性，但是对于数据仓库来说，我们并不需要对数据做修改和一致性的保障，原则上来说数据仓库的原始数据都是只读的，所以这些约束反而会成为影响性能的因素。</p></li><li><p>ETL动作对数据的预先假设和处理，导致机器学习部分获取到的数据为假设后的数据，因此效果不理想。例如如果需要使用数据仓库进行异常数据的挖掘，则在数据入库经过ETL的时候就需要明确定义需要提取的特征数据，否则无法结构化入库，然而大多数情况是需要基于异构数据才能提取出特征。</p></li></ul><p>在一系列的问题下，以Hadoop体系为首的大数据分析平台逐渐表现出优异性，围绕Hadoop体系的生态圈也不断的变大，对于Hadoop系统来说，从根本上解决了传统数据仓库的瓶颈的问题，但是也带来一系列的问题：</p><ul><li><p>从数据仓库升级到大数据架构，是不具备平滑演进的，基本等于推翻重做。</p></li><li><p>大数据下的分布式存储强调数据的只读性质，所以类似于Hive，HDFS这些存储方式都不支持update，HDFS的write操作也不支持并行，这些特性导致其具有一定的局限性。</p></li></ul><p>基于大数据架构的数据分析平台侧重于从以下几个维度去解决传统数据仓库做数据分析面临的瓶颈：</p><ul><li><p>分布式计算：分布式计算的思路是让多个节点并行计算，并且强调数据本地性，尽可能的减少数据的传输，例如Spark通过RDD的形式来表现数据的计算逻辑，可以在RDD上做一系列的优化，来减少数据的传输。</p></li><li><p>分布式存储：所谓的分布式存储，指的是将一个大文件拆成N份，每一份独立的放到一台机器上，这里就涉及到文件的副本，分片，以及管理等操作，分布式存储主要优化的动作都在这一块。</p></li><li><p>检索和存储的结合：在早期的大数据组件中，存储和计算相对比较单一，但是目前更多的方向是在存储上做更多的手脚，让查询和计算更加高效，对于计算来说高效不外乎就是查找数据快，读取数据快，所以目前的存储不单单的存储数据内容，同时会添加很多元信息，例如索引信息。像类似于parquet和carbondata都是这样的思想。</p></li></ul><p>总的来说，目前围绕Hadoop体系的大数据架构大概有以下几种：</p><h3 id="传统大数据架构"><a href="#传统大数据架构" class="headerlink" title="传统大数据架构"></a>传统大数据架构</h3><p><img src="index_files/f2e45286-90f3-406f-b41b-f3ed2c91b5ad.jpg" alt=""></p><p>之所以叫传统大数据架构，是因为其定位是为了解决传统BI的问题，简单来说，数据分析的业务没有发生任何变化，但是因为数据量、性能等问题导致系统无法正常使用，需要进行升级改造，那么此类架构便是为了解决这个问题。可以看到，其依然保留了ETL的动作，将数据经过ETL动作进入数据存储。</p><ul><li><p>优点：简单，易懂，对于BI系统来说，基本思想没有发生变化，变化的仅仅是技术选型，用大数据架构替换掉BI的组件。</p></li><li><p>缺点：对于大数据来说，没有BI下如此完备的Cube架构，虽然目前有kylin，但是kylin的局限性非常明显，远远没有BI下的Cube的灵活度和稳定度，因此对业务支撑的灵活度不够，所以对于存在大量报表，或者复杂的钻取的场景，需要太多的手工定制化，同时该架构依旧以批处理为主，缺乏实时的支撑。</p></li><li><p>适用场景：数据分析需求依旧以BI场景为主，但是因为数据量、性能等问题无法满足日常使用。</p></li></ul><h3 id="流式架构"><a href="#流式架构" class="headerlink" title="流式架构"></a>流式架构</h3><p><img src="index_files/d25852dd-5630-40f3-a869-b8da8a04632f.jpg" alt=""></p><p>在传统大数据架构的基础上，流式架构非常激进，直接拔掉了批处理，数据全程以流的形式处理，所以在数据接入端没有了ETL，转而替换为数据通道。经过流处理加工后的数据，以消息的形式直接推送给了消费者。虽然有一个存储部分，但是该存储更多的以窗口的形式进行存储，所以该存储并非发生在数据湖，而是在外围系统。</p><ul><li><p>优点：没有臃肿的ETL过程，数据的实效性非常高。</p></li><li><p>缺点：对于流式架构来说，不存在批处理，因此对于数据的重播和历史统计无法很好的支撑。对于离线分析仅仅支撑窗口之内的分析。</p></li><li><p>适用场景：预警，监控，对数据有有效期要求的情况。</p></li></ul><h3 id="Lambda架构"><a href="#Lambda架构" class="headerlink" title="Lambda架构"></a>Lambda架构</h3><p><img src="index_files/062a8ce0-0234-4ff0-a841-90caf5d5f147.jpg" alt=""></p><p>Lambda架构算是大数据系统里面举足轻重的架构，大多数架构基本都是Lambda架构或者基于其变种的架构。Lambda的数据通道分为两条分支：实时流和离线。</p><p>实时流依照流式架构，保障了其实时性，而离线则以批处理方式为主，保障了最终一致性。什么意思呢？流式通道处理为保障实效性更多的以增量计算为主辅助参考，而批处理层则对数据进行全量运算，保障其最终的一致性，因此Lambda最外层有一个实时层和离线层合并的动作，此动作是Lambda里非常重要的一个动作，大概的合并思路如下：</p><p><img src="index_files/06dbac82-5e05-4c75-9b6e-c5d2dbcf77f1.jpg" alt=""></p><ul><li><p>优点：既有实时又有离线，对于数据分析场景涵盖的非常到位。</p></li><li><p>缺点：离线层和实时流虽然面临的场景不相同，但是其内部处理的逻辑却是相同，因此有大量荣誉和重复的模块存在。</p></li><li><p>适用场景：同时存在实时和离线需求的情况。</p></li></ul><h3 id="Kappa架构"><a href="#Kappa架构" class="headerlink" title="Kappa架构"></a>Kappa架构</h3><p><img src="index_files/2ee1801d-6df4-41e5-ac78-251e5b27a769.jpg" alt=""></p><p>Kappa架构在Lambda 的基础上进行了优化，将实时和流部分进行了合并，将数据通道以消息队列进行替代。因此对于Kappa架构来说，依旧以流处理为主，但是数据却在数据湖层面进行了存储，当需要进行离线分析或者再次计算的时候，则将数据湖的数据再次经过消息队列重播一次则可。</p><ul><li><p>优点：Kappa架构解决了Lambda架构里面的冗余部分，以数据可重播的超凡脱俗的思想进行了设计，整个架构非常简洁。</p></li><li><p>缺点：虽然Kappa架构看起来简洁，但是施难度相对较高，尤其是对于数据重播部分。</p></li><li><p>适用场景：和Lambda类似，改架构是针对Lambda的优化。</p></li></ul><h3 id="Unifield架构"><a href="#Unifield架构" class="headerlink" title="Unifield架构"></a>Unifield架构</h3><p><img src="index_files/676ce0e1-33e5-4d6b-b9d2-fd2f3230447a.jpg" alt=""></p><p>以上的种种架构都围绕海量数据处理为主，Unifield架构则更激进，将机器学习和数据处理揉为一体，从核心上来说，Unifield依旧以Lambda为主，不过对其进行了改造，在流处理层新增了机器学习层。可以看到数据在经过数据通道进入数据湖后，新增了模型训练部分，并且将其在流式层进行使用。同时流式层不单使用模型，也包含着对模型的持续训练。</p><ul><li><p>优点：Unifield架构提供了一套数据分析和机器学习结合的架构方案，非常好的解决了机器学习如何与数据平台进行结合的问题。</p></li><li><p>缺点：Unifield架构实施复杂度更高，对于机器学习架构来说，从软件包到硬件部署都和数据分析平台有着非常大的差别，因此在实施过程中的难度系数更高。</p></li><li><p>适用场景：有着大量数据需要分析，同时对机器学习方便又有着非常大的需求或者有规划。</p></li></ul><h3 id="IOTA架构"><a href="#IOTA架构" class="headerlink" title="IOTA架构"></a>IOTA架构</h3><p>在IOT大潮下，智能手机、PC、智能硬件设备的计算能力越来越强，而业务需求要求数据实时响应需求能力也越来越强，过去传统的中心化、非实时化数据处理的思路已经不适应现在的大数据分析需求，我提出新一代的大数据IOTA架构来解决上述问题，整体思路是设定标准数据模型，通过边缘计算技术把所有的计算过程分散在数据产生、计算和查询过程当中，以统一的数据模型贯穿始终，从而提高整体的预算效率，同时满足即时计算的需要，可以使用各种Ad-hoc Query来查询底层数据。</p><p><img src="index_files/d1d1abbd-f5f4-4a98-8982-03a58df0d29e.jpg" alt=""></p><p>优点：</p><ul><li><p>去ETL化：ETL和相关开发一直是大数据处理的痛点。TA架构通过Common Data Model的设计，专注在某一个具体领域的数据计算，从而可以从SDK端开始计算，中央端只做采集、建立索引和查询，提高整体数据分析的效率</p></li><li><p>Ad-hoc即时查询：鉴于整体的计算流程机制，在手机端、智能IOT事件发生之时，就可以直接传送到云端进入real time data区，可以被前端的Query Engine来查询。此时用户可以使用各种各样的查询，直接查到前几秒发生的事件，而不用在等待ETL或者Streaming的数据研发和处理。</p></li><li><p>边缘计算（Edge-Computing）：将过去统一到中央进行整体计算，分散到数据产生、存储和查询端，数据产生既符合Common Data Model。同时，也给与Realtime model feedback，让客户端传送数据的同时马上进行反馈，而不需要所有事件都要到中央端处理之后再进行下发。</p></li></ul><h2 id="互联网公司大数据平台架构"><a href="#互联网公司大数据平台架构" class="headerlink" title="互联网公司大数据平台架构"></a>互联网公司大数据平台架构</h2><h3 id="阿里巴巴"><a href="#阿里巴巴" class="headerlink" title="阿里巴巴"></a>阿里巴巴</h3><p><img src="index_files/0052454c-adb1-450d-92c9-f03e3a06715a.jpg" alt=""></p><p><img src="index_files/c30fe1a6-e43e-412e-aebe-7166398c21d2.jpg" alt=""></p><p><a href="https://zhuanlan.zhihu.com/p/82258807" target="_blank" rel="external">阿里巴巴飞天大数据架构体系与Hadoop生态系统</a><br><a href="https://mp.weixin.qq.com/s/PUM-uA55E24LSHq4InQwSg" target="_blank" rel="external">大数据架构体系与Hadoop生态系统</a></p><h3 id="酷狗音乐的大数据平台架构"><a href="#酷狗音乐的大数据平台架构" class="headerlink" title="酷狗音乐的大数据平台架构"></a>酷狗音乐的大数据平台架构</h3><p><img src="index_files/0d049969-c592-4801-8be5-3477087a5a33.jpg" alt=""></p><p><a href="https://www.infoq.cn/article/kugou-big-data-platform-restructure" target="_blank" rel="external">经典大数据架构案例：酷狗音乐的大数据平台重构</a></p><p><img src="index_files/e7b21201-0491-4a63-9917-eb6379582802.jpg" alt=""></p><h3 id="滴滴大数据平台架构"><a href="#滴滴大数据平台架构" class="headerlink" title="滴滴大数据平台架构"></a>滴滴大数据平台架构</h3><p><img src="index_files/51fe93ff-603f-4a29-944d-6118c79710b9.jpg" alt=""></p><p><a href="https://myslide.cn/slides/15307#" target="_blank" rel="external">罗李：滴滴大数据离线和实时平台架构和实践</a></p><h3 id="知乎大数据平台架构"><a href="#知乎大数据平台架构" class="headerlink" title="知乎大数据平台架构"></a>知乎大数据平台架构</h3><p><img src="index_files/74393c7a-9302-467a-86e9-afd19f4870d2.jpg" alt=""></p><p><a href="https://myslide.cn/slides/15294#" target="_blank" rel="external">知乎大数据平台架构和实践优化</a></p><h3 id="美团大数据平台架构"><a href="#美团大数据平台架构" class="headerlink" title="美团大数据平台架构"></a>美团大数据平台架构</h3><p><img src="index_files/b1156a4f-9232-4013-9bac-ff330ad5d39f.jpg" alt=""></p><p><a href="https://zhuanlan.zhihu.com/p/26359613" target="_blank" rel="external">美团的大数据平台架构实践</a></p><h3 id="爱奇艺"><a href="#爱奇艺" class="headerlink" title="爱奇艺"></a>爱奇艺</h3><p><img src="index_files/f4473243-dd26-4e2e-8340-0df8587c329f.jpg" alt=""></p><p><a href="https://mp.weixin.qq.com/s/weHYPEZEzxsaJlP-zd7euQ" target="_blank" rel="external">爱奇艺大数据分析平台的演进之路</a></p><p>参考：<br><a href="https://mp.weixin.qq.com/s/SkGdlNqx7VU25YeZ7KOhqg" target="_blank" rel="external">Lambda架构已死，去ETL化的IOTA才是未来</a><br><a href="https://zhuanlan.zhihu.com/p/71969484" target="_blank" rel="external">数据仓库介绍与实时数仓案例–阿里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;大数据平台架构演进&quot;&gt;&lt;a href=&quot;#大数据平台架构演进&quot; class=&quot;headerlink&quot; title=&quot;大数据平台架构演进&quot;&gt;&lt;/a&gt;大数据平台架构演进&lt;/h2&gt;&lt;h3 id=&quot;经典数仓架构&quot;&gt;&lt;a href=&quot;#经典数仓架构&quot; class=&quot;headerlink&quot; title=&quot;经典数仓架构&quot;&gt;&lt;/a&gt;经典数仓架构&lt;/h3&gt;&lt;p&gt;在类似于Hadoop系列的大数据分析系统大行其道之前，数据分析工作已经经历了长足的发展，尤其是以BI系统为主的数据分析，已经有了非常成熟和稳定的技术方案和生态系统，对于BI系统来说，大概的架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;index_files/33ec90c2-5af5-4890-ba8a-3b1e6c4ef308.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="BIGDATA" scheme="http://mufool.com/tags/BIGDATA/"/>
    
  </entry>
  
  <entry>
    <title>vim基本操作</title>
    <link href="http://mufool.com/2019/11/01/vim-basic/"/>
    <id>http://mufool.com/2019/11/01/vim-basic/</id>
    <published>2019-11-01T03:27:24.000Z</published>
    <updated>2019-11-01T03:29:49.219Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><h3 id="字符移动"><a href="#字符移动" class="headerlink" title="字符移动"></a>字符移动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">k            上移</div><div class="line">h            左移</div><div class="line">l            右移</div><div class="line">j            下移</div></pre></td></tr></table></figure><a id="more"></a><p>你也可以使用键盘上的方向键来移动，但这么做<code>h j k l</code>的存在就失去了意义，之所以使用<code>h j k l</code>来控制方向，其主要目的是让你的手不离开键盘中心，从而提高效率。</p><blockquote><p>在命令前加上数字代表命令执行次数，如：5k，表示上移5行</p></blockquote><h3 id="单词移动"><a href="#单词移动" class="headerlink" title="单词移动"></a>单词移动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">W w            移动到下一个单词开头</div><div class="line">E e            移动到下一个单词结尾</div><div class="line">B b            倒退到上一个单词开头</div></pre></td></tr></table></figure><p>需要注意的是，E会忽略标点符号，如：I‘m，e会当成两个单词，E则不会。</p><p>同样，在命令前加上数字代表执行次数，如：2w，表示往下移动2个单词。</p><h3 id="整行移动"><a href="#整行移动" class="headerlink" title="整行移动"></a>整行移动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0            移动到行首</div><div class="line">$            移动到行末</div><div class="line">+            移动到下一行开头</div><div class="line">-            移动到上一行开头</div></pre></td></tr></table></figure><p><code>j k</code>也是移动到上一行和下一行，但它们移动的是光标所在的位置<br><code>+ -</code>不管你的光标在何处，总是移动到下一行或上一行的行首</p><h3 id="翻页"><a href="#翻页" class="headerlink" title="翻页"></a>翻页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Ctrl+f            往前滚动一整屏</div><div class="line">Ctrl+b            往后滚动一整屏</div><div class="line">Ctrl+d            往前滚动半屏</div><div class="line">Ctrl+u            往后滚动半屏</div><div class="line"></div><div class="line">Ctrl+e            往后滚动一行</div><div class="line">Ctrl+y            往前滚动一行</div></pre></td></tr></table></figure><p>看似比较多，但是可以根据键盘的位置来进行记忆，并且下面两个也不常用，上面的滚屏都有一个共同点，就是会改变光标的位置，且屏幕也在改变。</p><h3 id="滚屏"><a href="#滚屏" class="headerlink" title="滚屏"></a>滚屏</h3><p>如果想让光标维持在原来的位置可以用z调整光标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">z&lt;Enter&gt;        将光标所在行移动到屏幕顶端</div><div class="line">z.              将光标所在行移动到屏幕中间</div><div class="line">z-              将光标所在行移动到屏幕低端</div></pre></td></tr></table></figure><blockquote><p>980z<enter>可以将第980行移动到屏幕顶端</enter></p></blockquote><h3 id="在屏幕中移动"><a href="#在屏幕中移动" class="headerlink" title="在屏幕中移动"></a>在屏幕中移动</h3><p>有时候你其实不想滚屏，你只想在当前屏幕中移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">H            移动到屏幕顶端的行</div><div class="line">M            移动到屏幕中央的行</div><div class="line">L            移动到屏幕底端的行</div><div class="line"></div><div class="line">nH           移动到屏幕顶端往下的第n行</div><div class="line">nL           移动到屏幕顶端往上的第n行</div></pre></td></tr></table></figure><p>需要注意的是：这里只是光标的位置变化，和上面两种不同</p><blockquote><p>你可以用<code>+ -</code>和<code>j k</code>实现同样的位置变化，只不过要操作多次而已<br><code>+ -</code>和<code>j k</code>的区别忘了吗？往上看看吧</p></blockquote><h3 id="在当前行移动"><a href="#在当前行移动" class="headerlink" title="在当前行移动"></a>在当前行移动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">^            移动到当前行的第一个非空格处</div><div class="line">n|           移动到当前行的第n列</div></pre></td></tr></table></figure><p>这里的^与上面的0通常情况下表示的位置是一样的，而n|，个人感觉还没有h l方便，慢慢的数出行数还不如直接按着h l 左右移</p><h3 id="根据文本块移动"><a href="#根据文本块移动" class="headerlink" title="根据文本块移动"></a>根据文本块移动</h3><p>所谓的文本块也就是句子、段落、小节等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">（            移动到当前句子开头</div><div class="line">）            移动到下一个句子开头</div><div class="line">&#123;            移动到当前这一段开头</div><div class="line">&#125;            移动到下一段开头</div><div class="line">[[           移动到当前这一节的开头</div><div class="line">]]           移动到下一节的开头</div></pre></td></tr></table></figure><blockquote><p>其中，VIM以? . !等符号来标记一个句子<br>空白行来标记一个段落<br>用节宏来标记一个节（节宏是什么我还没搞清楚）</p></blockquote><h3 id="根据行号来移动"><a href="#根据行号来移动" class="headerlink" title="根据行号来移动"></a>根据行号来移动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Ctrl+g            显示当前行信息</div><div class="line">nG                转至第n行</div><div class="line">G                 转至文本末尾</div><div class="line">gg　　　　　　　　   移至文本开头</div></pre></td></tr></table></figure><p>如果你不知道当前是多少行的话就可以用Ctrl+g来查看，如果想转到第800行，可以用800G，其实z命令也可以做到，并且把光标移动到第一行。</p><blockquote><p>``反引号可以返回到使用G之前的位置</p></blockquote><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="字符位置插入"><a href="#字符位置插入" class="headerlink" title="字符位置插入"></a>字符位置插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i            在光标之前插入</div><div class="line">a            在光标之后追加</div></pre></td></tr></table></figure><p>开始用这两个就足够了，这就是最基础的</p><blockquote><p>nim<esc>，可以一次插入n个m </esc></p></blockquote><h3 id="行位置插入"><a href="#行位置插入" class="headerlink" title="行位置插入"></a>行位置插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A            在一行的结尾处追加</div><div class="line">I            在一行的开头处插入</div><div class="line">o            在光标所在位置的下一行打开新行插入</div><div class="line">O            在光标所在位置的上一行打开新行插入</div></pre></td></tr></table></figure><p>省去了移动在插入的过程</p><blockquote><p>同理，n0m<esc>，可以一次在n行插入m</esc></p></blockquote><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>合并行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">J            合并两行</div></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="字符删除"><a href="#字符删除" class="headerlink" title="字符删除"></a>字符删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x            删除光标所在处字符</div><div class="line">X            删除光标所在前字符</div></pre></td></tr></table></figure><h3 id="单词删除"><a href="#单词删除" class="headerlink" title="单词删除"></a>单词删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dw            删除到下一个单词开头</div><div class="line">de            删除到本单词末尾</div><div class="line">dE            删除到本单词末尾包括标点在内</div><div class="line">db            删除到前一个单词</div><div class="line">dB            删除到前一个单词包括标点在内</div></pre></td></tr></table></figure><h3 id="行删除"><a href="#行删除" class="headerlink" title="行删除"></a>行删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dd            删除一整行</div><div class="line">D或d$         删除光标位置到本行结尾</div><div class="line">d0            删除光标位置到本行开头</div></pre></td></tr></table></figure><blockquote><p>发散思维，3dd</p></blockquote><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><h3 id="字符替换"><a href="#字符替换" class="headerlink" title="字符替换"></a>字符替换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">r            单个字符替换</div><div class="line">R            连续替换</div><div class="line">～           更改大小写</div></pre></td></tr></table></figure><blockquote><p>组合操作同样适用</p></blockquote><h3 id="单词修改"><a href="#单词修改" class="headerlink" title="单词修改"></a>单词修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cw            从光标处修改到单词结尾</div><div class="line">cb            从光标处修改到单词开头</div></pre></td></tr></table></figure><p>这里直接使用cw或cb操作很简单，要注意的是加数字的使用方式，此时2cw 或者 c2w都可以使用，功能一样。</p><h3 id="行修改"><a href="#行修改" class="headerlink" title="行修改"></a>行修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">c$            从光标修改到本行末尾</div><div class="line">C             功能同上</div><div class="line">c0            从光标修改到本行开头</div><div class="line">cc            删除整行从头修改</div><div class="line">S             功能同上</div><div class="line">s             删除光标所在位置的字符，然后插入</div></pre></td></tr></table></figure><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="单词和字符复制"><a href="#单词和字符复制" class="headerlink" title="单词和字符复制"></a>单词和字符复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ynl            向右复制n个字符</div><div class="line">ynh            向左复制n个字符</div><div class="line">ynw            向前复制n个单词</div><div class="line">ynb            向后复制n个单词</div></pre></td></tr></table></figure><p>这里看起来并没有多大意义，因为复杂字符和单词还没有直接插入的方式来的快。</p><h3 id="行复制"><a href="#行复制" class="headerlink" title="行复制"></a>行复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">y0            复制到行首</div><div class="line">y$            复制到行末</div><div class="line">yy            复制整行</div><div class="line">yH            从当前行复制到屏幕顶端</div><div class="line">yL            从当前行复制到屏幕低端</div></pre></td></tr></table></figure><p>这里前两条用的也比较少，但是整行或多行复制才是yy的方便之处</p><blockquote><p>4yy也就是复制4行，y几乎可以跟任何光标移动命令结合</p></blockquote><h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p            粘帖</div></pre></td></tr></table></figure><h2 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h2><p>剪切很简单，就是先删除，然后按p粘帖</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>恢复在VIM里比较简单，不过想要具体恢复到某个时间段很难，就我的经验而言，有时候使用恢复还不如删了重写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">u            撤消上次命令</div><div class="line">U            恢复整行</div><div class="line">ctrl+r       重做</div><div class="line">.            重复</div><div class="line">e！          全文恢复</div></pre></td></tr></table></figure><p>u和ctrl+r对应的就是撤销和恢复</p><p>其中U也十分好用，它能恢复本行内容，无论你在本行做过什么，需要注意的是，你不能在别处操作多次后再回到那一行来恢复。</p><p><code>.</code>重复命令</p><p><code>e!</code>只要没有保存过，都能恢复</p><p>参考：<br><a href="http://cenalulu.github.io/linux/all-vim-cheatsheat/" target="_blank" rel="external">史上最全Vim快捷键键位图</a><br><a href="http://michael.peopleofhonoronly.com/vim/" target="_blank" rel="external">Vim Cheat Sheet for Programmers</a><br><a href="http://vimcolors.com/?utf8=%E2%9C%93&amp;bg=dark&amp;colors=term&amp;order=newest" target="_blank" rel="external">vimcolors</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;移动&quot;&gt;&lt;a href=&quot;#移动&quot; class=&quot;headerlink&quot; title=&quot;移动&quot;&gt;&lt;/a&gt;移动&lt;/h2&gt;&lt;h3 id=&quot;字符移动&quot;&gt;&lt;a href=&quot;#字符移动&quot; class=&quot;headerlink&quot; title=&quot;字符移动&quot;&gt;&lt;/a&gt;字符移动&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;k            上移&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;h            左移&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;l            右移&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;j            下移&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="vim" scheme="http://mufool.com/categories/vim/"/>
    
    
      <category term="VIM" scheme="http://mufool.com/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>Chrome快捷键</title>
    <link href="http://mufool.com/2019/10/08/chrome-shortcut/"/>
    <id>http://mufool.com/2019/10/08/chrome-shortcut/</id>
    <published>2019-10-08T12:36:06.000Z</published>
    <updated>2019-10-08T12:37:41.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标签和窗口快捷键"><a href="#标签和窗口快捷键" class="headerlink" title="标签和窗口快捷键"></a>标签和窗口快捷键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Ctrl + n            打开新窗口</div><div class="line">Ctrl + Shift + n    在无痕模式下打开新窗口</div><div class="line">Ctrl + t            打开新的标签页，并跳转到该标签页</div><div class="line">Ctrl + Shift + t    重新打开最后关闭的标签页，并跳转到该标签页</div><div class="line">Ctrl + Tab          跳转到下一个打开的标签页</div><div class="line">Ctrl + PgDn         跳转到下一个打开的标签页</div><div class="line">Ctrl + Shift + Tab  跳转到上一个打开的标签页</div><div class="line">Ctrl + PgUp         跳转到上一个打开的标签页</div><div class="line">Ctrl + n            跳转到特定标签页,n从1到8</div><div class="line">Ctrl + 9            跳转到最后一个标签页</div><div class="line">Alt + Home          在当前标签页中打开主页</div><div class="line">Alt + 向左箭头键     打开当前标签页浏览记录中记录的上一个页面</div><div class="line">Alt + 向右箭头键     打开当前标签页浏览记录中记录的下一个页面</div><div class="line">Ctrl + w/F4         关闭当前标签页</div><div class="line">Ctrl + Shift + w    关闭所有打开的标签页和浏览器</div><div class="line">Alt + 空格键 + n     最小化当前窗口</div><div class="line">Alt + 空格键 + x     最大化当前窗口</div><div class="line">Alt + F4            关闭当前窗口</div><div class="line">Ctrl + Shift + q    退出 Google Chrome</div></pre></td></tr></table></figure><a id="more"></a><h2 id="Google-Chrome-功能快捷键"><a href="#Google-Chrome-功能快捷键" class="headerlink" title="Google Chrome 功能快捷键"></a>Google Chrome 功能快捷键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Alt + f/Alt + e/F10        打开 Chrome 菜单</div><div class="line">Ctrl + Shift + b           显示或隐藏书签栏</div><div class="line">Ctrl + Shift + o           打开书签管理器</div><div class="line">Ctrl + h                   在新标签页中打开“历史记录”页</div><div class="line">Ctrl + j                   在新标签页中打开“下载内容”页</div><div class="line">Shift + Esc                打开 Chrome 任务管理器</div><div class="line">Shift + Alt + t            将焦点放置在 Chrome 工具栏中的第一项上</div><div class="line">F6                         在地址栏、书签栏（若显示）和页面内容之间向前切换焦点</div><div class="line">Shift + F6                 在地址栏、书签栏（若显示）和页面内容之间向后切换焦点</div><div class="line">Ctrl + f 或 F3             打开查找栏搜索当前网页</div><div class="line">Ctrl + g                   跳转到与查找栏中搜索字词相匹配的下一条内容</div><div class="line">Ctrl + Shift + g           跳转到与查找栏中搜索字词相匹配的上一条内容</div><div class="line">Ctrl + Shift + j 或 F12    打开“开发者工具”</div><div class="line">Ctrl + Shift + Delete      打开“清除浏览数据”选项</div><div class="line">F1                         在新标签页中打开 Chrome 帮助中心</div><div class="line">Ctrl + Shift + m           使用其他帐号登录或以访客身份浏览</div><div class="line">Alt + Shift + i            打开反馈表单</div></pre></td></tr></table></figure><h2 id="地址栏快捷键"><a href="#地址栏快捷键" class="headerlink" title="地址栏快捷键"></a>地址栏快捷键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入搜索字词并按Enter键           使用默认搜索引擎进行搜索</div><div class="line">输入搜索引擎名称并按Tab键         使用其他搜索引擎进行搜索</div><div class="line">输入网站名称并按 Ctrl + Enter键   为网站名称添加 www. 和 .com，并在当前标签页中打开该网站</div><div class="line">输入搜索字词并按 Alt + Enter 键   打开新的标签页并执行 Google 搜索</div><div class="line">Ctrl + l、Alt + d 或 F6          跳转到地址栏</div><div class="line">Ctrl + k 或 Ctrl + e             从页面中的任意位置搜索</div><div class="line">按向下箭头键以突出显示相应内容，然后按 Shift + Delete  从地址栏中移除联想查询内容</div></pre></td></tr></table></figure><h2 id="网页快捷键"><a href="#网页快捷键" class="headerlink" title="网页快捷键"></a>网页快捷键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Ctrl + p              打开选项以打印当前网页</div><div class="line">Ctrl + s              打开选项以保存当前网页</div><div class="line">F5 或 Ctrl + r        重新加载当前网页</div><div class="line">Shift + F5 或 Ctrl + Shift + r      重新加载当前网页（忽略缓存的内容）</div><div class="line">Esc                   停止加载网页</div><div class="line">Tab                   浏览下一个可点击项</div><div class="line">Shift + Tab           浏览上一个可点击项</div><div class="line">按住 Ctrl + o 键并选择文件           使用Chrome 打开计算机中的文件</div><div class="line">Ctrl + u              显示当前网页的 HTML 源代码（不可修改）</div><div class="line">Ctrl + d              将当前网页保存为书签</div><div class="line">Ctrl + Shift + d      将所有打开的标签页以书签的形式保存在新文件夹中</div><div class="line">F11                   开启或关闭全屏模式</div><div class="line">Ctrl 和 +             放大网页上的所有内容</div><div class="line">Ctrl 和 -             缩小网页上的所有内容</div><div class="line">Ctrl + 0              将网页上的所有内容恢复到默认大小</div><div class="line">空格键或 PgDn          向下滚动网页，一次一个屏幕</div><div class="line">Shift + 空格键或 PgUp  向上滚动网页，一次一个屏幕</div><div class="line">首页                   转到网页顶部</div><div class="line">末尾                   转到网页底部</div><div class="line">按住 Shift 键并滚动鼠标滚轮           在网页上水平滚动</div><div class="line">Ctrl + 向左箭头键      将光标移到文本字段中的上一个字词前面</div><div class="line">Ctrl + 向右箭头键      将光标移到文本字段中的上一个字词后面</div><div class="line">Ctrl + Backspace      删除文本字段中的上一个字词</div><div class="line">Alt + n               将焦点移到通知上</div><div class="line">Alt + Shift + a       在通知中允许</div><div class="line">Alt + Shift + d       在通知中拒绝</div><div class="line">Alt + Home            在当前标签页中打开主页</div></pre></td></tr></table></figure><h2 id="鼠标快捷键"><a href="#鼠标快捷键" class="headerlink" title="鼠标快捷键"></a>鼠标快捷键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">将链接拖到标签页中                           在当前标签页中打开链接（仅限鼠标）</div><div class="line">按住Ctrl键的同时点击链接                     在新的后台标签页中打开链接</div><div class="line">按住Ctrl + Shift键的同时点击链接             打开链接，并跳转到该链接</div><div class="line">将链接拖到标签栏的空白区域                    打开链接，并跳转到该链接（仅使用鼠标）</div><div class="line">按住Shift键的同时点击链接                    在新窗口中打开链接</div><div class="line">将标签页拖出标签栏                           在新窗口中打开标签页（仅使用鼠标）</div><div class="line">将标签页拖到现有窗口中                        将标签页移至当前窗口（仅限鼠标）</div><div class="line">拖动标签页的同时按Esc                        将标签页移回其原始位置</div><div class="line">将相应网址拖动到书签栏中                      将当前网页保存为书签</div><div class="line">按住Alt键的同时点击链接                      下载链接目标</div><div class="line">右键点击“后退”箭头 返回 或“前进”箭头 下一个    显示浏览记录</div><div class="line">双击标签栏的空白区域                         在最大化模式和窗口模式间切换</div><div class="line">按住Ctrl键的同时向上滚动鼠标滚轮              放大网页上的所有内容</div><div class="line">按住Ctrl键的同时向下滚动鼠标滚轮              缩小网页上的所有内容</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;标签和窗口快捷键&quot;&gt;&lt;a href=&quot;#标签和窗口快捷键&quot; class=&quot;headerlink&quot; title=&quot;标签和窗口快捷键&quot;&gt;&lt;/a&gt;标签和窗口快捷键&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Ctrl + n            打开新窗口&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Ctrl + Shift + n    在无痕模式下打开新窗口&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Ctrl + t            打开新的标签页，并跳转到该标签页&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Ctrl + Shift + t    重新打开最后关闭的标签页，并跳转到该标签页&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Ctrl + Tab          跳转到下一个打开的标签页&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Ctrl + PgDn         跳转到下一个打开的标签页&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Ctrl + Shift + Tab  跳转到上一个打开的标签页&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Ctrl + PgUp         跳转到上一个打开的标签页&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Ctrl + n            跳转到特定标签页,n从1到8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Ctrl + 9            跳转到最后一个标签页&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Alt + Home          在当前标签页中打开主页&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Alt + 向左箭头键     打开当前标签页浏览记录中记录的上一个页面&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Alt + 向右箭头键     打开当前标签页浏览记录中记录的下一个页面&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Ctrl + w/F4         关闭当前标签页&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Ctrl + Shift + w    关闭所有打开的标签页和浏览器&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Alt + 空格键 + n     最小化当前窗口&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Alt + 空格键 + x     最大化当前窗口&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Alt + F4            关闭当前窗口&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Ctrl + Shift + q    退出 Google Chrome&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="CHROME" scheme="http://mufool.com/tags/CHROME/"/>
    
  </entry>
  
  <entry>
    <title>极简Python代码</title>
    <link href="http://mufool.com/2019/10/08/python-mini/"/>
    <id>http://mufool.com/2019/10/08/python-mini/</id>
    <published>2019-10-08T09:40:36.000Z</published>
    <updated>2019-10-08T09:43:50.007Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="重复元素判定"><a href="#重复元素判定" class="headerlink" title="重复元素判定"></a>重复元素判定</h2><p>以下方法可以检查给定列表是不是存在重复元素，它会使用 set() 函数来移除所有重复元素</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_unique</span><span class="params">(lst)</span>:</span></div><div class="line">    <span class="keyword">return</span> len(lst) == len(set(lst))</div><div class="line"></div><div class="line"></div><div class="line">x = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">all_unique(x) <span class="comment">## False</span></div><div class="line">all_unique(y) <span class="comment">## True</span></div></pre></td></tr></table></figure><h2 id="字符元素组成判定"><a href="#字符元素组成判定" class="headerlink" title="字符元素组成判定"></a>字符元素组成判定</h2><p>检查两个字符串的组成元素是不是一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">anagram</span><span class="params">(first, second)</span>:</span></div><div class="line">    <span class="keyword">return</span> Counter(first) == Counter(second)</div><div class="line"></div><div class="line">anagram(<span class="string">"abcd3"</span>, <span class="string">"3acdb"</span>) <span class="comment">## True</span></div></pre></td></tr></table></figure><h2 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h2><p>下面的代码块可以检查变量 variable 所占用的内存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">variable = <span class="number">30</span></div><div class="line">print(sys.getsizeof(variable)) <span class="comment">## 24</span></div></pre></td></tr></table></figure><h2 id="字节占用"><a href="#字节占用" class="headerlink" title="字节占用"></a>字节占用</h2><p>下面的代码块可以检查字符串占用的字节数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">byte_size</span><span class="params">(string)</span>:</span></div><div class="line">    <span class="keyword">return</span> len(string.encode(<span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line">byte_size(<span class="string">''</span>) <span class="comment">## 4</span></div><div class="line">byte_size(<span class="string">'Hello World'</span>) <span class="comment">## 11</span></div></pre></td></tr></table></figure><h2 id="打印-N-次字符串"><a href="#打印-N-次字符串" class="headerlink" title="打印 N 次字符串"></a>打印 N 次字符串</h2><p>该代码块不需要循环语句就能打印 N 次字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">n = <span class="number">2</span></div><div class="line">s = <span class="string">"Programming"</span></div><div class="line">print(s * n)</div><div class="line"><span class="comment">## ProgrammingProgramming</span></div></pre></td></tr></table></figure><h2 id="大写第一个字母"><a href="#大写第一个字母" class="headerlink" title="大写第一个字母"></a>大写第一个字母</h2><p>以下代码块会使用 title() 方法，从而大写字符串中每一个单词的首字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = <span class="string">"programming is awesome"</span></div><div class="line">print(s.title())</div><div class="line"><span class="comment">## Programming Is Awesome</span></div></pre></td></tr></table></figure><h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>给定具体的大小，定义一个函数以按照这个大小切割列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">chunk</span><span class="params">(lst, size)</span>:</span></div><div class="line">    <span class="keyword">return</span> list(</div><div class="line">        map(<span class="keyword">lambda</span> x: lst[x * size:x * size + size],</div><div class="line">            list(range(<span class="number">0</span>, ceil(len(lst) / size)))))</div><div class="line"></div><div class="line">chunk([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">2</span>)</div><div class="line"><span class="comment">## [[1,2],[3,4],5]</span></div></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>这个方法可以将布尔型的值去掉，例如（False，None，0，“”），它使用 filter() 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compact</span><span class="params">(lst)</span>:</span></div><div class="line">    <span class="keyword">return</span> list(filter(bool, lst))</div><div class="line"></div><div class="line">compact([<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">False</span>, <span class="number">2</span>, <span class="string">''</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'s'</span>, <span class="number">34</span>])</div><div class="line"><span class="comment">## [ 1, 2, 3, 'a', 's', 34 ]</span></div></pre></td></tr></table></figure><h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><p>如下代码段可以将打包好的成对列表解开成两组不同的元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">array = [[<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="string">'c'</span>, <span class="string">'d'</span>], [<span class="string">'e'</span>, <span class="string">'f'</span>]]</div><div class="line">transposed = zip(*array)</div><div class="line">print(transposed)</div><div class="line"><span class="comment">## [('a', 'c', 'e'), ('b', 'd', 'f')]</span></div></pre></td></tr></table></figure><h2 id="链式对比"><a href="#链式对比" class="headerlink" title="链式对比"></a>链式对比</h2><p>我们可以在一行代码中使用不同的运算符对比多个不同的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">3</span></div><div class="line">print(<span class="number">2</span> &lt; a &lt; <span class="number">8</span>) <span class="comment">## True</span></div><div class="line">print(<span class="number">1</span> == a &lt; <span class="number">2</span>) <span class="comment">## False</span></div></pre></td></tr></table></figure><h2 id="逗号连接"><a href="#逗号连接" class="headerlink" title="逗号连接"></a>逗号连接</h2><p>下面的代码可以将列表连接成单个字符串，且每一个元素间的分隔方式设置为了逗号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hobbies = [<span class="string">"basketball"</span>, <span class="string">"football"</span>, <span class="string">"swimming"</span>]</div><div class="line">print(<span class="string">"My hobbies are: "</span> + <span class="string">", "</span>.join(hobbies))</div><div class="line"><span class="comment">## My hobbies are: basketball, football, swimming</span></div></pre></td></tr></table></figure><h2 id="元音统计"><a href="#元音统计" class="headerlink" title="元音统计"></a>元音统计</h2><p>以下方法将统计字符串中的元音 (‘a’, ‘e’, ‘i’, ‘o’, ‘u’) 的个数，它是通过正则表达式做的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_vowels</span><span class="params">(str)</span>:</span></div><div class="line">    <span class="keyword">return</span> len(len(re.findall(<span class="string">r'[aeiou]'</span>, str, re.IGNORECASE)))</div><div class="line"></div><div class="line">count_vowels(<span class="string">'foobar'</span>) <span class="comment">## 3</span></div><div class="line">count_vowels(<span class="string">'gym'</span>) <span class="comment">## 0</span></div></pre></td></tr></table></figure><h2 id="首字母小写"><a href="#首字母小写" class="headerlink" title="首字母小写"></a>首字母小写</h2><p>如下方法将令给定字符串的第一个字符统一为小写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decapitalize</span><span class="params">(string)</span>:</span></div><div class="line">    <span class="keyword">return</span> str[:<span class="number">1</span>].lower() + str[<span class="number">1</span>:]</div><div class="line"></div><div class="line">decapitalize(<span class="string">'FooBar'</span>) <span class="comment">## 'fooBar'</span></div><div class="line">decapitalize(<span class="string">'FooBar'</span>) <span class="comment">## 'fooBar'</span></div></pre></td></tr></table></figure><h2 id="展开列表"><a href="#展开列表" class="headerlink" title="展开列表"></a>展开列表</h2><p>该方法将通过递归的方式将列表的嵌套展开为单个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">spread</span><span class="params">(arg)</span>:</span></div><div class="line">    ret = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arg:</div><div class="line">        <span class="keyword">if</span> isinstance(i, list):</div><div class="line">            ret.extend(i)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        ret.append(i)</div><div class="line">    <span class="keyword">return</span> ret</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep_flatten</span><span class="params">(lst)</span>:</span></div><div class="line">    result = []</div><div class="line">    result.extend(</div><div class="line">        spread(list(map(<span class="keyword">lambda</span> x: deep_flatten(x) <span class="keyword">if</span> type(x) == list <span class="keyword">else</span> x, lst))))</div><div class="line">    <span class="keyword">return</span> result</div><div class="line"></div><div class="line">deep_flatten([<span class="number">1</span>, [<span class="number">2</span>], [[<span class="number">3</span>], <span class="number">4</span>], <span class="number">5</span>]) <span class="comment">## [1,2,3,4,5]</span></div></pre></td></tr></table></figure><h2 id="列表的差"><a href="#列表的差" class="headerlink" title="列表的差"></a>列表的差</h2><p>该方法将返回第一个列表的元素，其不在第二个列表内。如果同时要反馈第二个列表独有的元素，还需要加一句 <code>set_b.difference(set_a)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">difference</span><span class="params">(a, b)</span>:</span></div><div class="line">    set_a = set(a)</div><div class="line">    set_b = set(b)</div><div class="line">    comparison = set_a.difference(set_b)</div><div class="line">    <span class="keyword">return</span> list(comparison)</div><div class="line"></div><div class="line">difference([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]) <span class="comment">## [3]</span></div></pre></td></tr></table></figure><h2 id="通过函数取差"><a href="#通过函数取差" class="headerlink" title="通过函数取差"></a>通过函数取差</h2><p>如下方法首先会应用一个给定的函数，然后再返回应用函数后结果有差别的列表元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">difference_by</span><span class="params">(a, b, fn)</span>:</span></div><div class="line">    b = set(map(fn, b))</div><div class="line">    <span class="keyword">return</span> [item <span class="keyword">for</span> item <span class="keyword">in</span> a <span class="keyword">if</span> fn(item) <span class="keyword">not</span> <span class="keyword">in</span> b]</div><div class="line"></div><div class="line">difference_by([<span class="number">2.1</span>, <span class="number">1.2</span>], [<span class="number">2.3</span>, <span class="number">3.4</span>], floor) <span class="comment">## [1.2]</span></div><div class="line">difference_by([&#123;<span class="string">'x'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;], [&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;], <span class="keyword">lambda</span> v: v[<span class="string">'x'</span>])</div><div class="line"><span class="comment">## [ &#123; x: 2 &#125; ]</span></div></pre></td></tr></table></figure><h2 id="链式函数调用"><a href="#链式函数调用" class="headerlink" title="链式函数调用"></a>链式函数调用</h2><p>你可以在一行代码内调用多个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtract</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="keyword">return</span> a - b</div><div class="line"></div><div class="line">a, b = <span class="number">4</span>, <span class="number">5</span></div><div class="line">print((subtract <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> add)(a, b)) <span class="comment">## 9</span></div></pre></td></tr></table></figure><h2 id="检查重复项"><a href="#检查重复项" class="headerlink" title="检查重复项"></a>检查重复项</h2><p>如下代码将检查两个列表是不是有重复项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_duplicates</span><span class="params">(lst)</span>:</span></div><div class="line">    <span class="keyword">return</span> len(lst) != len(set(lst))</div><div class="line"></div><div class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>]</div><div class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">has_duplicates(x) <span class="comment">## True</span></div><div class="line">has_duplicates(y) <span class="comment">## False</span></div></pre></td></tr></table></figure><h2 id="合并两个字典"><a href="#合并两个字典" class="headerlink" title="合并两个字典"></a>合并两个字典</h2><p>下面的方法将用于合并两个字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_two_dicts</span><span class="params">(a, b)</span>:</span></div><div class="line">    c = a.copy() <span class="comment">## make a copy of a</span></div><div class="line">    c.update(b) <span class="comment">## modify keys and values of a with the ones from b</span></div><div class="line">    <span class="keyword">return</span> c</div><div class="line"></div><div class="line">a = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;</div><div class="line">b = &#123;<span class="string">'y'</span>: <span class="number">3</span>, <span class="string">'z'</span>: <span class="number">4</span>&#125;</div><div class="line">print(merge_two_dicts(a, b))</div><div class="line"><span class="comment">## &#123;'y': 3, 'x': 1, 'z': 4&#125;</span></div></pre></td></tr></table></figure><p>在 Python 3.5 或更高版本中，我们也可以用以下方式合并字典<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_dictionaries</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="keyword">return</span> &#123;**a, **b&#125;</div><div class="line"></div><div class="line">a = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;</div><div class="line">b = &#123;<span class="string">'y'</span>: <span class="number">3</span>, <span class="string">'z'</span>: <span class="number">4</span>&#125;</div><div class="line">print(merge_dictionaries(a, b))</div><div class="line"><span class="comment">## &#123;'y': 3, 'x': 1, 'z': 4&#125;</span></div></pre></td></tr></table></figure></p><h2 id="将两个列表转化为字典"><a href="#将两个列表转化为字典" class="headerlink" title="将两个列表转化为字典"></a>将两个列表转化为字典</h2><p>如下方法将会把两个列表转化为单个字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_dictionary</span><span class="params">(keys, values)</span>:</span></div><div class="line">    <span class="keyword">return</span> dict(zip(keys, values))</div><div class="line"></div><div class="line">keys = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</div><div class="line">values = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line">print(to_dictionary(keys, values))</div><div class="line"><span class="comment">## &#123;'a': 2, 'c': 4, 'b': 3&#125;</span></div></pre></td></tr></table></figure><h2 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h2><p>我们常用 For 循环来遍历某个列表，同样我们也能枚举列表的索引与值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">list = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</div><div class="line"><span class="keyword">for</span> index, element <span class="keyword">in</span> enumerate(list):</div><div class="line">    print(<span class="string">"Value"</span>, element, <span class="string">"Index "</span>, index, )</div><div class="line"><span class="comment">## ('Value', 'a', 'Index ', 0)</span></div><div class="line"><span class="comment">## ('Value', 'b', 'Index ', 1)</span></div><div class="line"><span class="comment">## ('Value', 'c', 'Index ', 2)</span></div><div class="line"><span class="comment">## ('Value', 'd', 'Index ', 3)</span></div></pre></td></tr></table></figure><h2 id="执行时间"><a href="#执行时间" class="headerlink" title="执行时间"></a>执行时间</h2><p>如下代码块可以用来计算执行特定代码所花费的时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">start_time = time.time()</div><div class="line">a = <span class="number">1</span></div><div class="line">b = <span class="number">2</span></div><div class="line">c = a + b</div><div class="line">print(c) <span class="comment">## 3</span></div><div class="line">end_time = time.time()</div><div class="line">total_time = end_time - start_time</div><div class="line">print(<span class="string">"Time: "</span>, total_time)</div><div class="line"><span class="comment">## ('Time: ', 1.1205673217773438e-05)</span></div></pre></td></tr></table></figure><h2 id="Try-else"><a href="#Try-else" class="headerlink" title="Try else"></a>Try else</h2><p>我们在使用 try/except 语句的时候也可以加一个 else 子句，如果没有触发错误的话，这个子句就会被运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="number">2</span> * <span class="number">3</span></div><div class="line"><span class="keyword">except</span> TypeError:</div><div class="line">    print(<span class="string">"An exception was raised"</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">"Thank God, no exceptions were raised."</span>)</div><div class="line"></div><div class="line"><span class="comment">## Thank God, no exceptions were raised.</span></div></pre></td></tr></table></figure><h2 id="元素频率"><a href="#元素频率" class="headerlink" title="元素频率"></a>元素频率</h2><p>下面的方法会根据元素频率取列表中最常见的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">most_frequent</span><span class="params">(list)</span>:</span></div><div class="line">    <span class="keyword">return</span> max(set(list), key=list.count)</div><div class="line"></div><div class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</div><div class="line">most_frequent(list)</div></pre></td></tr></table></figure><h2 id="回文序列"><a href="#回文序列" class="headerlink" title="回文序列"></a>回文序列</h2><p>以下方法会检查给定的字符串是不是回文序列，它首先会把所有字母转化为小写，并移除非英文字母符号。最后，它会对比字符串与反向字符串是否相等，相等则表示为回文序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindrome</span><span class="params">(string)</span>:</span></div><div class="line">    <span class="keyword">from</span> re <span class="keyword">import</span> sub</div><div class="line">    s = sub(<span class="string">'[\W_]'</span>, <span class="string">''</span>, string.lower())</div><div class="line">    <span class="keyword">return</span> s == s[::<span class="number">-1</span>]</div><div class="line"></div><div class="line">palindrome(<span class="string">'taco cat'</span>) <span class="comment">## True</span></div></pre></td></tr></table></figure><h2 id="不使用-if-else-的计算子"><a href="#不使用-if-else-的计算子" class="headerlink" title="不使用 if-else 的计算子"></a>不使用 if-else 的计算子</h2><p>这一段代码可以不使用条件语句就实现加减乘除、求幂操作，它通过字典这一数据结构实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> operator</div><div class="line"></div><div class="line">action = &#123;</div><div class="line">    <span class="string">"+"</span>: operator.add,</div><div class="line">    <span class="string">"-"</span>: operator.sub,</div><div class="line">    <span class="string">"/"</span>: operator.truediv,</div><div class="line">    <span class="string">"*"</span>: operator.mul,</div><div class="line">    <span class="string">"**"</span>: pow</div><div class="line">&#125;</div><div class="line">print(action[<span class="string">'-'</span>](<span class="number">50</span>, <span class="number">25</span>)) <span class="comment">## 25</span></div></pre></td></tr></table></figure><h2 id="Shuffle"><a href="#Shuffle" class="headerlink" title="Shuffle"></a>Shuffle</h2><p>该算法会打乱列表元素的顺序，它主要会通过 Fisher-Yates 算法对新列表进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</div><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(lst)</span>:</span></div><div class="line">    temp_lst = deepcopy(lst)</div><div class="line">    m = len(temp_lst)</div><div class="line">    <span class="keyword">while</span> (m):</div><div class="line">        m -= <span class="number">1</span></div><div class="line">    i = randint(<span class="number">0</span>, m)</div><div class="line">    temp_lst[m], temp_lst[i] = temp_lst[i], temp_lst[m]</div><div class="line">    <span class="keyword">return</span> temp_lst</div><div class="line"></div><div class="line">foo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">shuffle(foo) <span class="comment">## [2,3,1] , foo = [1,2,3]</span></div></pre></td></tr></table></figure><h2 id="展开列表-1"><a href="#展开列表-1" class="headerlink" title="展开列表"></a>展开列表</h2><p>将列表内的所有元素，包括子列表，都展开成一个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">spread</span><span class="params">(arg)</span>:</span></div><div class="line">    ret = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arg:</div><div class="line">        <span class="keyword">if</span> isinstance(i, list):</div><div class="line">            ret.extend(i)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        ret.append(i)</div><div class="line">    <span class="keyword">return</span> ret</div><div class="line"></div><div class="line">spread([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>]) <span class="comment">## [1,2,3,4,5,6,7,8,9]</span></div></pre></td></tr></table></figure><h2 id="交换值"><a href="#交换值" class="headerlink" title="交换值"></a>交换值</h2><p>不需要额外的操作就能交换两个变量的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="keyword">return</span> b, a</div><div class="line"></div><div class="line">a, b = <span class="number">-1</span>, <span class="number">14</span></div><div class="line">swap(a, b) <span class="comment">## (14, -1)</span></div><div class="line">spread([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>]) <span class="comment">## [1,2,3,4,5,6,7,8,9]</span></div></pre></td></tr></table></figure><h2 id="字典默认值"><a href="#字典默认值" class="headerlink" title="字典默认值"></a>字典默认值</h2><p>通过 Key 取对应的 Value 值，可以通过以下方式设置默认值。如果 get() 方法没有设置默认值，那么如果遇到不存在的 Key，则会返回 None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</div><div class="line">print(d.get(<span class="string">'c'</span>, <span class="number">3</span>)) <span class="comment">## 3</span></div></pre></td></tr></table></figure><p>参考：<br><a href="https://towardsdatascience.com/30-helpful-python-snippets-that-you-can-learn-in-30-seconds-or-less-69bb49204172" target="_blank" rel="external">towardsdatascience</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;重复元素判定&quot;&gt;&lt;a href=&quot;#重复元素判定&quot; class=&quot;headerlink&quot; title=&quot;重复元素判定&quot;&gt;&lt;/a&gt;重复元素判定&lt;/h2&gt;&lt;p&gt;以下方法可以检查给定列表是不是存在重复元素，它会使用 set() 函数来移除所有重复元素&lt;/p&gt;
    
    </summary>
    
    
      <category term="PYTHON" scheme="http://mufool.com/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>Vimium使用</title>
    <link href="http://mufool.com/2019/09/29/chrome-plugin-vimium/"/>
    <id>http://mufool.com/2019/09/29/chrome-plugin-vimium/</id>
    <published>2019-09-29T07:46:26.000Z</published>
    <updated>2019-10-08T09:43:24.632Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Vimium 这个名字其实是 Vim 和 Chromium 的合体。很多人可能不知道 Vim，这么说吧，你是不是经常在电影里看到那些顶尖的黑客，他们在屏幕上来去自如，最关键的是，他们竟然都不用鼠标？没错，狭义地说，Vim 其实是 Linux 等平台上的一款文本编辑器，它可以让你彻底脱离鼠标，通过一系列快捷键，来操作任何一件事情。</p><a id="more"></a><p>Vimium是一款谷歌浏览器扩展程序，它继承了 Vim 中的常用操作，让我们在使用 Chrome 的过程中，无论是浏览网页、切换标签或是其它任何操作，全都可以只通过键盘完成。想像一下，你再也不需要移动鼠标去打开一个链接，手指不用离开键盘，一切都是这么流畅。</p><p>Vimium 插件可以帮我们做到：</p><ul><li>帮助您在不触摸鼠标的情况下浏览网页</li><li>使用巧妙的突出显示方法来使用链接进行导航</li><li>可自定义的键盘快捷键</li><li>有一个页面内的帮助对话框来提醒您个性化的快捷键</li></ul><p>github地址：<a href="https://github.com/philc/vimium" target="_blank" rel="external">https://github.com/philc/vimium</a><br>项目官网：<a href="http://vimium.github.io/" target="_blank" rel="external">http://vimium.github.io/</a></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h3 id="跳转任意链接"><a href="#跳转任意链接" class="headerlink" title="跳转任意链接"></a>跳转任意链接</h3><p>只用敲三下，打开当前页面上任意一个链接，任意一个页面上，哪所有再多链接，你也不用鼠标，最多只需要敲三个键，你就可以迅速打开任意一个链接。</p><p>你只需要按一下「f」，然后当前页面会显示所有可点击的元素，vimium 会生成一个对应的快捷键给这些链接。再输入对应的字符就可以打开。</p><h3 id="打开新页面"><a href="#打开新页面" class="headerlink" title="打开新页面"></a>打开新页面</h3><ul><li><p>复制一段链接：经常在网页上看到一段链接文字，但却是不可点的。原来你需要先复制，然后新建标签页，再粘贴，敲回车后才能打开。现在呢？你只需要把要打开的链接复制一下，直接按「p」或「P」就可以打开了，小写的 p 是在当前标签页打开，大写的 P 则新建标签页打开。</p></li><li><p>从收藏夹、历史记录打开：是不是之前看过什么网页，现在又想看了，还需要再打开历史记录找？或者想打开收藏夹里的某个链接？现在，直接按下「o」，输入对应的关键字后，会一起搜索你的历史记录和收藏夹，如果你输的是一个网址，回车还能直接打开。</p></li></ul><h3 id="标签页快速切换"><a href="#标签页快速切换" class="headerlink" title="标签页快速切换"></a>标签页快速切换</h3><ul><li>有时候在查找信息、翻阅资料时，经常会一口气打开几十个网站，东西一多，Chrome 会自动将每个标签页的宽度缩小，几乎就看不到它们的标题了。用了 Vimium，你可以按一下大写的「T」，就可以显示当前打开的所有标签页，并支持快捷搜索和跳转。</li></ul><h3 id="自定义搜索引擎"><a href="#自定义搜索引擎" class="headerlink" title="自定义搜索引擎"></a>自定义搜索引擎</h3><p>配置自定义搜索引擎，通过快捷键 o/O 调起搜索框，输入搜索引擎简写，再输入空格，再输入搜索词回车，则会调用对应的搜索引擎进行搜索。</p><p>常用的搜索引擎配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">w: https://www.wikipedia.org/w/index.php?title=Special:Search&amp;search=%s Wikipedia</div><div class="line"></div><div class="line"># More examples.</div><div class="line">#</div><div class="line"># (Vimium supports search completion Wikipedia, as</div><div class="line"># above, and for these.)</div><div class="line">#</div><div class="line">g: https://www.google.com/search?q=%s Google</div><div class="line">G: https://www.google.com/search?q=%s Google</div><div class="line">zh: https://www.zhihu.com/search?type=content&amp;q=%s 知乎</div><div class="line">ZH: https://www.zhihu.com/search?type=content&amp;q=%s 知乎</div><div class="line">tb https://s.taobao.com/search?q=%s 淘宝</div><div class="line">TB https://s.taobao.com/search?q=%s 淘宝</div><div class="line">jd https://search.jd.com/Search?keyword=%s 京东</div><div class="line">JD https://search.jd.com/Search?keyword=%s 京东</div><div class="line">bd: https://www.baidu.com/s?wd=%s 百度</div><div class="line">BD: https://www.baidu.com/s?wd=%s 百度</div><div class="line">bz https://search.bilibili.com/all?keyword=%s b站</div><div class="line">BZ https://search.bilibili.com/all?keyword=%s b站</div><div class="line">az: https://www.amazon.com/s/?field-keywords=%s Amazon</div><div class="line">AZ: https://www.amazon.com/s/?field-keywords=%s Amazon</div><div class="line">aqy https://so.iqiyi.com/so/q_%s 爱奇艺</div><div class="line">AQY https://so.iqiyi.com/so/q_%s 爱奇艺</div><div class="line">tm https://list.tmall.com/search_product.htm?q=%s 天猫</div><div class="line">TM https://list.tmall.com/search_product.htm?q=%s 天猫</div><div class="line">yk https://so.youku.com/search_video/q_%s 优酷</div><div class="line">YK https://so.youku.com/search_video/q_%s 优酷</div><div class="line">db https://www.douban.com/search?q=%s 豆瓣</div><div class="line">DB https://www.douban.com/search?q=%s 豆瓣</div><div class="line">y: https://www.youtube.com/results?search_query=%s Youtube</div><div class="line">Y: https://www.youtube.com/results?search_query=%s Youtube</div><div class="line"># l: https://www.google.com/search?q=%s&amp;btnI I&apos;m feeling lucky...</div><div class="line"># gm: https://www.google.com/maps?q=%s Google maps</div><div class="line"># b: https://www.bing.com/search?q=%s Bing</div><div class="line"># d: https://duckduckgo.com/?q=%s DuckDuckGo</div><div class="line"># qw: https://www.qwant.com/?q=%s Qwant</div></pre></td></tr></table></figure></p><p>在插件的options中加入快捷配置即可。</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="当前页面操作"><a href="#当前页面操作" class="headerlink" title="当前页面操作"></a>当前页面操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">?       显示help，查询vimium的所有使用方法</div><div class="line">h       向左滚动</div><div class="line">j       向下滚动</div><div class="line">k       向上滚动</div><div class="line">l       向右滚动</div><div class="line">gg      滚动到顶部</div><div class="line">G       滚动到底部</div><div class="line">d       向下滚动半页</div><div class="line">u       向上滚动半页面</div><div class="line">f       显示链接字母，在当前页面打开</div><div class="line">F       显示链接字母，在新的页面打开</div><div class="line">r       刷新</div><div class="line">gs      显示网页源代码</div><div class="line">i       进入插入模式，所有按键的命令都无效，直至ESC键退出</div><div class="line">yy      将当前的网址复制到剪贴板</div><div class="line">yf      显示链接字母，并将网址拷贝到剪贴板</div><div class="line">gf      循环到下一帧(尤其在选择网页内置视频的时候很管用)</div><div class="line">gF      聚焦主/顶框架</div></pre></td></tr></table></figure><h3 id="新页面操作"><a href="#新页面操作" class="headerlink" title="新页面操作"></a>新页面操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">o       搜索网址，书签，或历史记录，在当前页面打开</div><div class="line">O       搜索网址，书签，或历史记录，在新的页面打开</div><div class="line">b       搜索书签，在当前页面打开</div><div class="line">B       搜索书签，在新的页面打开</div><div class="line">T       搜索当前浏览器的所有标签</div></pre></td></tr></table></figure><h3 id="使用搜索"><a href="#使用搜索" class="headerlink" title="使用搜索"></a>使用搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/       进入查找模式，输入关键字查找，ESC退出</div><div class="line">n       切换到下一个匹配</div><div class="line">N       切换到上一个匹配</div></pre></td></tr></table></figure><h3 id="浏览历史记录"><a href="#浏览历史记录" class="headerlink" title="浏览历史记录"></a>浏览历史记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">H       回到历史，也就是回到前一页</div><div class="line">L       在历史上前进，也就是回到后一页</div></pre></td></tr></table></figure><h3 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">J, gT   切换到左边tab</div><div class="line">K, gt   切换到右边tab</div><div class="line">g0      切换到第一个tab</div><div class="line">g$      切换到最后一个tab</div><div class="line">^       切换到刚才的tab</div><div class="line">t       创建一个新的页面</div><div class="line">yt      复制当前页面</div><div class="line">x       关闭当前页面</div><div class="line">X       恢复刚才关闭的页面</div><div class="line">p       在当前标签页打开剪切板中的URL，如不是URL则默认引擎搜索</div><div class="line">P       在新标签页打开剪切板中的URL，如不是URL则默认引擎搜索</div><div class="line">W       将当前标签移动到新窗口</div><div class="line">&lt;a-p&gt;   pin/unpin current tab</div></pre></td></tr></table></figure><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ma      当页标记，只能在当前tab页面跳转，m + 一个小写字母</div><div class="line">mA      全局标记，可以再切换到其他tab的跳转过来，m + 一个大写字母</div><div class="line">`a      跳转到当页标记</div><div class="line">`A      跳转到全局标记</div><div class="line">``      跳回之前的位置(也就是说，在执行gg，G，n，N，或/ a 之前的位置）</div></pre></td></tr></table></figure><h3 id="进阶控制命令"><a href="#进阶控制命令" class="headerlink" title="进阶控制命令"></a>进阶控制命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;&lt;      当前标签页向左移动</div><div class="line">&gt;&gt;      当前标签页向右移动</div><div class="line">&lt;a-f&gt;   在新标签中打开多个链接</div><div class="line">gi      聚焦页面上的第一个（或第n个）文本输入框</div><div class="line">gu      跳转到URL层次的父类(xxx.com/yyy/zzz 跳转到 xxx.com/yyy)</div><div class="line">gU      转到URL层次结构的根目录(也就是 xxx.com)</div><div class="line">ge      编辑当前的网址，在当前页面打开</div><div class="line">gE      编辑当前网址，在新的页面打开</div><div class="line">zH      滚动到最左边</div><div class="line">zL      滚动到最右边</div><div class="line">v       进入预览模式;使用p / P粘贴，然后使用y来拷贝</div><div class="line">V       enter visual line mode</div><div class="line">&lt;a-m&gt;   开/关静音</div><div class="line">&lt;a-p&gt;   固定标签栏</div></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5t      数字num + t，打开num个tab页面</div><div class="line">&lt;Esc&gt;   ESC按钮，可以从任意控制命令中退出，也可以从任意模式中退出（例如插入模式、查找模式）</div></pre></td></tr></table></figure><h3 id="预览模式（visual-mode）"><a href="#预览模式（visual-mode）" class="headerlink" title="预览模式（visual mode）"></a>预览模式（visual mode）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">先用 / 定位，找到想要选择的字符</div><div class="line">    再按 v ,进入模式</div><div class="line">    然后使用</div><div class="line">        j：向下一行</div><div class="line">        k：向上一行</div><div class="line">        h：向左一个字符或标点（数字+h，可以移动多个字符）</div><div class="line">        l：向右一个字符或标点（数字+l，可以移动多个字符）</div><div class="line">        w：下一个标点符号后位置，包括看不见的换行符</div><div class="line">        e：下一个标点符号前位置</div><div class="line">        b：取消选中上一个字符，字符和标点算一个字符</div></pre></td></tr></table></figure><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/64533566" target="_blank" rel="external">vimium 成神之路-键盘党的胜利</a><br><a href="https://v.youku.com/v_show/id_XMjM0MTE3MDcy.html" target="_blank" rel="external">vimium 官方视频</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Vimium 这个名字其实是 Vim 和 Chromium 的合体。很多人可能不知道 Vim，这么说吧，你是不是经常在电影里看到那些顶尖的黑客，他们在屏幕上来去自如，最关键的是，他们竟然都不用鼠标？没错，狭义地说，Vim 其实是 Linux 等平台上的一款文本编辑器，它可以让你彻底脱离鼠标，通过一系列快捷键，来操作任何一件事情。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PLUGIN" scheme="http://mufool.com/tags/PLUGIN/"/>
    
      <category term="VIM" scheme="http://mufool.com/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>HTTP/2.0入门</title>
    <link href="http://mufool.com/2017/11/30/http2-0/"/>
    <id>http://mufool.com/2017/11/30/http2-0/</id>
    <published>2017-11-30T09:56:33.000Z</published>
    <updated>2019-03-20T03:09:23.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议（HyperTextTransferProtocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。</p><a id="more"></a><h2 id="HTTP发展史"><a href="#HTTP发展史" class="headerlink" title="HTTP发展史"></a>HTTP发展史</h2><p><img src="http://pic-blog.bfvyun.com/http2.0/http21.jpg" alt="imag"></p><h2 id="HTTP-2-0主要特点"><a href="#HTTP-2-0主要特点" class="headerlink" title="HTTP/2.0主要特点"></a>HTTP/2.0主要特点</h2><p>这是 Akamai 公司建立的一个官方的演示<a href="https://http2.akamai.com/demo" target="_blank" rel="external">HTTP/2 is the future of the Web, and it is here!</a>，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。</p><p><img src="http://pic-blog.bfvyun.com/http2.0/http22.jpg" alt="imag"></p><p>HTTP/2 源自 SPDY/2，SPDY 系列协议由谷歌开发，于 2009 年公开。它的设计目标是降低 50% 的页面加载时间。当下很多著名的互联网公司都在自己的网站或 APP 中采用了 SPDY 系列协议（当前最新版本是SPDY/3.1），因为它对性能的提升是显而易见的。主流的浏览器（谷歌、火狐、Opera）也都早已经支持 SPDY，它已经成为了工业标准，HTTP Working-Group 最终决定以 SPDY/2 为基础，开发 HTTP/2。HTTP/2标准于2015年5月以RFC 7540正式发表。<br>但是，HTTP/2 跟 SPDY 仍有不同的地方，主要是以下两点：</p><ul><li>HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP/2 消息头的压缩算法采用 HPACK ，而非 SPDY 采用的 DEFLATE</li></ul><p>HTTP2.0 的出现，相比于 HTTP1.x ，大幅度的提升了 web 性能。其中主要特点如下。</p><h3 id="多路复用（Multiplexing）"><a href="#多路复用（Multiplexing）" class="headerlink" title="多路复用（Multiplexing）"></a>多路复用（Multiplexing）</h3><p><img src="http://pic-blog.bfvyun.com/http2.0/http23.jpg" alt="imag"></p><p>对于 HTTP1.1，浏览器通常最多有链接的限制，即使开启多个链接，每个连接都需要消耗服务器资源，同时HTTP是基于TCP的，每个连接需要有慢启动的过程，无法充分利用带宽资源。<br>HTTP2.0的多路复用允许单一的 HTTP/2 连接同时发起多重的请求-响应消息。让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。<br>HTTP2.0具体是如何实现单连接中发送多个请求呢？<br>HTTP基于TCP，TCP是双向流传输，一个是从client到server，一个是从server到客户端。单个流中传输的数据是有序的，主要发送有序，接受就可以接受到。比如：发送 hello http两个单词，接受端收到的也分别是hello和http。如果是将hello http混着这发出去，hehllottp，则服务器就没法讲两个单词分开。要实现这个效果，HTTP2.0中引入了二进制分帧这个新概念。</p><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p><img src="http://pic-blog.bfvyun.com/http2.0/http24.jpg" alt="imag"><br>在应用层与传输层之间增加一个二进制分帧层，以此达到“在不改动 HTTP 的语义，HTTP 方法、状态码、URI 及首部字段的情况下，突破 HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。”</p><p>HTTP/2 的三个概念：</p><ul><li>数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。</li><li>消息：与逻辑请求或响应消息对应的完整的一系列帧。</li><li>帧：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li></ul><p>在二进制分帧层上，HTTP2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，其中 HTTP1.x 的首部信息会被封装到 Headers 帧，而我们的 request body 则封装到 Data 帧里面。</p><p><img src="http://pic-blog.bfvyun.com/http2.0/http25.jpg" alt="imag"></p><p>总结关系如下：</p><ul><li>所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。</li><li>每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。</li><li>每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。</li><li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载，等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><p>HTTP消息分解为很多独立的帧之后，客户端和服务器交错发送和传输这些帧的顺序就成为关键的性能决定因素。有没有可能当我们需要一些关键的JS或者CSS的时候，服务器却还在接受不太重要的一些图片信息等。<br>HTTP2.0为每个数据流设置了一个优先级，每个数据流分配一个介于 1 至 256 之间的整数作为优先级，同时数据流之间可以存在显示的依赖关系。<br>客户端可以构建和传递“优先级树”，表明它倾向于如何接收响应。反过来，服务器可以使用此信息通过控制 CPU、内存和其他资源的分配设定数据流处理的优先级，在资源数据可用之后，带宽分配可以确保将高优先级响应以最优方式传输至客户端。</p><h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p>HTTP/1 中，HTTP 请求和响应都是由「状态行、请求 / 响应头部、消息主体」三部分组成。一般而言，消息主体都会经过 gzip 压缩，或者本身传输的就是压缩过后的二进制文件（例如图片、音频），但状态行和头部却没有经过任何压缩，直接以纯文本传输。<br>页面产生的请求数越多，消耗在头部的流量越多，尤其是每次都要传输 UserAgent、Cookie 这类不会频繁变动的内容，完全是一种浪费。</p><p><img src="http://pic-blog.bfvyun.com/http2.0/http26.jpg" alt="imag"></p><p>HTTP2.0 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；通信期间几乎不会改变的通用键-值对（用户代理、可接受的媒体类型，等等）只需发送一次。</p><p>首部发生变化了，那么只需要发送变化了数据在 Headers 帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在 HTTP2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p><img src="http://pic-blog.bfvyun.com/http2.0/http27.jpg" alt="imag"><br>HTTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。<br>一个服务器经常知道一个页面需要很多附加资源，在它响应浏览器第一个请求的时候，可以开始推送这些资源。这允许服务端去完全充分地利用一个可能空闲的网络，改善页面加载时间。<br>当然这同时也是它的一个缺点，如果客户端已经缓存了数据，此时会产生不必要的冗余。这也是为什么推荐服务器提示（Server Hints）的原因。</p><p>参考：<br><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="external">HTTP/2 简介</a><br><a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin?hl=zh-CN" target="_blank" rel="external">检查网站是否支持 SPDY 或者 HTTP/2 的 Chrome 扩展</a><br><a href="https://iyaozhen.com/nginx-http2-conf.html" target="_blank" rel="external">配置Nginx，开启HTTP/2</a><br><a href="https://github.com/fex-team/http2-spec/blob/master/HTTP2%E4%B8%AD%E8%8B%B1%E5%AF%B9%E7%85%A7%E7%89%88(06-29" target="_blank" rel="external">HTTP2中英对照版</a>.md)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP协议&quot;&gt;&lt;a href=&quot;#HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议&quot;&gt;&lt;/a&gt;HTTP协议&lt;/h2&gt;&lt;p&gt;HTTP协议（HyperTextTransferProtocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="http://mufool.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>RTMP协议</title>
    <link href="http://mufool.com/2017/11/30/rtmp/"/>
    <id>http://mufool.com/2017/11/30/rtmp/</id>
    <published>2017-11-30T09:33:22.000Z</published>
    <updated>2019-03-20T03:04:03.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>实时消息传输协议(RTMP)最初是由 Macromedia 为互联网上 Flash player 和服务器之间传输音频、视频以及数据流而开发的一个私有协议。RTMP协议是一个互联网TCP/IP五层体系结构中应用层的协议。RTMP协议中基本的数据单元称为消息（Message）。当RTMP协议在互联网中传输数据的时候，消息会被拆分成更小的单元，称为消息块（Chunk）。（本文内容多来自文档翻译）</p><a id="more"></a><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li>AMF(Action Message Format)是在flash和flex中与远程服务端交换数据的一种格式。它是二进制格式，Flash应用与服务端或数据库通过RPC交换数据时，通常都采用这种格式。AMF 1 诞生于Flash Player6，发展到现在已经变成了了AMF3。</li><li>RTMP(Real-Time Messaging Protocol实时消息传送协议)的缩写，它是Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输开发的协议。这是一个标准的，未加密的实时消息传递协议，默认端口是1935，如果未指定连接端口，那么flash客户端会尝试连接其他端口，其尝试连接顺序按照下列顺序依次连接：1935、443、80(RTMP), 80(RTMPT)。</li><li>RTMPT，RTMP的变种，此协建立在HTTP协议之上，是通过HTTP封装后的RTMP协议，默认端口80。</li><li>RTMPS，RTMP的另一个变种，此协议是通过SSL(Secure Sockets Layer 安全套接层)加密的RTMP协议，为数据通讯提供安全支持。SSL在传输层对网络连接进行加密，默认端口443。</li><li>RTMPE，RTMP的变种，RTMPE是一个加密版本的RTMP，和RTMPS不同的是RTMPE不采用SSL加密，RTMPE加密快于SSL,并且不需要认证管理。如果没有指定RTMPE端口，Flash播放器将像RTMP协议一样依次扫描下列端口，1935(RTMPE)，443(RTMPE) ，80(RTMPE)，80(RTMPTE)。</li><li>RTMPTE，RTMPTE 这个协议是一个通过加密通道连接的RTMPE，默认端口80。</li><li>RTMFP，RTMFP是Adobe公司开发的一套新的通信协议，该协议可以让使用Adobe Flash Player的终端用户之间进行直接通信。</li></ul><h2 id="RTMP协议格式"><a href="#RTMP协议格式" class="headerlink" title="RTMP协议格式"></a>RTMP协议格式</h2><h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3><p>1、 基本命令<br>C0 和S0：分别是1 个byte 的数据块，它主要是为了指明RTMP 的版本。对于Client 来说代表了客户端请求使用的版本，而对Server 来说，表明了服务端选择使用的版本。现在所使用的版本号都是0x03,0-2是早期产品所用的，已被丢弃；4-31保留在未来使用 ；32-255不允许使用。如果Client 请求了一个非法的版本号，那么Server 应该返回版本号0x03。Client 要么同意Server 的选择，要么放弃握手。<br><img src="http://pic-blog.bfvyun.com/rtmp/c0s0.jpg" alt="image"></p><p>C1 和S1 ：分别是一个1536 bytes 长的数据块。这个数据块的前4 个bytes 指明了这个数据块创建的当前时间戳，也可以是0。后面4 个bytes 通常是0，也可以是版本号，对于Client来说是FP 的版本号，对于Server 来说是FMS 的版本号。随后的1528 个bytes 的值是任意填写的。<br><img src="http://pic-blog.bfvyun.com/rtmp/c1s1.jpg" alt="image"></p><p>C2 和S2 ：也分别是一个1536 bytes 长的数据块。所不同的是，对于C2 来说，time 和time2的值必须是从S1 中读取的；反过来对S2 也一样，是从C1 中读取的。另一方面剩下的1528个bytes 也不再是随机值了，对于C2 来说这些bytes 必须来自S1，反过来对S2 也一样，这些bytes 必须来自C1。总结下来就是说，C2 要把之前S1 的1536 bytes 内容完完整整的发回给Server，S2 也做类似的动作，把之前收到的C1 的内容完整的发回给Client。<br><img src="http://pic-blog.bfvyun.com/rtmp/c2s2.jpg" alt="image"></p><p>2、握手流程</p><ul><li>首先由Client 发送C0、C1 给Server，并且等待S1 的到来。</li><li>当Server 收到C0 之后，发送S0 和S1 给Client，在收到C1 之后，发送S2 给Client，并等待C2 的到来。</li><li>当Client 收到S1 之后，发送C2 给Server，在收到S2 之后，就可以发送后续的数据了。</li><li>当Server 收到C2 之后，就可以发送后续的数据了。</li></ul><p>3、握手优化<br>由于C0、S0 只有1 个bytes，出于优化考虑，通常C0 和C1 是一起发送的，也就是握手开始发送1537 个bytes。由于Server 收到C1 就可以发送S2 了，所以通常Server 会一次性返回S0、S1 和S2 给Client。由于Client 发送完C2 之后就可以发送后续数据包了，因此通通常C2 之后有可能会跟随其他的数据块。</p><h3 id="消息流（message-stream）"><a href="#消息流（message-stream）" class="headerlink" title="消息流（message stream）"></a>消息流（message stream）</h3><p>message stream是逻辑意义上的流，包含command stream和media stream两种。command stream表示命令数据流，media stream表示媒体流。Command stream是指专门用来在Client 和Server 间传递命令控制消息的数据流。media stream是指包括音频、视频和元数据(metadata)在内的媒体流。</p><h3 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h3><p>RTMP协议中消息在网络上传输时被拆分成消息块（chunk）。Message Stream 只是逻辑上的概念，因此每个Chunk 也都会包含一个Msg Stream ID。Chunk 的大小是人为指定的，客户端可以与服务器采用不同的chunk 大小。在没有指定之前，chunk 大小采用默认值128 字节。<br>每个Chunk 都会分配一个Chunk Stream ID。</p><p>1、Chunk格式<br><img src="http://pic-blog.bfvyun.com/rtmp/chunk.jpg" alt="image"></p><p>2、Chunk Basic Header<br>Basic Header 包含fmt 和cs id 两个字段，fmt 表示协议头格式（Chunk Message HeaderFormat），cs id 表示流id（Chunk Stream ID）。Basic Header 长度为1-3 个字节，由cs id 字段来决定。<br>Fmt，决定了Chunk Message Header 的格式，取值为0-3，共四种格式。<br>Cs id，取值范围是0 – 65599，0-2 为保留值。0 表示basic header 长度为2 个字节，1 表示长度为3 个字节，2 表示该chunk 为控制消息（同时Message Stream ID必须是0）。</p><ul><li><p>当Basic Header 长度为1 时，cs id 取值2-63。<br><img src="http://pic-blog.bfvyun.com/rtmp/bh1.jpg" alt="image"></p></li><li><p>当Basic Header 长度为2时，cs id = 64 + the second byte。<br><img src="http://pic-blog.bfvyun.com/rtmp/bh2.jpg" alt="image"></p></li><li><p>当Basic Header 长度为3 时，cs id = 64 + the second byte + the third byte × 256。<br><img src="http://pic-blog.bfvyun.com/rtmp/bh3.jpg" alt="image"></p></li></ul><p>解析csid示例代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> nChannel = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)*m_recvBuf &amp; <span class="number">0x3f</span>);</div><div class="line"><span class="keyword">if</span>(nChannel == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    nChannel = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)m_recvBuf[<span class="number">1</span>] + <span class="number">64</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nChannel == <span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">    nChannel = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)m_recvBuf[<span class="number">2</span>] * <span class="number">256</span> + (<span class="keyword">unsigned</span> <span class="keyword">char</span>)m_recvBuf[<span class="number">1</span>] + <span class="number">64</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3、Chunk Message Header<br>Fmt 取值从0-3，决定了四种长度的chunk msg header，可取值为11B、7B、3B、0B。</p><ul><li>type0（fmt=0）<br><img src="http://pic-blog.bfvyun.com/rtmp/cmh0.jpg" alt="image"></li></ul><ul><li>Timestamp，时间戳，最大值为0xffffff，当超过这个值时启用时间戳扩展字段（最大4 个字节）。当时间戳扩展启用时，这个值必须填0xffffff。</li><li>Message length，并非trunk 的长度，而是指一条音视频帧或者控制消息的长度。</li><li>Message type id，消息类型，0x01-0x07 为控制消息(Chunk Stream ID 必须为2)，0x08 为音频，0x09 为视频，0x12 为元数据，0x14 为命令消息，0x16 为组合消息。</li><li>Msg streamid，Chunk 中的message stream id 为小端字节序，这是adobe 特别强调的。<br>每个Chunk Stream 开始的第一个Chunk 必须是Type 0 格式的，即使整个Chunk Stream只有一个Chunk。timestamp 表示Chunk 中的msg 的绝对时间值，每条Chunk Stream 的第一个Chunk 的timestamp 都是0。实战中我们发现type0 格式的chunk 非常少。</li></ul><ul><li><p>type1（fmt=1）<br><img src="http://pic-blog.bfvyun.com/rtmp/cmh1.jpg" alt="image"><br>type1的trunk 和上一个trunk 拥有相同的message stream id。且Timestamp delta 表示相对上一个trunk 的时间差，实战中大多数音视频数据都采用相对时间戳。</p></li><li><p>type2（fmt=2）<br><img src="http://pic-blog.bfvyun.com/rtmp/cmh2.jpg" alt="image"><br>type 2 的trunk 和上一个trunk 拥有相同的长度、消息类型、消息流id。</p></li><li><p>type3（fmt=3）<br>Type 3 的trunk msg header 长度为0，表示和上一个trunk 所有参数都相同。如果type3跟在type0 后面，则type3 的相对时间戳也是0。</p></li></ul><p>4、 Extended Timestamp:<br>这个字段是可选的，长度为4 个字节。只有当正常时间戳超过0xffffff 时，这个字段才存在。Type3 类型的trunk 一定不能有这个字段。</p><p>5、Chunk Data:<br>Chunk Data 可以是音视频数据、元数据、控制消息。</p><p>根据FMT的值（nPacketType）获取packet头信息代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> CRtmp::ParsePacketHead(<span class="keyword">const</span> <span class="keyword">char</span> *pInPacket, <span class="keyword">int</span> nPacketType, CRtmpPacket *pOutPacket)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span> (pInPacket == <span class="literal">NULL</span> || pOutPacket == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">switch</span> (nPacketType)</div><div class="line">&#123;</div><div class="line"><span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">&#123;</div><div class="line">pOutPacket-&gt;m_nTimeStamp = Utils::ReadInt24(pInPacket);</div><div class="line">pOutPacket-&gt;m_nMsgLen = Utils::ReadInt24(pInPacket + <span class="number">3</span>);</div><div class="line">pOutPacket-&gt;m_cPacketType = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)*(pInPacket + <span class="number">6</span>);</div><div class="line">pOutPacket-&gt;m_nMsgStreamId = Utils::ReadInt32LE(pInPacket + <span class="number">7</span>);</div><div class="line"><span class="keyword">if</span>(pOutPacket-&gt;m_nTimeStamp == <span class="number">0xffffff</span>)</div><div class="line">&#123;</div><div class="line">pOutPacket-&gt;m_bIfUseExtTS = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">&#123;</div><div class="line">pOutPacket-&gt;m_nTimeStamp = Utils::ReadInt24(pInPacket);</div><div class="line">pOutPacket-&gt;m_nMsgLen = Utils::ReadInt24(pInPacket + <span class="number">3</span>);</div><div class="line">pOutPacket-&gt;m_cPacketType = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)*(pInPacket + <span class="number">6</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">&#123;</div><div class="line">pOutPacket-&gt;m_nTimeStamp = Utils::ReadInt24(pInPacket);</div><div class="line">&#125;</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="number">3</span>:</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">default</span>:</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="实际中message与trunk的关系"><a href="#实际中message与trunk的关系" class="headerlink" title="实际中message与trunk的关系"></a>实际中message与trunk的关系</h3><p>在一条TCP 连接中，可以同时包含着几条Message Stream，绝大部分情况下是Control Msg Stream 和Media Msg Stream。而这些Msg Stream 由一段一段的Chunk Stream 组成，每个Chunk Stream 都带有一个Message Stream ID 以标识这个Chunk Stream 是属于哪一个Msg Stream。由于Chunk Stream 所包含的数据比较大，常常又被切分成更小的Chunk，每个Chunk 都带有一个Chunk Stream ID 以标识它属于哪一个Chunk Stream。</p><h2 id="控制消息"><a href="#控制消息" class="headerlink" title="控制消息"></a>控制消息</h2><p>控制消息是作为rtmp trunk stream 的负载存在的。当Message type id 取值为0-7 时，表示控制消息。同时Chunk Basic Header 的Chunk Stream ID 必须为2，Chunk Msg Header 的Message Stream ID 必须为0。其中消息7一般不用。<br>1、 0x01 – Set Chunk Size<br><img src="http://pic-blog.bfvyun.com/rtmp/scz.jpg" alt="image"><br>这个消息是双向发送的，一方告诉另一方自己的trunk 大小。一旦设置成功则后续所有trunk 大小会一直保持这个值。设置之前是128。</p><p>2、 0x02 – About Message<br><img src="http://pic-blog.bfvyun.com/rtmp/am.jpg" alt="image"><br>用来通知正在等待接收指定的Chunk Stream 的对端，放弃等待，并且放弃处理AboutMessage 中所指明的chunk stream id 的Chunk Stream 中的消息。注意这条命令只是撤销一个Chunk Stream 的数据，并不是整条Message Stream。实战中这个消息基本不会发送， 在rtmpdump 中也不会处理这个消息。</p><p>3、 0x03 – Acknowledgement<br><img src="http://pic-blog.bfvyun.com/rtmp/ack.jpg" alt="image"><br>用来告知server，到目前为止已经收到了一定量的数据。0x05 消息指定了server 发送的窗口最大值，如果在发送的数据达到了最大值还没有收到客户端发来的报告，则server 会停止发送数据，经过实测fms 超过三倍这个窗口时会停止发送数据。因此客户端必须在收到数据未达到最大值前报告自己接收到的字节数。Sequence num 表示到目前为止客户端收到的字节数，但是要注意这个值会溢出，溢出后server不久便会停止发送数据，rtmpdump 就有这个问题。</p><p>4、 0x04 – User Control Message<br><img src="http://pic-blog.bfvyun.com/rtmp/ucm.jpg" alt="image"><br>这条消息是用户控制消息。主要是用来在Client 与Server 之间发送消息通知对方用户控制事件。这个消息的前2 个bytes 是指事件的类型，后面是事件的数据。根据Event Type 的不同，Event Data 的长度是不同的。</p><ul><li>Type0，Stream Begin，服务器端通知客户端message stream 已经可以正常工作了。Event Data 是0，长度为4 个字节。这个事件是当服务器收到客户端的connect 命令后发送给客户端的。</li><li>Type1，Stream EOF，服务器端通知客户端播放已经结束了。Event Data 表示流ID，长度为4 个字节。</li><li>Type2，Stream Dry，服务器端通知客户端message stream 已经没有数据了。EventData 表示流ID，长度为4 个字节。服务器端在一段时间内没有检测到消息则可以给客户端发送这个事件。</li><li>Type3，SetBuffer Length，客户端通知服务器端用来接收数据的buffer 大小（以毫秒为单位）。Event Data 共8 比特，前4 比特表示流ID，后4 比特代表buffer 大小。客户端在服务器端处理流之前发送这个事件。</li><li>Type4，StreamIsRecorded，服务器端通知客户端这个流需要被录像。Event Data 表示流ID，长度为4 个字节。</li><li>Type6，PingRequest，服务器端用于测试客户端是否存活。Event Data 为服务器时间戳，长度为4 个字节。</li><li>Type7，PingResponse，客户端反馈服务器端PingRequest 消息，Event Data 为ping消息中的时间戳，长度为4 个字节。Ping 消息必须回，否则一段时间后server 会停止服务。</li></ul><p>5、 0x05 – Window Acknowledgement Size<br><img src="http://pic-blog.bfvyun.com/rtmp/waz.jpg" alt="image"><br>这条消息也叫“Server Bandwidth”，主要是用于告知对方自己希望对方接收多少个字节之后回应一个Ack 确认消息。这个具体的字节数也叫做窗口大小。通常Server 会在成功处理Client 发出的connect 请求后发送这个Msg 更新Client 的Ack 窗口大小。</p><p>6、 0x06 – Set Peer Bandwidth<br><img src="http://pic-blog.bfvyun.com/rtmp/spb.jpg" alt="image"><br>这条消息也叫“Client Bandwidth”，和Msg Type 0x05 相对应，这条消息是告诉对方要以怎样的带宽发送数据，带宽值应该与对方的Windows Size 相同。如果收到这条消息的一方发现自己的Windows Size 和这条消息中指定的Bandwidth 不同，应该回应一个Msg Type0x05。另外这条消息还有一个额外的字段Limit type，它的取值分别为：hard(0)、soft(1)、dynamic(2)。</p><ul><li>Hard：对方的发送数据带宽必须严格符合指定带宽。</li><li>Soft：对方发送数据带宽可以自行决定。必要时接收方可以限制对方带宽。</li><li>Dynamic：带宽既可以是hard 也可以是soft。</li></ul><h2 id="命令消息"><a href="#命令消息" class="headerlink" title="命令消息"></a>命令消息</h2><p>当Message type id 取值为14 时，表示命令消息。命令消息对Chunk Stream ID 和MessageStream ID 没有特殊要求，而控制消息是有的。命令消息分为两大类，NetConnection 和NetStream。</p><ul><li>NetConnection 包括：connect、call、close、createStream 命令。</li><li>NetStream 包括：play、play2、deleteStream、closeStream、receiveAudio、receiveVideo、publish、seek、pause 命令。<br>命令的格式为command name + transaction ID + 其他，所有字段都是用AMF 格式封装的，transaction ID的含义不明确，虽然官方文档有规定，但是实战中不是这么用的。下面我们只介绍最常用的connect、createStream、Play 命令，这三个命令是必须的，其他命令可以不用。<h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3>Connect 命令是client 发送给server 的第一个命令，而此时chunk 大小还没有设定。因此client 采用默认值128 字节。<br>Client 到Server 命令格式：<br><img src="http://pic-blog.bfvyun.com/rtmp/connectc2s.jpg" alt="image"><br>其中Command object的取值包括:<br><img src="http://pic-blog.bfvyun.com/rtmp/connectcmdobj.jpg" alt="image"><br>Server 到Client 命令格式:<br><img src="http://pic-blog.bfvyun.com/rtmp/connects2c.jpg" alt="image"></li></ul><h3 id="createStream"><a href="#createStream" class="headerlink" title="createStream"></a>createStream</h3><p>Createstream 用于与服务器创建一条逻辑链路，传输音频、视频、元数据。<br>Client 到Server 格式如下：<br><img src="http://pic-blog.bfvyun.com/rtmp/createc2s.jpg" alt="image"><br>Server 到Client 格式如下：<br><img src="http://pic-blog.bfvyun.com/rtmp/creates2c.jpg" alt="image"></p><h3 id="Play"><a href="#Play" class="headerlink" title="Play"></a>Play</h3><p>开始播放一条stream，streamid为createstream返回的id。<br>Client 到Server 格式如下：<br><img src="http://pic-blog.bfvyun.com/rtmp/playc2s.jpg" alt="image"><br>Server 到Client 格式如下:<br><img src="http://pic-blog.bfvyun.com/rtmp/plays2c.jpg" alt="image"></p><h2 id="客户端与服务器交互流程"><a href="#客户端与服务器交互流程" class="headerlink" title="客户端与服务器交互流程"></a>客户端与服务器交互流程</h2><p>客户端与服务器之间的交互可以划分为三个过程:握手、设置参数、播放。</p><h3 id="握手-1"><a href="#握手-1" class="headerlink" title="握手"></a>握手</h3><p><img src="http://pic-blog.bfvyun.com/rtmp/handshake.jpg" alt="image"></p><h3 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h3><p><img src="http://pic-blog.bfvyun.com/rtmp/setconf.jpg" alt="image"></p><h3 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h3><p><img src="http://pic-blog.bfvyun.com/rtmp/play.jpg" alt="image"></p><h3 id="从rtmpdump观察到的交互流程"><a href="#从rtmpdump观察到的交互流程" class="headerlink" title="从rtmpdump观察到的交互流程"></a>从rtmpdump观察到的交互流程</h3><p>client ———————————-server<br>1.RTMP_Connect———————————————————————–&gt;<br>2.HandleServerBW&lt;———————————————————————<br>3.HandleClientBW&lt;———————————————————————-<br>4.HandleChangeChunkSize&lt;————————————————————<br>5.HandleInvoke(_result for connect, NetConnection.Connect.Success)&lt;———–<br>6.SendServerBW———————————————————————–&gt;<br>7.SendRecvBuffSize——————————————————————–&gt;<br>8.SendCreateStream——————————————————————&gt;<br>9.HandleInvoke(onBWDone)&lt;———————————————————-<br>10.SendCheckBW(_checkbw)———————————————————&gt;</p><ol><li>HandleInvoke(_result for createStream, 得到stream id)&lt;———————–<br>12.SendPlay—————————————————————————–&gt;<br>13.SendClientBufferTime————————————————————–&gt;<br>14.HandleInvoke(_onbwcheck)&lt;——————————————————-<br>15.SendCheckBwResult—————————————————————-&gt;<br>16.ChangeChunkSize&lt;——————————————————————<br>17.HandleCtrl(stream is recorded)&lt;—————————————————<br>18.HandleInvoke(onStatus: NetStream.Play.Reset)&lt;——————————–<br>19.HandleCtrl(Stream Begin)&lt;———————————————————<br>20.HandleInvoke(onStatus: NetStream.Play.Start)&lt;———————————<br>21.MetaData(RtmpSampleAccess)&lt;—————————————————<br>22.MetaData(NetStream.Data.Start)&lt;————————————————-<br>23.MetaData(onMetaData)&lt;————————————————————<br>说明:HandleInvoke指的就是命令消息，HandleCtrl指的是控制消息。<br>1到7为设置参数阶段、8到23为播放阶段、第13步SendClientBufferTime，这个命令是向服务器发送本地接收缓冲区的大小，以时间（毫秒）为单位。实战中发现，FMS流控就是依靠这个参数来做的。如果将这个值设置为5000，则我们会发现FMS快速发送一部分数据（应该是5秒的数据），然后等待大约5秒，然后再发送一部分数据，这种流控其实很不合理。</li></ol><h2 id="混合消息"><a href="#混合消息" class="headerlink" title="混合消息"></a>混合消息</h2><p>混合消息（Aggregate Message）是由多个消息组合而成的消息，Msg type 为0x16。之所以会存在这样的打包消息。是为了减少FMS 因为IO 过于频繁而导致CPU 开销过大的一种优化。<br><img src="http://pic-blog.bfvyun.com/rtmp/aggregate.jpg" alt="image"><br>混合消息中包含很多子消息，实战中发现子消息只有视频、音频、元信息三种。需要说明一点的是，子消息中的head 指的是flv 头而不是rtmp 头。如果非要解析这个数据包的话必须结合flv 头格式进行解析。还有注意一点，flv头中的时间戳都是绝对时间戳，和rtmp 流的时间戳不是一个体系的。如果要计算子消息的时间戳则要结合混合消息头消息中的时间戳。子消息的相对时间可以这样来计算：第一个子消息的时间戳与混合消息的时间戳相同，后续子消息用自己的绝对时间戳减去第一个子消息的绝对时间戳，然后再加上混合消息的时间戳即可。在Aggregate Message body 的打包消息列表中，Back Pointer 的内容是前一个Msg 的尺寸，包括Msg Header，这和FLV File Format 中的PreviousTagSize 非常相似。</p><h2 id="加流控信息"><a href="#加流控信息" class="headerlink" title="加流控信息"></a>加流控信息</h2><p>flv文件头非常小，通常只有几百个字节，好处是元信息很少便于传输，坏处是不便于对数据做索引。下面两个工具可以给flv增加关键帧索引信息，即关键帧的位置和播放时间。<br>元数据主要有两个数组，times和filepositions,这两个数组是相对应的，比如times[10]=184.4，而filepositions[10]=10000,意思是视频在184.4秒处的文件位置是10000，当向http服务器（例如Nginx）视频信息时<br><a href="http://localhost/flv/1.flv？start=10000,则视频就会从184.4秒处开始播放，这样就实现了seek到184.4的效果。但是需要注意的是，start的数值必须是关键帧数组里的filepositions的值，否则不会成功。" target="_blank" rel="external">http://localhost/flv/1.flv？start=10000,则视频就会从184.4秒处开始播放，这样就实现了seek到184.4的效果。但是需要注意的是，start的数值必须是关键帧数组里的filepositions的值，否则不会成功。</a></p><p>参考：<br><a href="http://rubyforge.org/frs/?group_id=1096" target="_blank" rel="external">flvtool2</a><br><a href="http://yamdi.sourceforge.net" target="_blank" rel="external">yamdi</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;实时消息传输协议(RTMP)最初是由 Macromedia 为互联网上 Flash player 和服务器之间传输音频、视频以及数据流而开发的一个私有协议。RTMP协议是一个互联网TCP/IP五层体系结构中应用层的协议。RTMP协议中基本的数据单元称为消息（Message）。当RTMP协议在互联网中传输数据的时候，消息会被拆分成更小的单元，称为消息块（Chunk）。（本文内容多来自文档翻译）&lt;/p&gt;
    
    </summary>
    
    
      <category term="RTMP" scheme="http://mufool.com/tags/RTMP/"/>
    
  </entry>
  
  <entry>
    <title>Mysql单表大数据导出导入</title>
    <link href="http://mufool.com/2017/11/30/mysql-table-import-export/"/>
    <id>http://mufool.com/2017/11/30/mysql-table-import-export/</id>
    <published>2017-11-30T09:21:57.000Z</published>
    <updated>2017-11-30T09:23:00.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT * INTO OUTFILE &apos;/var/lib/mysql-files/data.txt&apos; FIELDS TERMINATED BY &apos;,&apos; FROMOLD_TABLE;</div><div class="line">LOAD DATA INFILE &apos;/var/lib/mysql-files/data.txt&apos; INTO TABLE NEW_TABLE;</div></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一般使用时会遇到一下问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The MySQL server is running with the --secure-file-priv option so it cannot execute this statement</div></pre></td></tr></table></figure><h2 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h2><p>secure_file_priv 设置了指定目录，需要在指定的目录下进行数据导出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;%secure%&apos;;</div><div class="line">+--------------------------+-----------------------+</div><div class="line">| Variable_name            | Value                |</div><div class="line">+--------------------------+-----------------------+</div><div class="line">| require_secure_transport | OFF                  |</div><div class="line">| secure_auth              | ON                    |</div><div class="line">| secure_file_priv        | /var/lib/mysql-files/ |</div><div class="line">+--------------------------+-----------------------+</div><div class="line">3 rows in set (0.00 sec)</div></pre></td></tr></table></figure></p><p>这个参数用来限制数据导入和导出操作的效果，例如执行LOAD DATA、SELECT … INTO OUTFILE语句和LOAD_FILE()函数。这些操作需要用户具有FILE权限。 如果这个参数为空，这个变量没有效果； 如果这个参数设为一个目录名，MySQL服务只允许在这个目录中执行文件的导入和导出操作。这个目录必须存在，MySQL服务不会创建它； 如果这个参数为NULL，MySQL服务会禁止导入和导出操作。这个参数在MySQL 5.7.6版本引入。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;命令使用&quot;&gt;&lt;a href=&quot;#命令使用&quot; class=&quot;headerlink&quot; title=&quot;命令使用&quot;&gt;&lt;/a&gt;命令使用&lt;/h2&gt;
    
    </summary>
    
    
      <category term="MYSQL" scheme="http://mufool.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>FM原理和使用</title>
    <link href="http://mufool.com/2017/11/20/fm/"/>
    <id>http://mufool.com/2017/11/20/fm/</id>
    <published>2017-11-20T10:49:12.000Z</published>
    <updated>2019-03-20T03:08:23.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FM算法，全称Factorization Machines,一般翻译为“因子分解机”。2010年，它由当时还在日本大阪大学的Steffen Rendle提出。此算法的主要作用是可以把所有特征进行高阶组合，减少人工参与特征组合的工作，工程师可以将精力集中在模型参数调优。FM只需要线性时间复杂度，可以应用于大规模机器学习。经过部分数据集试验，此算法在稀疏数据集合上的效果要明显好于SVM。</p><a id="more"></a><h2 id="模型形式"><a href="#模型形式" class="headerlink" title="模型形式"></a>模型形式</h2><p>在线性回归模型中，每个feature具有一个权重，参数求解过程相当于构造一个超平面将空间分为两部分。线性回归最大的优点是简单高效，只需要计算好每个feature的权重。但是缺点也是模型比较简单，只能建模线性关系（不过大部分时候也够用了，不够用时可以用特征工程）。</p><p>传统线性回归基于以下模型，从模型方程易见，各特征分量xi和xj是相互独立。</p><p><img src="http://pic-blog.bfvyun.com/fm/fm1.jpg" alt="image"><br>但是，一般线性模型无法学习到高阶组合特征，所以会将特征进行高阶组合，这里以二阶为例(理论上，FM可以组合任意高阶，但是由于计算复杂度，实际中常用二阶，后面也主要介绍二阶组合的内容)。模型形式为，</p><p><img src="http://pic-blog.bfvyun.com/fm/fm2.jpg" alt="image"></p><p>相比于线性模型而言，二阶模型多了n(n−1)2参数。比如有(n=)1000个特征（连续变量离散化，并one-hot编码，特征很容易到达此量级），增加近50万个参数。</p><p>FM使用近似矩阵分解。将参数量级减少成线性量级。可以将所有参数Wij组合成一个矩阵。</p><p><img src="http://pic-blog.bfvyun.com/fm/fm3.jpg" alt="image"></p><p><img src="http://pic-blog.bfvyun.com/fm/fm4.jpg" alt="image"><br>很明显，实数矩阵W是对称的。所以，实对称矩阵W正定（至少半正定，这里假设正定）。根据矩阵的性质，正定矩阵可以分解。</p><p>定理：当k足够大时，对于任意对称正定矩阵<br><img src="http://pic-blog.bfvyun.com/fm/fm5.jpg" alt="image"><br>存在矩阵</p><p><img src="http://pic-blog.bfvyun.com/fm/fm6.jpg" alt="image"></p><p>使得<br><img src="http://pic-blog.bfvyun.com/fm/fm7.jpg" alt="image"></p><p>带入后，模型如下<br><img src="http://pic-blog.bfvyun.com/fm/fm8.jpg" alt="image"></p><p>问题从求解矩阵W变成了求解矩阵V</p><p>这样做的有点：</p><ul><li>W需要求解的参数个数为n<em>n，V需要求解的个数为n</em>k，k是一个可调整的参数，通常远远小于n</li><li>上面说过为求解wij，需要大量同时不为0的xi，xj，这个几乎是不可解的，没有那么多的样本。参数因子化使得 xhxi的参数和 xixj 的参数不再是相互独立的，因此我们可以在样本稀疏的情况下相对合理地估计FM的二次项参数。具体来说，xhxi 和 xixj 的系数分别为 <vh,vi> 和 <vi,vj>，它们之间有共同项 vi。也就是说，所有包含“xi的非零组合特征”（存在某个 j≠i，使得 xixj≠0）的样本都可以用来学习隐向量 vi，这很大程度上避免了数据稀疏性造成的影响。而在多项式模型中，whi 和 wij 是相互独立的。</vi,vj></vh,vi></li></ul><p>总的来说，计算效率得到质提升是因为使用近似计算，将参数复杂度从O(n2)降到O(n)。之前工作中遇到的介数估算，也使用类似套路，减少计算时间复杂度。</p><h2 id="FM实践"><a href="#FM实践" class="headerlink" title="FM实践"></a>FM实践</h2><p>使用真实环境中用户的数据测试一下几个FM库，测试样本共800万条，正负样本各一半，特征为325个。因为本例是点击率预测的，所以属于二分类问题。</p><h3 id="libfm使用示例"><a href="#libfm使用示例" class="headerlink" title="libfm使用示例"></a>libfm使用示例</h3><p>训练<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./libFM -task c -train /opt/hadoop/hadoop-2.6.5/train1.txt -test /opt/hadoop/hadoop-2.6.5/test1.txt -rlog ./log.txt -dim &apos;1,1,16&apos; -iter 10 -init_stdev 0.001 -method sgd -learn_rate 0.001  -regular &apos;0,0,0.001&apos; -save_model mode.fm -out model.txt</div></pre></td></tr></table></figure></p><p>预测，<code>-iter</code>设置为0即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./libFM -task c -train /opt/hadoop/hadoop-2.6.5/train1.txt -test /opt/hadoop/hadoop-2.6.5/test1.txt -rlog ./log.txt -dim &apos;1,1,16&apos; -iter 0 -init_stdev 0.001 -method sgd -learn_rate 0.001  -regular &apos;0,0,0.001&apos; -load_model mode.fm -out model.txt</div></pre></td></tr></table></figure></p><p>rlog.txt为输出的log文件，对于回归输出的是均方差；对于分类输出为准确率。</p><h3 id="fastFM使用"><a href="#fastFM使用" class="headerlink" title="fastFM使用"></a>fastFM使用</h3><p>支持tests目录下的例子即可，对于als的使用，可能会报错，需要修改源码中报错部分再安装。</p><h3 id="alphaFM使用"><a href="#alphaFM使用" class="headerlink" title="alphaFM使用"></a>alphaFM使用</h3><p>训练<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat train1.txt | /opt/hadoop/alphaFM-master/bin/fm_train -dim 1,1,16 -m /opt/hadoop/hadoop-2.6.5/model_file.txt -w_l1 0.05 -v_l1 0.05 -init_stdev 0.001 -w_alpha 0.01 -v_alpha 0.01 -core 10</div></pre></td></tr></table></figure></p><p>预测<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/hdfs dfs -cat /fmdata/20171107/part-*| /opt/hadoop/alphaFM-master/bin/fm_predict -dim 8 -m /opt/hadoop/hadoop-2.6.5/model_file.txt -out fm_pre.txt -core 10</div></pre></td></tr></table></figure></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th>FM库</th><th>语言</th><th>训练时间</th><th>准确性</th><th>接口</th><th>其他</th></tr></thead><tbody><tr><td><a href="https://github.com/srendle/libfm" target="_blank" rel="external">libfm</a></td><td>C++11</td><td>5min</td><td>73%</td><td>命令行，支持模型保存和载入</td><td>基于paper的实现，支持SGD, SGDA, ALS和MCMC</td></tr><tr><td><a href="https://github.com/jfloff/pywFM" target="_blank" rel="external">pywFM</a></td><td>python</td><td>5min</td><td>同上</td><td>类sklearn接口，支持模型保存和载入</td><td>python封装的libfm</td></tr><tr><td><a href="http://geek.csdn.net/news/detail/112231" target="_blank" rel="external">alphaFM</a></td><td>C++11</td><td>2min</td><td>71%</td><td>命令行，支持模型保存和载入</td><td>支持多线程，基于FTRL算法实现</td></tr><tr><td><a href="https://github.com/ibayer/fastFM" target="_blank" rel="external">fastFM</a></td><td>python，c</td><td>8min</td><td>sgd:61% als:73% mcmc:76%</td><td>类sklearn接口，mcmc不支持模型保存载入</td><td>SGD, ALS和MCMC</td></tr><tr><td><a href="https://github.com/coreylynch/pyFM" target="_blank" rel="external">pyFM</a></td><td>python，c</td><td>大数据量无法计算</td><td>无</td><td>类sklearn接口，支持模型保存和载入</td><td>基于SGDA算法实现</td></tr><tr><td><a href="https://github.com/geffy/tffm/tree/master/tffm" target="_blank" rel="external">Factorization Machines with libFM (Python/TensorFlow)</a></td><td>python</td><td>未测试</td><td></td><td></td></tr><tr><td><a href="https://github.com/zhengruifeng/spark-libFM" target="_blank" rel="external">spark-libFM</a></td><td>scala</td><td>未测试</td><td></td><td></td></tr><tr><td><a href="https://github.com/dmlc/difacto" target="_blank" rel="external">DiFacto</a></td><td>c++</td><td>未测试</td><td></td></tr></tbody></table><h2 id="FFM"><a href="#FFM" class="headerlink" title="FFM"></a>FFM</h2><p>FM有一个衍生算法FFM（Field-aware FM），大概思路是将特征进行分组，学习出更多的隐式向量V，FM可以看做FFM只有一个分组的特例。FFM复杂度比较高，比较适合高度稀疏数据；而FM可以应用于非稀疏数据，更加通用。</p><p>参考：<br><a href="http://www.libfm.org/libfm-1.42.manual.pdf" target="_blank" rel="external">libfm使用文档</a><br><a href="http://d0evi1.com/libfm/" target="_blank" rel="external">libfm中文翻译</a><br><a href="http://ibayer.github.io/fastFM/guide.html" target="_blank" rel="external">fastFM文档</a><br><a href="http://www.tk4479.net/jiangda_0_0/article/details/77510029" target="_blank" rel="external">FM算法和fastFM包的使用介绍</a><br><a href="http://castellanzhang.github.io/2016/10/16/fm_ftrl_softmax/" target="_blank" rel="external">FM, FTRL, Softmax</a><br><a href="https://github.com/arogozhnikov/arogozhnikov.github.io/blob/master/notebooks/2016-02-15-TestingLibFM.ipynb" target="_blank" rel="external">老外的测试结果</a><br><a href="https://tech.meituan.com/deep-understanding-of-ffm-principles-and-practices.html" target="_blank" rel="external">美团fm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;FM算法，全称Factorization Machines,一般翻译为“因子分解机”。2010年，它由当时还在日本大阪大学的Steffen Rendle提出。此算法的主要作用是可以把所有特征进行高阶组合，减少人工参与特征组合的工作，工程师可以将精力集中在模型参数调优。FM只需要线性时间复杂度，可以应用于大规模机器学习。经过部分数据集试验，此算法在稀疏数据集合上的效果要明显好于SVM。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://mufool.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python使用国内源下载</title>
    <link href="http://mufool.com/2017/11/16/python-mirrors/"/>
    <id>http://mufool.com/2017/11/16/python-mirrors/</id>
    <published>2017-11-16T08:54:00.000Z</published>
    <updated>2017-11-16T08:55:12.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>通过pip安装scipy、scikit-learn等库的时候，可能会报上面的错误</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ReadTimeoutError: HTTPSConnectionPool(host=&apos;pypi.python.org&apos;, port=443): Read timed out.</div></pre></td></tr></table></figure><h2 id="原因及解决方法"><a href="#原因及解决方法" class="headerlink" title="原因及解决方法"></a>原因及解决方法</h2><p>以上原因是因为默认使用国外源进行下载，下载速度慢导致超时。解决方法更换成国内园即可。</p><p>国内源：</p><ul><li><a href="http://pypi.douban.com/" target="_blank" rel="external">http://pypi.douban.com/</a>  豆瓣</li><li><a href="http://pypi.hustunique.com/" target="_blank" rel="external">http://pypi.hustunique.com/</a>  华中理工大学</li><li><a href="http://pypi.sdutlinux.org/" target="_blank" rel="external">http://pypi.sdutlinux.org/</a>  山东理工大学</li><li><a href="http://pypi.mirrors.ustc.edu.cn/" target="_blank" rel="external">http://pypi.mirrors.ustc.edu.cn/</a>  中国科学技术大学</li></ul><p>下载时指定源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip  install --index https://pypi.mirrors.ustc.edu.cn/simple/  scikit-learn</div></pre></td></tr></table></figure><p>或者，更改默认的配置，创建~/.pip/pip.conf，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[global]</div><div class="line">index-url = https://pypi.mirrors.ustc.edu.cn/simple/</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;通过pip安装scipy、scikit-learn等库的时候，可能会报上面的错误&lt;/p&gt;
    
    </summary>
    
    
      <category term="PYTHON" scheme="http://mufool.com/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>Zeppelin中文文档</title>
    <link href="http://mufool.com/2017/11/16/zeppelin/"/>
    <id>http://mufool.com/2017/11/16/zeppelin/</id>
    <published>2017-11-16T08:52:46.000Z</published>
    <updated>2017-11-16T08:55:48.116Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://cwiki.apachecn.org/display/Zeppelin/Index" target="_blank" rel="external">Apache Zeppelin 0.7.2 中文文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://cwiki.apachecn.org/display/Zeppelin/Index&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Zeppelin 0.7.2 中文文档&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="SPARK" scheme="http://mufool.com/tags/SPARK/"/>
    
  </entry>
  
  <entry>
    <title>Centos升级gcc版本</title>
    <link href="http://mufool.com/2017/11/16/gcc-update/"/>
    <id>http://mufool.com/2017/11/16/gcc-update/</id>
    <published>2017-11-16T08:46:15.000Z</published>
    <updated>2017-11-16T08:58:04.677Z</updated>
    
    <content type="html"><![CDATA[<ol><li>下载源码包</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://ftp.gnu.org/gnu/gcc/gcc-4.8.0/gcc-4.8.0.tar.bz2</div></pre></td></tr></table></figure><p>　　<br>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -jxvf  gcc-4.8.0.tar.bz2</div></pre></td></tr></table></figure><ol><li>下载编译所需依赖库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd gcc-4.8.0　</div><div class="line">./contrib/download_prerequisites　</div><div class="line">cd ..</div></pre></td></tr></table></figure><ol><li>建立编译输出目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir gcc-build-4.8.0</div></pre></td></tr></table></figure><ol><li>进入此目录，执行以下命令，生成makefile文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd  gcc-build-4.8.0</div><div class="line">../gcc-4.8.0/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</div></pre></td></tr></table></figure><ol><li>编译</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make -j4</div></pre></td></tr></table></figure><p>如果编译成功，则时间是比较长的，半个小时左右，所以如果你看它一直在输出没有立刻停下来，应该很开心！</p><ol><li>安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo make install</div></pre></td></tr></table></figure><ol><li>切换GCC到新版</li></ol><p>确定新安装的GCC的路径,一般默认在/usr/local/bin下。可以先<code>updatedb</code>,然后<code>locate gcc-4.8|tail</code>找一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls /usr/local/bin | grep gcc</div></pre></td></tr></table></figure><p>添加新GCC到可选项，倒数第三个是名字，倒数第二个参数为新GCC路径，最后一个参数40为优先级，设大一些之后就自动使用新版了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update-alternatives --install /usr/bin/gcc gcc /usr/local/bin/i686-pc-linux-gnu-gcc 40</div></pre></td></tr></table></figure><ol><li>确认当前版本已经切换为新版</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -v</div></pre></td></tr></table></figure><p>我这里用ssh远程的，发现版本没变，断开重练下，重新生成会话后发现变成了4.8了！</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;下载源码包&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="GCC" scheme="http://mufool.com/tags/GCC/"/>
    
  </entry>
  
  <entry>
    <title>Centos升级python2.7</title>
    <link href="http://mufool.com/2017/11/16/python-update-2-7/"/>
    <id>http://mufool.com/2017/11/16/python-update-2-7/</id>
    <published>2017-11-16T08:43:26.000Z</published>
    <updated>2017-11-16T08:44:41.871Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS 6.X 自带的Python版本是 2.6 , 目前python主流的编译环境是2.7，故整理一下python2.6到2.7的升级过程。</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>依赖工具包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel</div></pre></td></tr></table></figure><p>源码安装2.7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget http://www.python.org/ftp/python/2.7.8/Python-2.7.8.tar.xz</div><div class="line">xz -d Python-2.7.8.tar.xz</div><div class="line">tar -xvf Python-2.7.8.tar</div></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd Python-2.7.8</div><div class="line">./configure --prefix=/usr/local</div><div class="line">make</div><div class="line">make altinstall</div><div class="line">[root@VM_centos ~]# python2.7 -V</div><div class="line">Python 2.7.8</div></pre></td></tr></table></figure><h2 id="更新python"><a href="#更新python" class="headerlink" title="更新python"></a>更新python</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mv /usr/bin/python /usr/bin/python.bak</div><div class="line">ln -s /usr/local/bin/python2.7  /usr/bin/python</div></pre></td></tr></table></figure><p>此时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[clouddev@TY-0064 ~]$ python -V</div><div class="line">Python 2.7.8</div><div class="line">[clouddev@TY-0064 ~]$ which python</div><div class="line">/usr/bin/python</div><div class="line">[clouddev@TY-0064 ~]$</div></pre></td></tr></table></figure><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl  https://bootstrap.pypa.io/get-pip.py | python2.7 -</div></pre></td></tr></table></figure><p>启动pip报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pkg_resources.DistributionNotFound: The &apos;pip==7.1.0&apos; distribution was not found and is required by the application</div></pre></td></tr></table></figure></p><p>修改pip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mv /usr/bin/pip /usr/bin/pip0</div><div class="line">cp /usr/local/bin/pip2.7 /usr/bin/pip</div></pre></td></tr></table></figure></p><h2 id="修复yum"><a href="#修复yum" class="headerlink" title="修复yum"></a>修复yum</h2><p>yum依赖的python2.6，此时yum无法使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[clouddev@TY-0064 ~]$ which yum</div><div class="line">/usr/bin/yum</div></pre></td></tr></table></figure></p><p>将第一行<code>#!/usr/bin/python</code>改为<code>#!/usr/bin/python2.6</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS 6.X 自带的Python版本是 2.6 , 目前python主流的编译环境是2.7，故整理一下python2.6到2.7的升级过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PYTHON" scheme="http://mufool.com/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>Centos安装redis集群</title>
    <link href="http://mufool.com/2017/10/17/redis-cluster/"/>
    <id>http://mufool.com/2017/10/17/redis-cluster/</id>
    <published>2017-10-17T12:02:47.000Z</published>
    <updated>2019-03-20T03:10:18.062Z</updated>
    
    <content type="html"><![CDATA[<p>Redis Cluster是3.0版本之后提供的新功能，采用了P2P的去中心化架构，而没有采用像Codis之类的Proxy解决方案中的中心协调节点设计。</p><a id="more"></a><h2 id="Redis集群原理"><a href="#Redis集群原理" class="headerlink" title="Redis集群原理"></a>Redis集群原理</h2><p>Redis集群使用数据分片而非一致性哈希来实现，一个Redis集群包含16384个哈希槽（slot），数据库中的每个键都属于这16384个哈希槽中的其中一个，集群中的每个节点可以处理0个或最多16384个槽，当数据库中的16384个槽都有节点在处理时，集群处于上线状态；而如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态。<br>集群中的每个节点负责处理一部分哈希槽，比如，现在有三个独立的节点127.0.0.1:7000,127.0.0.1:7001,127.0.0.1:7002，其中各节点处理的哈希槽关系：节点7000负责处理0到5000号哈希槽，节点7001负责处理5001到10000号哈希槽，节点7002负责处理10001到16384号哈希槽。<br>从而，当向集群中添加或删除节点时，集群只需在对应节点的哈希槽做移动即可。不会造成节点阻塞、集群下线。<br>当然，为了使得集群在一部分节点下线的情况下仍然可以正常运作，Redis集群对节点提供了主从复制功能，集群中的每个节点都有1到N个复制节点，形成主-从模型。</p><h2 id="Redis集群架构"><a href="#Redis集群架构" class="headerlink" title="Redis集群架构"></a>Redis集群架构</h2><p>(图片来自网络)<br><img src="http://i.imgur.com/O4QfdDF.jpg" alt="image"></p><p>Redis集群架构的主要特点有:</p><ul><li>所有节点批次互联（PING-PONG机制），没有中心控制协调节点，内部使用二进制协议优化传输速度和带宽；</li><li>节点的失效通过集群中超过半数的节点“投票”监测；</li><li>客户端与Redis节点直连，不需要中间proxy层，客户端连接集群中任何一个可用节点即可；</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>依赖库安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install gcc openssl-devel libyaml-devel libffi-devel readline-devel zlib-devel gdbm-devel ncurses-devel gcc-c++ automake autoconf</div></pre></td></tr></table></figure></p><p>redis编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget http://download.redis.io/releases/redis-3.0.6.tar.gz</div><div class="line">tar xvf redis-3.0.6.tar.gz</div><div class="line">cd redis-3.0.6/</div><div class="line">make MALLOC=libc</div></pre></td></tr></table></figure></p><p>编译之后再src目录下会生成需要的可执行文件，用到的文件有：</p><ul><li>redis-trib.rb，集群创建脚本</li><li>redis-server，redis服务</li><li>redis-cli，redis客户端</li></ul><h2 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h2><p>这里部署在同一台上测试，同时配置主从，共6个节点7000-7005。</p><p>1、创建目录</p><p>在redis-cluster目录下，创建目录7000-7005<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir redis-cluster</div><div class="line">mkdir 7000 7001 7002 7003 7004 7005</div></pre></td></tr></table></figure></p><p>2、修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">daemonize yes</div><div class="line">pidfile /var/run/redis0.pid</div><div class="line">port 7000</div><div class="line">#bind 127.0.0.1 192.168.193.229 119.18.193.229</div><div class="line">loglevel notice</div><div class="line">logfile &quot;./log.txt&quot;</div><div class="line"></div><div class="line">cluster-enabled yes</div><div class="line">cluster-config-file nodes-7000.conf</div><div class="line">cluster-node-timeout 5000</div><div class="line"></div><div class="line">appendonly yes</div><div class="line">appendfsync everysec</div><div class="line"></div><div class="line">rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c28</div><div class="line">rename-command FLUSHALL &quot;&quot; </div><div class="line">rename-command FLUSHDB &quot;&quot;</div></pre></td></tr></table></figure><p>分别拷贝到其他目录，并修改对应的配置项。</p><p>3、分别启动6个redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd redis-cluster/7000</div><div class="line">./redis-server redis.conf</div><div class="line">...</div><div class="line">cd redis-cluster/7005</div><div class="line">./redis-server redis.conf</div></pre></td></tr></table></figure><p>4、查看进程</p><p><img src="http://pic-blog.bfvyun.com/redis/redis-cluster0.jpg" alt="image"></p><h2 id="建立redis集群"><a href="#建立redis集群" class="headerlink" title="建立redis集群"></a>建立redis集群</h2><p>以上步骤分别创建了6个节点，并已经启动，这里要把这6个节点加入到一个集群里面。redis 已经为我们提供了集群操作的脚本 redis-trib.rb。</p><h3 id="安装ruby"><a href="#安装ruby" class="headerlink" title="安装ruby"></a>安装ruby</h3><p>由于集群操作需要用到 ruby 脚本 redis-trib.rb , 所以要安装 ruby 和 rubygems<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum -y install ruby rubygems</div><div class="line">gem install redis --version 3.0.6</div></pre></td></tr></table></figure></p><p><img src="http://pic-blog.bfvyun.com/redis/redis-cluster1.jpg" alt="image"></p><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div></pre></td></tr></table></figure><p>其中，命令create表示创建一个新的集群，选项–replicas 1表示未集群中的每个主节点创建一个从节点。即，上述命令运行后，redis-trib将创建一个包含三个主节点和三个从节点的集群。<br><img src="http://pic-blog.bfvyun.com/redis/redis-cluster2.jpg" alt="image"><br>上面信息中 M 表示 Master 节点， S 表示 Slave 节点，同时可以看到主备关系。随后输入yes即可创建完成。</p><h2 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./src/redis-trib.rb check 127.0.0.1:7000</div></pre></td></tr></table></figure><p><img src="http://pic-blog.bfvyun.com/redis/redis-cluster3.jpg" alt="image"><br> 其中可以看到每台master上的slot的分配个数，所有16384个slot都被covered，集群处于上线状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src/redis-cli -p 7000 cluster nodes</div></pre></td></tr></table></figure><p><img src="http://pic-blog.bfvyun.com/redis/redis-cluster4.jpg" alt="image"> </p><p>查看集群中各节点的信息。包括唯一的节点ID，主从关系，每个主节点分配的slots范围。</p><p><img src="http://pic-blog.bfvyun.com/redis/redis-cluster5.jpg" alt="image"> </p><p>在任意节点上增删数据都可以在集群的其他节点看到。若节点上没有查询的数据，-c参数指定查询时接收到MOVED指令自动跳转。</p><p>参考：<br><a href="http://blog.dujiong.net/2017/01/15/Redis-Cluster/" target="_blank" rel="external">搭建Redis集群</a><br><a href="http://weizijun.cn/2016/01/08/redis%20cluster%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7redis-trib-rb%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">redis cluster管理工具redis-trib.rb详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis Cluster是3.0版本之后提供的新功能，采用了P2P的去中心化架构，而没有采用像Codis之类的Proxy解决方案中的中心协调节点设计。&lt;/p&gt;
    
    </summary>
    
    
      <category term="REDIS" scheme="http://mufool.com/tags/REDIS/"/>
    
  </entry>
  
  <entry>
    <title>Centos安装配置powerline</title>
    <link href="http://mufool.com/2017/09/29/powerline/"/>
    <id>http://mufool.com/2017/09/29/powerline/</id>
    <published>2017-09-29T08:23:47.000Z</published>
    <updated>2019-03-20T03:09:56.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Powerline是vim编辑器的插件，它是Python开发的，为多个应用（bash，zsh，tmux等）提供statusline。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装pip：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install python-pip -y</div></pre></td></tr></table></figure></p><p>安装powerline</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install git+git://github.com/powerline/powerline</div></pre></td></tr></table></figure><p>安装Powerline字体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/powerline/powerline/raw/develop/font/PowerlineSymbols.otf</div><div class="line">wget https://github.com/powerline/powerline/raw/develop/font/10-powerline-symbols.conf</div><div class="line">mv PowerlineSymbols.otf /usr/share/fonts/</div><div class="line">fc-cache -vf /usr/share/fonts/            //更新系统的字体缓存</div><div class="line">mv 10-powerline-symbols.conf /etc/fonts/conf.d/</div></pre></td></tr></table></figure><h2 id="在Bash中启用Powerline"><a href="#在Bash中启用Powerline" class="headerlink" title="在Bash中启用Powerline"></a>在Bash中启用Powerline</h2><p>查看powerline安装位置<br><img src="http://pic-blog.bfvyun.com/powerline/powerline1.jpg" alt="image"></p><p>可以看到安装位置在<code>/usr/lib/python2.6/site-packages</code>下</p><p>在~/.bashrc中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">powerline-daemon -q</div><div class="line">POWERLINE_BASH_CONTINUATION=1</div><div class="line">POWERLINE_BASH_SELECT=1</div><div class="line">. /usr/lib/python2.6/site-packages/powerline/bindings/bash/powerline.sh</div></pre></td></tr></table></figure><p><code>source ~/.bashrc</code>生效</p><p>重启终端即可看到效果。</p><p><img src="http://pic-blog.bfvyun.com/powerline/powerlinel4.jpg" alt="image"></p><h2 id="在vim中启用powerline"><a href="#在vim中启用powerline" class="headerlink" title="在vim中启用powerline"></a>在vim中启用powerline</h2><p>在.vimrc文件中添加即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">set rtp+=/usr/lib/python2.6/dist-packages/powerline/bindings/vim/</div><div class="line">set laststatus=2</div><div class="line">set t_Co=256</div></pre></td></tr></table></figure><p><img src="http://pic-blog.bfvyun.com/powerline/powerline2.jpg" alt="image"></p><h2 id="在zsh中启用powerline"><a href="#在zsh中启用powerline" class="headerlink" title="在zsh中启用powerline"></a>在zsh中启用powerline</h2><p>与bash中类似，在.zshrc中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export TERM=xterm-256color</div><div class="line">source /usr/lib/python2.6/site-packages/powerline/bindings/zsh/powerline.zsh</div></pre></td></tr></table></figure><p><code>source ~/.zshrc</code>生效。</p><p>参考：<br><a href="http://blog.topspeedsnail.com/archives/2652" target="_blank" rel="external">安装使用Powerline：Vim和Bash终端的状态栏</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Powerline是vim编辑器的插件，它是Python开发的，为多个应用（bash，zsh，tmux等）提供statusline。&lt;/p&gt;
    
    </summary>
    
    
      <category term="POWERLINE" scheme="http://mufool.com/tags/POWERLINE/"/>
    
  </entry>
  
  <entry>
    <title>Tmux安装使用</title>
    <link href="http://mufool.com/2017/09/29/tmux/"/>
    <id>http://mufool.com/2017/09/29/tmux/</id>
    <published>2017-09-29T07:24:41.000Z</published>
    <updated>2019-03-20T03:10:42.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Tmux是一个优秀的终端复用软件，支持多标签，也支持窗口内部面板的分割，更重要的是，Tmux提供了窗体随时保存和恢复的功能。想象一下假如你在公司的服务器上开了许多窗口调试程序，回到家时通过SSH连接公司电脑又要打开一堆繁琐的窗口，而且还忘记了当时调试到哪一步了，那Tmux可以帮你解决这个难题，当SSH连接断开重新连接后能够恢复到原来的工作环境。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">yum -y install ncurses-devel #依赖包</div><div class="line"></div><div class="line"># 版本需大于2.0.10-stable</div><div class="line">wget --no-check-certificate https://github.com/downloads/libevent/libevent/libevent-2.0.21-stable.tar.gz</div><div class="line">tar xzf libevent-2.0.21-stable.tar.gz</div><div class="line">cd libevent-2.0.21-stable</div><div class="line">./configure</div><div class="line">make &amp;&amp; make install</div><div class="line">cd ../</div></pre></td></tr></table></figure><h3 id="安装tmux"><a href="#安装tmux" class="headerlink" title="安装tmux"></a>安装tmux</h3><p>从git上下载最新代码编译安装，参见<a href="https://github.com/tmux/tmux" target="_blank" rel="external">github</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/tmux/tmux.git</div><div class="line">$ cd tmux</div><div class="line">$ sh autogen.sh</div><div class="line">$ CFLAGS=&quot;-I/usr/local/include&quot; LDFLAGS=&quot;-L//usr/local/lib&quot; ./configure #直接./configure会报错</div><div class="line"># make &amp;&amp; make install</div></pre></td></tr></table></figure></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>运行可能出现如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux: error while loading shared libraries: libevent-2.0.so.5: cannot open shared object file: No such file or directory</div></pre></td></tr></table></figure></p><p>建立一下符号链接即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if [ `getconf WORD_BIT` = '32' ] &amp;&amp; [ `getconf LONG_BIT` = '64' ] ; then</div><div class="line">    ln -s /usr/local/lib/libevent-2.0.so.5 /usr/lib64/libevent-2.0.so.5</div><div class="line">else</div><div class="line">    ln -s /usr/local/lib/libevent-2.0.so.5 /usr/lib/libevent-2.0.so.5</div><div class="line">fi</div></pre></td></tr></table></figure><p>启动如出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lost server</div></pre></td></tr></table></figure></p><p>重新安装解决</p><p>完成进入tmux进入软件，界面类似一个下方带有状态栏的终端。<br><img src="http://pic-blog.bfvyun.com/tmux/tmux1.jpg" alt="image"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Tmux基于典型的c/s模型，主要分为会话、窗口和面板三个元素：</p><ul><li>服务器：输入tmux命令时就开启了一个服务器。</li><li>Session：输入tmux后就创建了一个会话，一个会话是一组窗体的集合。</li><li>Window：会话中一个可见的窗口。</li><li>Pane:一个窗口可以分成多个面板。</li></ul><p><img src="http://pic-blog.bfvyun.com/tmux/tmux2.jpg" alt="image"><br>注：图片来自网络<br>图中左下角的3显示为当前会话，随后1 vim,2 bash,3 ssh 分别是3个窗口，蓝色bash表示当前窗口，图中用蓝色数字标记的1,2,3分别是bash窗口的三个面板。你还可以在tmux配置文件中给状态栏添加时间、天气等信息。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>第一次会产生一个新的 session 和 window ，在下方会显示其状态，如果意外断开 (detach) 连接，session 仍会在后台运行，每个窗口可以分为多个 pane 。</p><p>启动时的参数选项有：</p><ul><li>-2: 强制 tmux 假设终端支持 256 色。</li><li>-8: 类似于 -2 ，不过是强制 tmux 假设终端支持 88 色。</li><li>-c shell-command: 使用默认的 shell 执行命令，主要用于当 tmux 作为 login shell 时使用。</li><li>-f file: 指定配置文件，默认检查 /etc/tmux.conf、~/.tmux.conf，如果有命令错误，则会直接退出。</li><li>-V: 查看版本号。<br>默认 tmux 会创建的匿名的 session ，可以通过如下命令创建一个命名的 session ， Ctrl-b 是命令前缀(Command prefix)，通过前缀告知 tmux 下面的命令是发给 tmux 的，而非终端。常见的操作如下。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ tmux new-session -s basic    # 创建一个名为 basic 的 session</div><div class="line">$ tmux new -s basic -d        # 同上，但是不会连接到终端，在后台运行</div><div class="line">$ tmux new -s basic -n win    # 同上，并将第一个窗口命令为 win</div><div class="line"></div><div class="line">$ tmux ls                      # 列出现在的 sessions ，等同 tmux list-sessioin</div><div class="line">$ tmux attach                  # 如果只有一个 session</div><div class="line">$ tmux attach -t basic        # 指定名称，-t 表示 target</div><div class="line"></div><div class="line">$ tmux kill-session -t basic  # 关闭一个 session</div></pre></td></tr></table></figure></li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>基本操作</p><table><thead><tr><th>命令</th><th>操作</th></tr></thead><tbody><tr><td>?</td><td>列出所有快捷键；按q返回</td></tr><tr><td>d</td><td>脱离当前会话,可暂时返回Shell界面，输入tmux attach能够重新进入之前会话</td></tr><tr><td>s</td><td>选择并切换会话；在同时开启了多个会话时使用</td></tr><tr><td>D</td><td>选择要脱离的会话；在同时开启了多个会话时使用</td></tr><tr><td>:</td><td>进入命令行模式；此时可输入支持的命令，例如kill-server所有tmux会话</td></tr><tr><td>[</td><td>复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc退出</td></tr><tr><td>]</td><td>进入粘贴模式，粘贴之前复制的内容，按q/Esc退出</td></tr><tr><td>~</td><td>列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</td></tr><tr><td>t</td><td>显示当前的时间</td></tr><tr><td>Ctrl+z</td><td>挂起当前会话</td></tr></tbody></table><p>窗口操作</p><table><thead><tr><th>命令</th><th>操作</th></tr></thead><tbody><tr><td>c</td><td>创建新窗口</td></tr><tr><td>&amp;</td><td>关闭当前窗口</td></tr><tr><td>数字键</td><td>切换到指定窗口</td></tr><tr><td>p</td><td>切换至上一窗口</td></tr><tr><td>n</td><td>切换至下一窗口</td></tr><tr><td>l</td><td>前后窗口间互相切换</td></tr><tr><td>w</td><td>通过窗口列表切换窗口</td></tr><tr><td>,</td><td>重命名当前窗口，便于识别</td></tr><tr><td>.</td><td>修改当前窗口编号，相当于重新排序</td></tr><tr><td>f</td><td>在所有窗口中查找关键词，便于窗口多了切换</td></tr></tbody></table><p>面板操作</p><table><thead><tr><th>命令</th><th>操作</th></tr></thead><tbody><tr><td>“</td><td>将当前面板上下分屏</td></tr><tr><td>%</td><td>将当前面板左右分屏</td></tr><tr><td>x</td><td>关闭当前分屏</td></tr><tr><td>!</td><td>将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板</td></tr><tr><td>Ctrl+方向键</td><td>以1个单元格为单位移动边缘以调整当前面板大小</td></tr><tr><td>Alt+方向键</td><td>以5个单元格为单位移动边缘以调整当前面板大小</td></tr><tr><td>空格键</td><td>可以在默认面板布局中切换，试试就知道了</td></tr><tr><td>q</td><td>显示面板编号</td></tr><tr><td>o</td><td>选择当前窗口中下一个面板</td></tr><tr><td>方向键</td><td>移动光标选择对应面板</td></tr><tr><td>{</td><td>向前置换当前面板</td></tr><tr><td>}</td><td>向后置换当前面板</td></tr><tr><td>Alt+o</td><td>逆时针旋转当前窗口的面板</td></tr><tr><td>Ctrl+o</td><td>顺时针旋转当前窗口的面板</td></tr><tr><td>z</td><td>tmux 1.8新特性，最大化当前所在面板</td></tr></tbody></table><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>用户私人配置文件在~/.tmux.conf, 全局配置文件在 /etc/tmux.conf。修改这两处均可。</p><h3 id="前缀修改"><a href="#前缀修改" class="headerlink" title="前缀修改"></a>前缀修改</h3><p>Tmux的所有操作必须使用一个前缀进入命令模式，默认前缀为ctrl+b，很多人会改为ctrl+a,你可以修改tmux.conf配置文件来修改默认前缀：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#前缀设置为&lt;Ctrl-a&gt;</div><div class="line">set -g prefix C-a</div><div class="line">#解除&lt;Ctrl-b&gt;</div><div class="line">ubind C-b</div></pre></td></tr></table></figure><h3 id="配置更新"><a href="#配置更新" class="headerlink" title="配置更新"></a>配置更新</h3><p>配置完以后，重启tmux起效，或者先按C+b，然后输入：，进入命令行模式， 在命令行模式下输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source-file ~/.tmux.conf</div></pre></td></tr></table></figure></p><p>你也可以跟我一样，在配置文件中加入下面这句话，以后改了只需要按前缀+r了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#将r 设置为加载配置文件，并显示&quot;reloaded!&quot;信息</div><div class="line">bind r source-file ~/.tmux.conf \; display &quot;Reloaded!&quot;</div></pre></td></tr></table></figure></p><h3 id="复制模式copy-mode"><a href="#复制模式copy-mode" class="headerlink" title="复制模式copy-mode"></a>复制模式copy-mode</h3><ul><li>前缀 [ 进入复制模式</li><li>按 space 开始复制，移动光标选择复制区域</li><li>按 Enter 复制并退出copy-mode。</li><li>将光标移动到指定位置，按 PREIFX ] 粘贴<br>如果把tmux比作vim的话，那么我们大部分时间都是处于编辑模式，我们复制的时候可不可以像 vim一样移动呢？只需要在配置文件(~/.tmux.conf)中加入如下行即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#copy-mode 将快捷键设置为vi 模式</div><div class="line">setw -g mode-keys vi</div></pre></td></tr></table></figure></li></ul><h3 id="开启批量执行"><a href="#开启批量执行" class="headerlink" title="开启批量执行"></a>开启批量执行</h3><p>如果已经修改prefix键位Ctrl+a，则Ctrl+a[默认Ctrl+b]后输入:set synchronize-panes ，输入:set sync [TAB]键可自动补齐</p><h3 id="脚本化启动"><a href="#脚本化启动" class="headerlink" title="脚本化启动"></a>脚本化启动</h3><p>把以下脚本内容加入到~/.bashrc，即可每次登录进入到tmux<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tmux_init()</div><div class="line">&#123;</div><div class="line">tmux new-session -s &quot;kumu&quot; -d -n &quot;local&quot; # 开启一个会话</div><div class="line">tmux new-window -n &quot;other&quot; # 开启一个窗口</div><div class="line">tmux split-window -h # 开启一个竖屏</div><div class="line">tmux split-window -v &quot;top&quot; # 开启一个横屏,并执行top命令</div><div class="line">tmux -2 attach-session -d # tmux -2强制启用256color，连接已开启的tmux</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="自动关联session"><a href="#自动关联session" class="headerlink" title="自动关联session"></a>自动关联session</h3><p>判断是否已有开启的tmux会话，没有则开启，有则关联当前一打开的会话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if which tmux 2&gt;&amp;1 &gt;/dev/null; then</div><div class="line">test -z &quot;$TMUX&quot; &amp;&amp; (tmux attach || tmux_init)</div><div class="line">fi</div></pre></td></tr></table></figure></p><h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><p>使用下列快捷键可以进入滚动模式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ctrl-b [</div></pre></td></tr></table></figure></p><p>这会使你进入滚动模式,然后你可以使用上下键或翻页键进行滚动,翻页.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ctrl-b PageUp</div></pre></td></tr></table></figure></p><p>这个快捷键会使你立即进入滚动模式,并向上翻页.</p><h3 id="自定义状态栏"><a href="#自定义状态栏" class="headerlink" title="自定义状态栏"></a>自定义状态栏</h3><p><a href="http://note4code.com/2016/07/03/tmux-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">TMUX 自定义配置</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">set-option -g status on</div><div class="line">#set -g status-bg blue # 状态栏背景颜色</div><div class="line">set -g status-bg &apos;#333333&apos;</div><div class="line">#set -g status-fg &apos;#bbbbbb&apos; # 状态栏前景颜色</div><div class="line">set -g status-fg &apos;#ffffff&apos;</div><div class="line">set-option -g status-interval 2 # 设置自动刷新的时间间隔</div><div class="line">set-option -g status-justify &quot;centre&quot; # 状态栏对齐</div><div class="line">set -g status-left-fg green</div><div class="line">set -g status-left-bg blue</div><div class="line">set -g status-right-fg green</div><div class="line">set -g status-right-bg blue</div><div class="line">set-option -g status-left-length 60 # 状态栏左侧宽度</div><div class="line">set-option -g status-right-length 90 # 状态栏右侧宽度</div><div class="line">#set-option -g status-left &quot;#(~/tmux-powerline/powerline.sh left)&quot; 通过插件管理</div><div class="line">#set-option -g status-right &quot;#(~/tmux-powerline/powerline.sh right)&quot;</div><div class="line"></div><div class="line">set -g status-left &apos;[#(whoami),#H]&apos;</div><div class="line">#set -g status-left &apos;#[bg=#00bb00] [#S] #[default] &apos; # 状态栏左侧显示 session 的名字</div><div class="line">set -g status-right &apos;[#(date +&quot;%Y-%m-%d %H:%M:%S &quot;)]&apos; # 状态栏右侧显示时间</div><div class="line">#set -g status-right &apos;#[fg=white,bg=#55bb00] [#h] #[fg=white,bg=#009c00] %Y-%m-%d #[fg=white,bg=#007700] %H:%M:%S &apos;</div><div class="line">#set -g status-right &apos;#[fg=white,bg=#444444] [#h] #[fg=white,bg=#666666] %Y-%m-%d #[fg=white,bg=#888888] %H:%M:%S &apos;</div><div class="line"></div><div class="line">#set -g window-status-format &apos;#I #W&apos; # 未激活每个窗口占位的格式</div><div class="line">setw -g window-status-format &apos;#[bg=#0000ff, fg=#ffffff] [#I] #W &apos;</div><div class="line"></div><div class="line">#set -g window-status-current-format &apos; #I #W &apos; # 当前激活窗口在状态栏的展位格式</div><div class="line">setw -g window-status-current-format &apos;#[bg=#ff0000, fg=#ffffff, bold]*[#I] #W*&apos;</div><div class="line"></div><div class="line">setw -g window-status-current-bg blue</div><div class="line">setw -g window-status-current-fg green</div><div class="line"></div><div class="line"># 自动重新编号 window</div><div class="line">set -g renumber-windows on</div><div class="line"></div><div class="line"># pane border colors</div><div class="line">set -g pane-active-border-fg &apos;#55ff55&apos;</div><div class="line">set -g pane-border-fg &apos;#555555&apos;</div></pre></td></tr></table></figure><p>256颜色表<br><img src="http://pic-blog.bfvyun.com/tmux/tmux3.jpg" alt="image"><br>注：图片来自网络</p><h3 id="插件配置状态栏"><a href="#插件配置状态栏" class="headerlink" title="插件配置状态栏"></a>插件配置状态栏</h3><p>使用<a href="https://github.com/erikw/tmux-powerline" target="_blank" rel="external">tmux-powerline</a>插件配置状态栏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd ~</div><div class="line">$ git clone https://github.com/erikw/tmux-powerline.git</div></pre></td></tr></table></figure><p>开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set-option -g status-left &quot;#(~/tmux-powerline/powerline.sh left)&quot;</div><div class="line">set-option -g status-right &quot;#(~/tmux-powerline/powerline.sh right)&quot;</div></pre></td></tr></table></figure><p>显示<code>No weather location specified</code>时，需要修改segments/weather.sh文件，<a href="https://github.com/erikw/tmux-powerline/issues/219" target="_blank" rel="external">参考</a></p><p>securtcrt或者putty中powerline中文显示问题，参考<a href="http://blog.csdn.net/daoshuti/article/details/69788156" target="_blank" rel="external">让putty，secureCRT等工具支持Powerline，oh-my-zsh，解决乱码问题</a></p><h2 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h2><p>安装插件管理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm</div></pre></td></tr></table></figure><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># List of plugins</div><div class="line">set -g @plugin &apos;tmux-plugins/tpm&apos;</div><div class="line">set -g @plugin &apos;tmux-plugins/tmux-sensible&apos;</div><div class="line"></div><div class="line"># Other examples:</div><div class="line"># set -g @plugin &apos;github_username/plugin_name&apos;</div><div class="line"># set -g @plugin &apos;git@github.com/user/plugin&apos;</div><div class="line"># set -g @plugin &apos;git@bitbucket.com/user/plugin&apos;</div><div class="line"></div><div class="line"># Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)</div><div class="line">run &apos;~/.tmux/plugins/tpm/tpm&apos;</div></pre></td></tr></table></figure><p>启用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tmux source ~/.tmux.conf</div></pre></td></tr></table></figure></p><p>安装、升级和反安装插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">prefix shift-i      # install</div><div class="line">prefix shift-u      # update</div><div class="line">prefix alt-u        # uninstall plugins not on the plugin list</div></pre></td></tr></table></figure></p><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h3 id="tmux-resurrect"><a href="#tmux-resurrect" class="headerlink" title="tmux-resurrect"></a><a href="https://github.com/tmux-plugins/tmux-resurrect" target="_blank" rel="external">tmux-resurrect</a></h3><p>保存和恢复 Tmux 会话，面板布局，甚至支持恢复vim会话，重启机器仍可恢复。参考<a href="https://liam0205.me/2016/09/10/tmux-plugin-resurrect/" target="_blank" rel="external">保存和恢复 Tmux 会话</a>。</p><p>在tmux.conf中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set -g @plugin &apos;tmux-plugins/tmux-resurrect&apos;</div></pre></td></tr></table></figure></p><p>添加插件后<code>prefix + I</code>即下载并开启</p><p>参考：<br><a href="http://blog.csdn.net/u012335044/article/details/61923402" target="_blank" rel="external">tmux – Linux终端管理软件</a><br><a href="https://wiki.archlinux.org/index.php/Tmux_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">Tmux (简体中文)</a>)<br><a href="https://www.zybuluo.com/mwumli/note/149542" target="_blank" rel="external">CentOS 下安装 tmux</a><br><a href="https://qiaoanran.com/article/0d268826+Tmux_%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7" target="_blank" rel="external">Tmux 插件管理工具</a><br><a href="https://github.com/jimeh/tmux-themepack" target="_blank" rel="external">tmux-themepack</a><br><a href="https://my.oschina.net/am313/blog/865915" target="_blank" rel="external">在 Linux/Mac 安装 Tmux 及其配置</a><br><a href="https://jin-yang.github.io/post/tmux-introduce.html" target="_blank" rel="external">TMUX 简介</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Tmux是一个优秀的终端复用软件，支持多标签，也支持窗口内部面板的分割，更重要的是，Tmux提供了窗体随时保存和恢复的功能。想象一下假如你在公司的服务器上开了许多窗口调试程序，回到家时通过SSH连接公司电脑又要打开一堆繁琐的窗口，而且还忘记了当时调试到哪一步了，那Tmux可以帮你解决这个难题，当SSH连接断开重新连接后能够恢复到原来的工作环境。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TMUX" scheme="http://mufool.com/tags/TMUX/"/>
    
  </entry>
  
  <entry>
    <title>Putty免密登陆</title>
    <link href="http://mufool.com/2017/09/29/putty/"/>
    <id>http://mufool.com/2017/09/29/putty/</id>
    <published>2017-09-29T07:15:48.000Z</published>
    <updated>2019-03-20T03:10:07.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件，其主要优点有： 完全免费 、全面支持SSH1和SSH2 、绿色软件，无需安装，下载后在桌面建个快捷方式即可使用、体积很小、操作简单。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="external">下载地址</a></p><p>下载msi包安装，或者直接下载exe文件即可。</p><h2 id="免密登陆配置"><a href="#免密登陆配置" class="headerlink" title="免密登陆配置"></a>免密登陆配置</h2><p>PuTTY不提供“记住密码”一类的选项，PuTTY自动登录Linux系统，需要使用公钥/私钥方式。 这种方式需要生成一组对应的公钥（简短的字符串）和密钥（一个文件），然后把公钥放到服务器上，私钥提供给PuTTY。PuTTY仍然不知道你的密码，而是通过与服务器核对密钥而核实身份。</p><h3 id="生成公私钥"><a href="#生成公私钥" class="headerlink" title="生成公私钥"></a>生成公私钥</h3><p>使用PuTTY安装目录里的puttygen.exe工具。先点“生成(Generate)”，然后随意移动鼠标直到进度条填满，即可生成密钥。</p><p><img src="http://pic-blog.bfvyun.com/putty/putty1.jpg" alt="image"></p><p>点击<code>Save private key</code>保存私钥到文件。</p><h3 id="Putty关联私钥"><a href="#Putty关联私钥" class="headerlink" title="Putty关联私钥"></a>Putty关联私钥</h3><p>在Connection -&gt; SSH -&gt; Auth, Private keyfile for authentication中添加上一步生成的私钥文件，同时保存会话。<br><img src="http://pic-blog.bfvyun.com/putty/putty2.jpg" alt="image"></p><h3 id="服务器添加公钥"><a href="#服务器添加公钥" class="headerlink" title="服务器添加公钥"></a>服务器添加公钥</h3><p>在服务器对应的用户文件<code>~/.ssh/authorized_keys</code>，中添加生成第一步生成的公钥即可。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>退出重新登陆putty即可，如配置后仍然报错<code>server refused our key</code>，修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod 700 .ssh #目录权限700</div><div class="line">chmod 600 authorized_keys #文件权限600</div></pre></td></tr></table></figure></p><p>参考：<br><a href="http://blog.csdn.net/xocoder/article/details/45821967" target="_blank" rel="external">linux ssh私钥登陆失败:server refused our key原因</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件，其主要优点有： 完全免费 、全面支持SSH1和SSH2 、绿色软件，无需安装，下载后在桌面建个快捷方式即可使用、体积很小、操作简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PUTTY" scheme="http://mufool.com/tags/PUTTY/"/>
    
  </entry>
  
  <entry>
    <title>Linux inode节点满的解决方法</title>
    <link href="http://mufool.com/2017/09/22/linux-inode/"/>
    <id>http://mufool.com/2017/09/22/linux-inode/</id>
    <published>2017-09-22T09:25:53.000Z</published>
    <updated>2017-09-22T09:26:38.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是inode"><a href="#什么是inode" class="headerlink" title="什么是inode"></a>什么是inode</h2><a id="more"></a><p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。<br>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。<br>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。<br>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df -ih</div></pre></td></tr></table></figure><h2 id="查找满的目录"><a href="#查找满的目录" class="headerlink" title="查找满的目录"></a>查找满的目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for i in /*; do echo $i; find $i | wc -l; done</div></pre></td></tr></table></figure><p>依次对所查找的目录执行以上目录，即可找到哪个目录文件最多，一般情况下是频繁的写小文件或者linux邮件服务导致。</p><h2 id="删除占用文件多的目录"><a href="#删除占用文件多的目录" class="headerlink" title="删除占用文件多的目录"></a>删除占用文件多的目录</h2><p>直接删除目录很慢，进入目录查看文件可能会卡死<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find dir -type f -name &apos;*&apos;  | xargs rm</div></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd dir</div><div class="line">ls | xargs rm -f</div></pre></td></tr></table></figure></p><p>参考：<br><a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="external">理解inode</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是inode&quot;&gt;&lt;a href=&quot;#什么是inode&quot; class=&quot;headerlink&quot; title=&quot;什么是inode&quot;&gt;&lt;/a&gt;什么是inode&lt;/h2&gt;
    
    </summary>
    
    
      <category term="LINUX" scheme="http://mufool.com/tags/LINUX/"/>
    
  </entry>
  
  <entry>
    <title>Grunt打包前端代码</title>
    <link href="http://mufool.com/2017/09/22/grunt-package/"/>
    <id>http://mufool.com/2017/09/22/grunt-package/</id>
    <published>2017-09-22T08:19:23.000Z</published>
    <updated>2017-09-22T08:23:30.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Grunt介绍"><a href="#Grunt介绍" class="headerlink" title="Grunt介绍"></a>Grunt介绍</h2><p>grunt是一套前端自动化构建工具，一个基于nodeJs的命令行工具，一般用于压缩文件，合并文件等，与java世界的Maven工具类似。</p><a id="more"></a><h2 id="Grunt安装"><a href="#Grunt安装" class="headerlink" title="Grunt安装"></a>Grunt安装</h2><p><a href="http://mufool.com/2017/08/21/centos-grunt/">Centos下安装Grunt</a></p><h2 id="Grunt使用"><a href="#Grunt使用" class="headerlink" title="Grunt使用"></a>Grunt使用</h2><p>每一个gurnt都会需要这两个文件package.json和Gruntfile.js，package.json这个文件用来存储npm模块的依赖项，比如我们的打包若是依赖requireJS的插件；Gruntfile.js读取package信息，插件加载、注册任务，运行任务。</p><h3 id="package-json示例"><a href="#package-json示例" class="headerlink" title="package.json示例"></a>package.json示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"clouds"</span>,</div><div class="line">    <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">    <span class="string">"author"</span>: <span class="string">"xx@xx.com"</span>,</div><div class="line">    <span class="string">"description"</span>: <span class="string">"clouds-app"</span>,</div><div class="line">    <span class="string">"dependencies"</span>: &#123;</div><div class="line">        <span class="string">"ejs"</span>: <span class="string">"*"</span>,  </div><div class="line">        <span class="string">"grunt"</span>: <span class="string">"~0.4.1"</span>,</div><div class="line">        <span class="string">"grunt-contrib-less"</span>: <span class="string">"*"</span>,</div><div class="line">        <span class="string">"grunt-contrib-uglify"</span>: <span class="string">"~0.2.2"</span>,</div><div class="line">        <span class="string">"grunt-contrib-cssmin"</span>: <span class="string">"~0.9.0"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>devDependencies中添加所需要的插件，以及对应的版本信息。以及一些会显示在文件中的版本，作者信息等。<br>在已有package.json的情况下，执行<code>npm install</code>会自动将所需要的插件下载到node_modules目录下，</p><h3 id="Gruntfile-js示例"><a href="#Gruntfile-js示例" class="headerlink" title="Gruntfile.js示例"></a>Gruntfile.js示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> zipjs,compileJsConfig,config;</div><div class="line">    config = &#123;</div><div class="line">        pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),</div><div class="line">        ismap: <span class="literal">false</span>,<span class="comment">//是否生成调试代码</span></div><div class="line">        path: &#123;<span class="attr">less</span>: <span class="string">'less/'</span>,<span class="attr">style</span>: <span class="string">'style/'</span>,<span class="attr">script</span>:<span class="string">"script/"</span>,<span class="attr">src</span>:<span class="string">"src/"</span>&#125;,</div><div class="line">        less: &#123; <span class="comment">// 编译 LESS 文件</span></div><div class="line">            compile: &#123;</div><div class="line">                files: &#123;</div><div class="line">                    <span class="string">'&lt;%= path.style %&gt;index.css'</span>:[<span class="string">'&lt;%= path.less %&gt;index.less'</span>],</div><div class="line">                     ......</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        cssmin: &#123; <span class="comment">// 压缩 CSS 文件</span></div><div class="line">            options: &#123;</div><div class="line">                report : <span class="string">"min"</span></div><div class="line">            &#125;,</div><div class="line">            combine: &#123;</div><div class="line">                files: &#123;</div><div class="line">                  <span class="string">'&lt;%= path.style %&gt;index.min.css'</span>: <span class="string">'&lt;%= path.style %&gt;index.css'</span>,</div><div class="line">                ......</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        uglify: &#123;<span class="comment">// 压缩合并 JS 文件</span></div><div class="line">            options: &#123;</div><div class="line">                report:<span class="string">'min'</span>,</div><div class="line">                expand: <span class="literal">true</span>,</div><div class="line">                mangle: <span class="literal">true</span>,</div><div class="line">                sourceMapRoot: <span class="string">'../../'</span>,</div><div class="line">                preserveComments: <span class="string">'false'</span>,</div><div class="line">                beautify: &#123;</div><div class="line">                    ascii_only: <span class="literal">true</span><span class="comment">//中文ascii化,防止中文乱码</span></div><div class="line">                &#125;,</div><div class="line">                banner: <span class="string">'/** \n'</span> +<span class="comment">//生成注释</span></div><div class="line">                        <span class="string">' * -------------------------------------------------------------\n'</span> +</div><div class="line">                        <span class="string">' * Copyright (c) 2014 xx, All rights reserved. \n'</span> +</div><div class="line">                        <span class="string">' * @version: &lt;%= pkg.version%&gt; \n'</span> +</div><div class="line">                        <span class="string">' * @author: &lt;%= pkg.author%&gt; \n'</span> +</div><div class="line">                        <span class="string">' * @description: &lt;%= pkg.description%&gt; \n'</span> +</div><div class="line">                        <span class="string">' * @date: &lt;%=grunt.template.today("yyyy-mm-dd  HH:MM:ss")%&gt;\n'</span> +</div><div class="line">                        <span class="string">' * ------------------------------------------------------------- \n'</span> +</div><div class="line">                        <span class="string">' */ \n\n'</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    zipjs = &#123;<span class="comment">//压缩配置</span></div><div class="line">        swfupload : &#123;</div><div class="line">            namespace : config.path.script+<span class="string">'swfUpload.min.js'</span>,</div><div class="line">            dstname : [config.path.ui+<span class="string">'SwfLoaderBar.js'</span>,config.path.view+<span class="string">'swfUpload.js'</span>]</div><div class="line">        &#125;,</div><div class="line">                ......</div><div class="line">    &#125;;</div><div class="line">    compileJsConfig = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> json;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> zipjs) &#123;<span class="comment">//需要压缩的代码</span></div><div class="line">            json = &#123;&#125;</div><div class="line">            json[zipjs[key].namespace] = zipjs[key].dstname;</div><div class="line">            config.uglify[key] = &#123;<span class="attr">files</span>:json&#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(config.ismap)&#123;</div><div class="line">            config.uglify.options.sourceMap = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;<span class="comment">// 生成 map文件的地址</span></div><div class="line">                <span class="keyword">var</span> file = path.split(<span class="string">"/"</span>),filename = file.pop(),route = file.join(<span class="string">"/"</span>) + <span class="string">"/"</span>;</div><div class="line">                <span class="keyword">return</span> route + <span class="string">"map/"</span> +  filename.replace(<span class="string">'.js'</span>,<span class="string">'.map'</span>);</div><div class="line">            &#125;;</div><div class="line">            config.uglify.options.sourceMappingURL = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;<span class="comment">// 用于定义 map文件地址 并放在压缩文件底部， url相对于 压缩文件</span></div><div class="line">                <span class="keyword">var</span> file = path.split(<span class="string">"/"</span>),filename = file.pop();</div><div class="line">                <span class="keyword">return</span> <span class="string">"map/"</span> +  filename.replace(<span class="string">'.js'</span>,<span class="string">'.map'</span>);</div><div class="line">            &#125;;  </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> config;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//读取配置文件</span></div><div class="line">    grunt.initConfig(compileJsConfig(config));</div><div class="line"></div><div class="line">    <span class="comment">//加载任务的插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-contrib-less'</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-contrib-cssmin'</span>); </div><div class="line"></div><div class="line">    <span class="comment">//注册任务</span></div><div class="line">    grunt.registerTask(<span class="string">'build'</span>, [<span class="string">'less'</span>,<span class="string">'cssmin'</span>,<span class="string">'uglify'</span>]);</div><div class="line">    grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'uglify'</span>]);<span class="comment">//不带参数，及执行uglify</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>参考：<br><a href="http://javascript.ruanyifeng.com/tool/grunt.html" target="_blank" rel="external">Grunt：任务自动管理工具</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Grunt介绍&quot;&gt;&lt;a href=&quot;#Grunt介绍&quot; class=&quot;headerlink&quot; title=&quot;Grunt介绍&quot;&gt;&lt;/a&gt;Grunt介绍&lt;/h2&gt;&lt;p&gt;grunt是一套前端自动化构建工具，一个基于nodeJs的命令行工具，一般用于压缩文件，合并文件等，与java世界的Maven工具类似。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JS" scheme="http://mufool.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Linux压缩命令对比</title>
    <link href="http://mufool.com/2017/09/22/linux-zip/"/>
    <id>http://mufool.com/2017/09/22/linux-zip/</id>
    <published>2017-09-22T08:18:43.000Z</published>
    <updated>2017-09-22T09:03:39.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zip格式的压缩和解压缩"><a href="#zip格式的压缩和解压缩" class="headerlink" title=".zip格式的压缩和解压缩"></a>.zip格式的压缩和解压缩</h2><a id="more"></a><ul><li><p>zip 压缩文件名源文件<br>含义：这条命令压缩的是文件。</p></li><li><p>zip -r 压缩文件名源目录<br>含义：这条命令压缩的是目录，包括目录下的文件一并压缩进去。</p></li><li><p>unzip 压缩文件名<br>含义：解压缩，不管是压缩的文件还是压缩的目录都用此来解压缩</p></li></ul><p>注意：Linux下的.zip和windows下的.zip格式是一样的，也就是说windows下的.zip压缩包可以直接拿到</p><h2 id="gz格式的压缩和解压缩"><a href="#gz格式的压缩和解压缩" class="headerlink" title=".gz格式的压缩和解压缩"></a>.gz格式的压缩和解压缩</h2><ul><li><p>gzip 源文件<br>含义：将源文件压缩为.gz格式，但是源文件会消失。</p></li><li><p>gzip -c 源文件 &gt; 压缩文件<br>含义：将源文件压缩为.gz格式，但是源文件会保留。其实原理是将压缩的.gz输入到“压缩文件”而已。</p></li><li><p>gzip -r 目录<br>含义：压缩目录下的所有子文件，但是注意不能压缩目录。</p></li><li><p>gunzip 压缩文件<br>含义：解压缩。原有的.ga压缩文件会消失的。</p></li><li><p>gzip -d 压缩文件<br>含义：解压缩。同上。</p></li><li><p>gunzip -r 目录<br>含义：将目录下所有的.gz格式的文件解压缩。</p></li></ul><p>注意：windows下的.rar格式压缩文件不能在Linux下使用。.gz格式是Linux下独有的压缩格式，但是也可以在windows下被解压缩。</p><h2 id="bz2格式的压缩与解压缩"><a href="#bz2格式的压缩与解压缩" class="headerlink" title=".bz2格式的压缩与解压缩"></a>.bz2格式的压缩与解压缩</h2><ul><li><p>bzip2 源文件<br>含义：压缩源文件为.bz2格式，不保留源文件。</p></li><li><p>bzip2 -k 源文件<br>含义：压缩源文件，但是保留源文件。</p></li></ul><p>注意：.bz2不支持压缩目录。</p><ul><li><p>bzip2 -d 压缩文件<br>含义：解压缩。如果加选项“-k”，则保留压缩文件</p></li><li><p>bunzip2 压缩文件<br>含义：解压缩。如果加选项“-k”，则保留压缩文件</p></li></ul><h2 id="tar-gz和tar-bz2格式的压缩和解压缩"><a href="#tar-gz和tar-bz2格式的压缩和解压缩" class="headerlink" title=".tar.gz和tar.bz2格式的压缩和解压缩"></a>.tar.gz和tar.bz2格式的压缩和解压缩</h2><p>为了解决.gz格式不能压缩目录，所以Linux给出了.tar.gz的压缩格式。它的原理其实就是先将目录（也可以将文件）打包成一个.tar格式的单一文件包，然后再使用.gz的压缩方式对其压缩。那么我们就按照它的实现原理来讲几个命令：</p><h3 id="打包成-tar-gz格式。"><a href="#打包成-tar-gz格式。" class="headerlink" title="打包成.tar.gz格式。"></a>打包成.tar.gz格式。</h3><p>先将文件或者目录打包成.tart格式，使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -cvf 打包文件名源文件</div></pre></td></tr></table></figure></p><p>选项：</p><ul><li>-c 打包的意思</li><li>-v 显示过程</li><li>-f 指定打包后的文件名</li></ul><p>比如我们打包出了文件”cangls.tar”，然后再将其打包成.tar.gz。直接使用.gz格式的命令即可。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip cangls.tar</div></pre></td></tr></table></figure></p><p>这样子最终就打包成了cangls.tar.ga格式的压缩包了。</p><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><p>下面我们可以一步步的将.tar.gz解压缩。首先使用.gz的命令解压成.tar格式，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gunzip cangls.tar.gz</div></pre></td></tr></table></figure></p><p>这样子就会被解压成cangls.tar。然后再使用.tar的解压方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -xvf cangls.tar</div></pre></td></tr></table></figure></p><p>这样子就最终解压成了cangls。</p><p>上面说的是其实现原理，你可以这样子一步步来压缩。也可以一步将文件或者目录打包成.tar.gz格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zcvf 压缩包名源文件</div></pre></td></tr></table></figure></p><p>选项：</p><ul><li>-z 就是直接打包成.tar.gz格式的意思</li></ul><p>一句话将.tar.gz格式解压缩：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf 压缩包名</div></pre></td></tr></table></figure></p><p>而关于.tar.bz2的实现原理跟上面是一样的，这里就不再多说。</p><p>下面做一下总结，其实.tar.gz和.tar.bz2是linux下最常用的命令。对于初学者，只需要记住一下几个命令即可：</p><p>一般记住下面的命令即可：</p><ul><li><p>tar -zcvf 压缩包名源文件或者目录<br>含义：将源文件或者目录打包成.tar.gz格式。</p></li><li><p>tar -zxvf 压缩包名<br>含义：将.tar.gz格式的包解压。</p></li><li><p>tar -jcvf 压缩包名源文件或者目录名<br>含义：将源文件或者目录压缩成.tar.bz2格式的包。</p></li><li><p>tar -jxvf 压缩包名<br>含义：将.tar.bz2格式解压缩</p></li></ul><p>上面的命令都是压缩到或者解压到当前目录下，如果想压缩到或者解压到其他目录下呢？</p><p>用下面的两个示例来说明一下方法吧：</p><ul><li><p>tar -zxvf cangls.tar.gz -c /tmp/<br>含义：将cangls.tar.gz解压到tmp目录下。也就是说，后面跟上“-c 目录名”，就是要解压到的地方。</p></li><li><p>tar -zcvf /tmp/cangls.tar.gz cangls<br>含义：将cangls压缩到/tmp目录下，并且命名为cangls.tar.gz。也就是压缩到哪里，在前面直接加上目录即可。</p></li></ul><h2 id="各个压缩命令比较"><a href="#各个压缩命令比较" class="headerlink" title="各个压缩命令比较"></a>各个压缩命令比较</h2><p>已一个163M的node目录为例进行压缩比较</p><ul><li>tar -cvf node.tar node<br>压缩完后148M</li><li>zip -r node.zip node<br>压缩完后44M</li><li>tar -zcvf node.tgz node<br>压缩完后34M</li><li>tar -jcvf node.tar.bz node<br>压缩完后28M</li><li>tar -jcvf node.tar.bz2 node<br>压缩完后28M，只是bz2的压缩速度更快</li></ul><p>综合起来，在压缩比率上： tar.bz=tar.bz2&gt;tgz&gt;zip&gt;tar<br>耗费时间（打包，解压）<br>打包：tar.bz&gt;tar.bz2&gt;tgz&gt;zip&gt;tar<br>解压： tar.bz&gt;tar.bz2&gt;zip&gt;tar&gt;tgz<br>从效率角度来说，当然是耗费时间越短越好，可以根据需要选择不同的压缩工具，物理空间和时间上不能两全。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;zip格式的压缩和解压缩&quot;&gt;&lt;a href=&quot;#zip格式的压缩和解压缩&quot; class=&quot;headerlink&quot; title=&quot;.zip格式的压缩和解压缩&quot;&gt;&lt;/a&gt;.zip格式的压缩和解压缩&lt;/h2&gt;
    
    </summary>
    
    
      <category term="ZIP" scheme="http://mufool.com/tags/ZIP/"/>
    
  </entry>
  
</feed>
